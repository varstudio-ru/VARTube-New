{"version":3,"file":"s123_core.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACj8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC75BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxoDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AENA;AACA;AACA;AACA","sources":["webpack://S123Core/webpack/universalModuleDefinition","webpack://S123Core/./plugins/lodash_get.js","webpack://S123Core/./src/Core/changeable.ts","webpack://S123Core/./src/Environment/environment.ts","webpack://S123Core/./src/MeshUtils/batching.ts","webpack://S123Core/./src/MeshUtils/generator.ts","webpack://S123Core/./src/MeshUtils/meshslice.ts","webpack://S123Core/./src/MeshUtils/unwrapper.ts","webpack://S123Core/./src/Product/builder.ts","webpack://S123Core/./src/Product/product.ts","webpack://S123Core/./src/Product/product_parts.ts","webpack://S123Core/./src/Product/shape.ts","webpack://S123Core/./src/Product/virtual_object.ts","webpack://S123Core/./src/Project/DTOs/ProjectComponent/array_modifier.ts","webpack://S123Core/./src/Project/DTOs/ProjectComponent/builtin_modifier.ts","webpack://S123Core/./src/Project/DTOs/ProjectComponent/component_modifier.ts","webpack://S123Core/./src/Project/DTOs/ProjectComponent/dummy_modifier.ts","webpack://S123Core/./src/Project/DTOs/ProjectComponent/ldsp_modifier.ts","webpack://S123Core/./src/Project/DTOs/ProjectComponent/mesh_modifier.ts","webpack://S123Core/./src/Project/DTOs/ProjectComponent/other_modifiers.ts","webpack://S123Core/./src/Project/DTOs/ProjectComponent/processing.ts","webpack://S123Core/./src/Project/DTOs/ProjectComponent/project_component.ts","webpack://S123Core/./src/Project/DTOs/ProjectComponent/shape_modifier.ts","webpack://S123Core/./src/Project/DTOs/VirtualObject/camera_modifier.ts","webpack://S123Core/./src/Project/DTOs/VirtualObject/light_modifier.ts","webpack://S123Core/./src/Project/DTOs/VirtualObject/manipulator_modifier.ts","webpack://S123Core/./src/Project/DTOs/VirtualObject/points_distance_modifier.ts","webpack://S123Core/./src/Project/DTOs/VirtualObject/shadow_plane_modifier.ts","webpack://S123Core/./src/Project/DTOs/VirtualObject/virtual_object.ts","webpack://S123Core/./src/Project/DTOs/VirtualObject/virtual_object_modifier.ts","webpack://S123Core/./src/Project/DTOs/connectable_project_item.ts","webpack://S123Core/./src/Project/DTOs/connection_point.ts","webpack://S123Core/./src/Project/DTOs/positioning_point.ts","webpack://S123Core/./src/Project/DTOs/project.ts","webpack://S123Core/./src/Project/DTOs/project_item.ts","webpack://S123Core/./src/Project/Implementations/connectable_project_item_implementation.ts","webpack://S123Core/./src/Project/Implementations/positioning_point_implementation.ts","webpack://S123Core/./src/Project/Implementations/project_assembler.ts","webpack://S123Core/./src/Project/Implementations/project_component_implementation.ts","webpack://S123Core/./src/Project/Implementations/project_item_implementation.ts","webpack://S123Core/./src/Project/enums.ts","webpack://S123Core/./src/Project/utils.ts","webpack://S123Core/./src/filesystem.ts","webpack://S123Core/./src/graph.ts","webpack://S123Core/./src/iik.ts","webpack://S123Core/./src/index.ts","webpack://S123Core/./src/logger.ts","webpack://S123Core/./src/material.ts","webpack://S123Core/./src/math.ts","webpack://S123Core/./src/utils.ts","webpack://S123Core/webpack/bootstrap","webpack://S123Core/webpack/runtime/define property getters","webpack://S123Core/webpack/runtime/global","webpack://S123Core/webpack/runtime/hasOwnProperty shorthand","webpack://S123Core/webpack/runtime/make namespace object","webpack://S123Core/webpack/before-startup","webpack://S123Core/webpack/startup","webpack://S123Core/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"S123Core\"] = factory();\n\telse\n\t\troot[\"S123Core\"] = factory();\n})(this, () => {\nreturn ","/**\r\n * lodash (Custom Build) <https://lodash.com/>\r\n * Build: `lodash modularize exports=\"npm\" -o ./`\r\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\r\n * Released under MIT license <https://lodash.com/license>\r\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\r\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n */\r\n\r\n/** Used as the `TypeError` message for \"Functions\" methods. */\r\nvar FUNC_ERROR_TEXT = \"Expected a function\";\r\n\r\n/** Used to stand-in for `undefined` hash values. */\r\nvar HASH_UNDEFINED = \"__lodash_hash_undefined__\";\r\n\r\n/** Used as references for various `Number` constants. */\r\nvar INFINITY = 1 / 0;\r\n\r\n/** `Object#toString` result references. */\r\nvar funcTag = \"[object Function]\",\r\n  genTag = \"[object GeneratorFunction]\",\r\n  symbolTag = \"[object Symbol]\";\r\n\r\n/** Used to match property names within property paths. */\r\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\r\n  reIsPlainProp = /^\\w*$/,\r\n  reLeadingDot = /^\\./,\r\n  rePropName =\r\n    /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\r\n\r\n/**\r\n * Used to match `RegExp`\r\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\r\n */\r\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\r\n\r\n/** Used to match backslashes in property paths. */\r\nvar reEscapeChar = /\\\\(\\\\)?/g;\r\n\r\n/** Used to detect host constructors (Safari). */\r\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\r\n\r\n/** Detect free variable `global` from Node.js. */\r\nvar freeGlobal =\r\n  typeof global == \"object\" && global && global.Object === Object && global;\r\n\r\n/** Detect free variable `self`. */\r\nvar freeSelf =\r\n  typeof self == \"object\" && self && self.Object === Object && self;\r\n\r\n/** Used as a reference to the global object. */\r\nvar root = freeGlobal || freeSelf || Function(\"return this\")();\r\n\r\n/**\r\n * Gets the value at `key` of `object`.\r\n *\r\n * @private\r\n * @param {Object} [object] The object to query.\r\n * @param {string} key The key of the property to get.\r\n * @returns {*} Returns the property value.\r\n */\r\nfunction getValue(object, key) {\r\n  return object == null ? undefined : object[key];\r\n}\r\n\r\n/**\r\n * Checks if `value` is a host object in IE < 9.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\r\n */\r\nfunction isHostObject(value) {\r\n  // Many host objects are `Object` objects that can coerce to strings\r\n  // despite having improperly defined `toString` methods.\r\n  var result = false;\r\n  if (value != null && typeof value.toString != \"function\") {\r\n    try {\r\n      result = !!(value + \"\");\r\n    } catch (e) {}\r\n  }\r\n  return result;\r\n}\r\n\r\n/** Used for built-in method references. */\r\nvar arrayProto = Array.prototype,\r\n  funcProto = Function.prototype,\r\n  objectProto = Object.prototype;\r\n\r\n/** Used to detect overreaching core-js shims. */\r\nvar coreJsData = root[\"__core-js_shared__\"];\r\n\r\n/** Used to detect methods masquerading as native. */\r\nvar maskSrcKey = (function () {\r\n  var uid = /[^.]+$/.exec(\r\n    (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || \"\",\r\n  );\r\n  return uid ? \"Symbol(src)_1.\" + uid : \"\";\r\n})();\r\n\r\n/** Used to resolve the decompiled source of functions. */\r\nvar funcToString = funcProto.toString;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * Used to resolve the\r\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\r\n * of values.\r\n */\r\nvar objectToString = objectProto.toString;\r\n\r\n/** Used to detect if a method is native. */\r\nvar reIsNative = RegExp(\r\n  \"^\" +\r\n    funcToString\r\n      .call(hasOwnProperty)\r\n      .replace(reRegExpChar, \"\\\\$&\")\r\n      .replace(\r\n        /hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,\r\n        \"$1.*?\",\r\n      ) +\r\n    \"$\",\r\n);\r\n\r\n/** Built-in value references. */\r\nvar Symbol = root.Symbol,\r\n  splice = arrayProto.splice;\r\n\r\n/* Built-in method references that are verified to be native. */\r\nvar Map = getNative(root, \"Map\"),\r\n  nativeCreate = getNative(Object, \"create\");\r\n\r\n/** Used to convert symbols to primitives and strings. */\r\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\r\n  symbolToString = symbolProto ? symbolProto.toString : undefined;\r\n\r\n/**\r\n * Creates a hash object.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\nfunction Hash(entries) {\r\n  var index = -1,\r\n    length = entries ? entries.length : 0;\r\n\r\n  this.clear();\r\n  while (++index < length) {\r\n    var entry = entries[index];\r\n    this.set(entry[0], entry[1]);\r\n  }\r\n}\r\n\r\n/**\r\n * Removes all key-value entries from the hash.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf Hash\r\n */\r\nfunction hashClear() {\r\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\r\n}\r\n\r\n/**\r\n * Removes `key` and its value from the hash.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf Hash\r\n * @param {Object} hash The hash to modify.\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\nfunction hashDelete(key) {\r\n  return this.has(key) && delete this.__data__[key];\r\n}\r\n\r\n/**\r\n * Gets the hash value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf Hash\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\nfunction hashGet(key) {\r\n  var data = this.__data__;\r\n  if (nativeCreate) {\r\n    var result = data[key];\r\n    return result === HASH_UNDEFINED ? undefined : result;\r\n  }\r\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\r\n}\r\n\r\n/**\r\n * Checks if a hash value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf Hash\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\nfunction hashHas(key) {\r\n  var data = this.__data__;\r\n  return nativeCreate\r\n    ? data[key] !== undefined\r\n    : hasOwnProperty.call(data, key);\r\n}\r\n\r\n/**\r\n * Sets the hash `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf Hash\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the hash instance.\r\n */\r\nfunction hashSet(key, value) {\r\n  var data = this.__data__;\r\n  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\r\n  return this;\r\n}\r\n\r\n// Add methods to `Hash`.\r\nHash.prototype.clear = hashClear;\r\nHash.prototype[\"delete\"] = hashDelete;\r\nHash.prototype.get = hashGet;\r\nHash.prototype.has = hashHas;\r\nHash.prototype.set = hashSet;\r\n\r\n/**\r\n * Creates an list cache object.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\nfunction ListCache(entries) {\r\n  var index = -1,\r\n    length = entries ? entries.length : 0;\r\n\r\n  this.clear();\r\n  while (++index < length) {\r\n    var entry = entries[index];\r\n    this.set(entry[0], entry[1]);\r\n  }\r\n}\r\n\r\n/**\r\n * Removes all key-value entries from the list cache.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf ListCache\r\n */\r\nfunction listCacheClear() {\r\n  this.__data__ = [];\r\n}\r\n\r\n/**\r\n * Removes `key` and its value from the list cache.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf ListCache\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\nfunction listCacheDelete(key) {\r\n  var data = this.__data__,\r\n    index = assocIndexOf(data, key);\r\n\r\n  if (index < 0) {\r\n    return false;\r\n  }\r\n  var lastIndex = data.length - 1;\r\n  if (index == lastIndex) {\r\n    data.pop();\r\n  } else {\r\n    splice.call(data, index, 1);\r\n  }\r\n  return true;\r\n}\r\n\r\n/**\r\n * Gets the list cache value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf ListCache\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\nfunction listCacheGet(key) {\r\n  var data = this.__data__,\r\n    index = assocIndexOf(data, key);\r\n\r\n  return index < 0 ? undefined : data[index][1];\r\n}\r\n\r\n/**\r\n * Checks if a list cache value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf ListCache\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\nfunction listCacheHas(key) {\r\n  return assocIndexOf(this.__data__, key) > -1;\r\n}\r\n\r\n/**\r\n * Sets the list cache `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf ListCache\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the list cache instance.\r\n */\r\nfunction listCacheSet(key, value) {\r\n  var data = this.__data__,\r\n    index = assocIndexOf(data, key);\r\n\r\n  if (index < 0) {\r\n    data.push([key, value]);\r\n  } else {\r\n    data[index][1] = value;\r\n  }\r\n  return this;\r\n}\r\n\r\n// Add methods to `ListCache`.\r\nListCache.prototype.clear = listCacheClear;\r\nListCache.prototype[\"delete\"] = listCacheDelete;\r\nListCache.prototype.get = listCacheGet;\r\nListCache.prototype.has = listCacheHas;\r\nListCache.prototype.set = listCacheSet;\r\n\r\n/**\r\n * Creates a map cache object to store key-value pairs.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\nfunction MapCache(entries) {\r\n  var index = -1,\r\n    length = entries ? entries.length : 0;\r\n\r\n  this.clear();\r\n  while (++index < length) {\r\n    var entry = entries[index];\r\n    this.set(entry[0], entry[1]);\r\n  }\r\n}\r\n\r\n/**\r\n * Removes all key-value entries from the map.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf MapCache\r\n */\r\nfunction mapCacheClear() {\r\n  this.__data__ = {\r\n    hash: new Hash(),\r\n    map: new (Map || ListCache)(),\r\n    string: new Hash(),\r\n  };\r\n}\r\n\r\n/**\r\n * Removes `key` and its value from the map.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf MapCache\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\nfunction mapCacheDelete(key) {\r\n  return getMapData(this, key)[\"delete\"](key);\r\n}\r\n\r\n/**\r\n * Gets the map value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf MapCache\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\nfunction mapCacheGet(key) {\r\n  return getMapData(this, key).get(key);\r\n}\r\n\r\n/**\r\n * Checks if a map value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf MapCache\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\nfunction mapCacheHas(key) {\r\n  return getMapData(this, key).has(key);\r\n}\r\n\r\n/**\r\n * Sets the map `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf MapCache\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the map cache instance.\r\n */\r\nfunction mapCacheSet(key, value) {\r\n  getMapData(this, key).set(key, value);\r\n  return this;\r\n}\r\n\r\n// Add methods to `MapCache`.\r\nMapCache.prototype.clear = mapCacheClear;\r\nMapCache.prototype[\"delete\"] = mapCacheDelete;\r\nMapCache.prototype.get = mapCacheGet;\r\nMapCache.prototype.has = mapCacheHas;\r\nMapCache.prototype.set = mapCacheSet;\r\n\r\n/**\r\n * Gets the index at which the `key` is found in `array` of key-value pairs.\r\n *\r\n * @private\r\n * @param {Array} array The array to inspect.\r\n * @param {*} key The key to search for.\r\n * @returns {number} Returns the index of the matched value, else `-1`.\r\n */\r\nfunction assocIndexOf(array, key) {\r\n  var length = array.length;\r\n  while (length--) {\r\n    if (eq(array[length][0], key)) {\r\n      return length;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\n/**\r\n * The base implementation of `_.get` without support for default values.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @param {Array|string} path The path of the property to get.\r\n * @returns {*} Returns the resolved value.\r\n */\r\nfunction baseGet(object, path) {\r\n  path = isKey(path, object) ? [path] : castPath(path);\r\n\r\n  var index = 0,\r\n    length = path.length;\r\n\r\n  while (object != null && index < length) {\r\n    object = object[toKey(path[index++])];\r\n  }\r\n  return index && index == length ? object : undefined;\r\n}\r\n\r\n/**\r\n * The base implementation of `_.isNative` without bad shim checks.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a native function,\r\n *  else `false`.\r\n */\r\nfunction baseIsNative(value) {\r\n  if (!isObject(value) || isMasked(value)) {\r\n    return false;\r\n  }\r\n  var pattern =\r\n    isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;\r\n  return pattern.test(toSource(value));\r\n}\r\n\r\n/**\r\n * The base implementation of `_.toString` which doesn't convert nullish\r\n * values to empty strings.\r\n *\r\n * @private\r\n * @param {*} value The value to process.\r\n * @returns {string} Returns the string.\r\n */\r\nfunction baseToString(value) {\r\n  // Exit early for strings to avoid a performance hit in some environments.\r\n  if (typeof value == \"string\") {\r\n    return value;\r\n  }\r\n  if (isSymbol(value)) {\r\n    return symbolToString ? symbolToString.call(value) : \"\";\r\n  }\r\n  var result = value + \"\";\r\n  return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\r\n}\r\n\r\n/**\r\n * Casts `value` to a path array if it's not one.\r\n *\r\n * @private\r\n * @param {*} value The value to inspect.\r\n * @returns {Array} Returns the cast property path array.\r\n */\r\nfunction castPath(value) {\r\n  return isArray(value) ? value : stringToPath(value);\r\n}\r\n\r\n/**\r\n * Gets the data for `map`.\r\n *\r\n * @private\r\n * @param {Object} map The map to query.\r\n * @param {string} key The reference key.\r\n * @returns {*} Returns the map data.\r\n */\r\nfunction getMapData(map, key) {\r\n  var data = map.__data__;\r\n  return isKeyable(key)\r\n    ? data[typeof key == \"string\" ? \"string\" : \"hash\"]\r\n    : data.map;\r\n}\r\n\r\n/**\r\n * Gets the native function at `key` of `object`.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @param {string} key The key of the method to get.\r\n * @returns {*} Returns the function if it's native, else `undefined`.\r\n */\r\nfunction getNative(object, key) {\r\n  var value = getValue(object, key);\r\n  return baseIsNative(value) ? value : undefined;\r\n}\r\n\r\n/**\r\n * Checks if `value` is a property name and not a property path.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @param {Object} [object] The object to query keys on.\r\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\r\n */\r\nfunction isKey(value, object) {\r\n  if (isArray(value)) {\r\n    return false;\r\n  }\r\n  var type = typeof value;\r\n  if (\r\n    type == \"number\" ||\r\n    type == \"symbol\" ||\r\n    type == \"boolean\" ||\r\n    value == null ||\r\n    isSymbol(value)\r\n  ) {\r\n    return true;\r\n  }\r\n  return (\r\n    reIsPlainProp.test(value) ||\r\n    !reIsDeepProp.test(value) ||\r\n    (object != null && value in Object(object))\r\n  );\r\n}\r\n\r\n/**\r\n * Checks if `value` is suitable for use as unique object key.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\r\n */\r\nfunction isKeyable(value) {\r\n  var type = typeof value;\r\n  return type == \"string\" ||\r\n    type == \"number\" ||\r\n    type == \"symbol\" ||\r\n    type == \"boolean\"\r\n    ? value !== \"__proto__\"\r\n    : value === null;\r\n}\r\n\r\n/**\r\n * Checks if `func` has its source masked.\r\n *\r\n * @private\r\n * @param {Function} func The function to check.\r\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\r\n */\r\nfunction isMasked(func) {\r\n  return !!maskSrcKey && maskSrcKey in func;\r\n}\r\n\r\n/**\r\n * Converts `string` to a property path array.\r\n *\r\n * @private\r\n * @param {string} string The string to convert.\r\n * @returns {Array} Returns the property path array.\r\n */\r\nvar stringToPath = memoize(function (string) {\r\n  string = toString(string);\r\n\r\n  var result = [];\r\n  if (reLeadingDot.test(string)) {\r\n    result.push(\"\");\r\n  }\r\n  string.replace(rePropName, function (match, number, quote, string) {\r\n    result.push(quote ? string.replace(reEscapeChar, \"$1\") : number || match);\r\n  });\r\n  return result;\r\n});\r\n\r\n/**\r\n * Converts `value` to a string key if it's not a string or symbol.\r\n *\r\n * @private\r\n * @param {*} value The value to inspect.\r\n * @returns {string|symbol} Returns the key.\r\n */\r\nfunction toKey(value) {\r\n  if (typeof value == \"string\" || isSymbol(value)) {\r\n    return value;\r\n  }\r\n  var result = value + \"\";\r\n  return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\r\n}\r\n\r\n/**\r\n * Converts `func` to its source code.\r\n *\r\n * @private\r\n * @param {Function} func The function to process.\r\n * @returns {string} Returns the source code.\r\n */\r\nfunction toSource(func) {\r\n  if (func != null) {\r\n    try {\r\n      return funcToString.call(func);\r\n    } catch (e) {}\r\n    try {\r\n      return func + \"\";\r\n    } catch (e) {}\r\n  }\r\n  return \"\";\r\n}\r\n\r\n/**\r\n * Creates a function that memoizes the result of `func`. If `resolver` is\r\n * provided, it determines the cache key for storing the result based on the\r\n * arguments provided to the memoized function. By default, the first argument\r\n * provided to the memoized function is used as the map cache key. The `func`\r\n * is invoked with the `this` binding of the memoized function.\r\n *\r\n * **Note:** The cache is exposed as the `cache` property on the memoized\r\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\r\n * constructor with one whose instances implement the\r\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\r\n * method interface of `delete`, `get`, `has`, and `set`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Function\r\n * @param {Function} func The function to have its output memoized.\r\n * @param {Function} [resolver] The function to resolve the cache key.\r\n * @returns {Function} Returns the new memoized function.\r\n * @example\r\n *\r\n * var object = { 'a': 1, 'b': 2 };\r\n * var other = { 'c': 3, 'd': 4 };\r\n *\r\n * var values = _.memoize(_.values);\r\n * values(object);\r\n * // => [1, 2]\r\n *\r\n * values(other);\r\n * // => [3, 4]\r\n *\r\n * object.a = 2;\r\n * values(object);\r\n * // => [1, 2]\r\n *\r\n * // Modify the result cache.\r\n * values.cache.set(object, ['a', 'b']);\r\n * values(object);\r\n * // => ['a', 'b']\r\n *\r\n * // Replace `_.memoize.Cache`.\r\n * _.memoize.Cache = WeakMap;\r\n */\r\nfunction memoize(func, resolver) {\r\n  if (\r\n    typeof func != \"function\" ||\r\n    (resolver && typeof resolver != \"function\")\r\n  ) {\r\n    throw new TypeError(FUNC_ERROR_TEXT);\r\n  }\r\n  var memoized = function () {\r\n    var args = arguments,\r\n      key = resolver ? resolver.apply(this, args) : args[0],\r\n      cache = memoized.cache;\r\n\r\n    if (cache.has(key)) {\r\n      return cache.get(key);\r\n    }\r\n    var result = func.apply(this, args);\r\n    memoized.cache = cache.set(key, result);\r\n    return result;\r\n  };\r\n  memoized.cache = new (memoize.Cache || MapCache)();\r\n  return memoized;\r\n}\r\n\r\n// Assign cache to `_.memoize`.\r\nmemoize.Cache = MapCache;\r\n\r\n/**\r\n * Performs a\r\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n * comparison between two values to determine if they are equivalent.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to compare.\r\n * @param {*} other The other value to compare.\r\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\r\n * @example\r\n *\r\n * var object = { 'a': 1 };\r\n * var other = { 'a': 1 };\r\n *\r\n * _.eq(object, object);\r\n * // => true\r\n *\r\n * _.eq(object, other);\r\n * // => false\r\n *\r\n * _.eq('a', 'a');\r\n * // => true\r\n *\r\n * _.eq('a', Object('a'));\r\n * // => false\r\n *\r\n * _.eq(NaN, NaN);\r\n * // => true\r\n */\r\nfunction eq(value, other) {\r\n  return value === other || (value !== value && other !== other);\r\n}\r\n\r\n/**\r\n * Checks if `value` is classified as an `Array` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\r\n * @example\r\n *\r\n * _.isArray([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isArray(document.body.children);\r\n * // => false\r\n *\r\n * _.isArray('abc');\r\n * // => false\r\n *\r\n * _.isArray(_.noop);\r\n * // => false\r\n */\r\nvar isArray = Array.isArray;\r\n\r\n/**\r\n * Checks if `value` is classified as a `Function` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\r\n * @example\r\n *\r\n * _.isFunction(_);\r\n * // => true\r\n *\r\n * _.isFunction(/abc/);\r\n * // => false\r\n */\r\nfunction isFunction(value) {\r\n  // The use of `Object#toString` avoids issues with the `typeof` operator\r\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\r\n  var tag = isObject(value) ? objectToString.call(value) : \"\";\r\n  return tag == funcTag || tag == genTag;\r\n}\r\n\r\n/**\r\n * Checks if `value` is the\r\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\r\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\r\n * @example\r\n *\r\n * _.isObject({});\r\n * // => true\r\n *\r\n * _.isObject([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isObject(_.noop);\r\n * // => true\r\n *\r\n * _.isObject(null);\r\n * // => false\r\n */\r\nfunction isObject(value) {\r\n  var type = typeof value;\r\n  return !!value && (type == \"object\" || type == \"function\");\r\n}\r\n\r\n/**\r\n * Checks if `value` is object-like. A value is object-like if it's not `null`\r\n * and has a `typeof` result of \"object\".\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\r\n * @example\r\n *\r\n * _.isObjectLike({});\r\n * // => true\r\n *\r\n * _.isObjectLike([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isObjectLike(_.noop);\r\n * // => false\r\n *\r\n * _.isObjectLike(null);\r\n * // => false\r\n */\r\nfunction isObjectLike(value) {\r\n  return !!value && typeof value == \"object\";\r\n}\r\n\r\n/**\r\n * Checks if `value` is classified as a `Symbol` primitive or object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\r\n * @example\r\n *\r\n * _.isSymbol(Symbol.iterator);\r\n * // => true\r\n *\r\n * _.isSymbol('abc');\r\n * // => false\r\n */\r\nfunction isSymbol(value) {\r\n  return (\r\n    typeof value == \"symbol\" ||\r\n    (isObjectLike(value) && objectToString.call(value) == symbolTag)\r\n  );\r\n}\r\n\r\n/**\r\n * Converts `value` to a string. An empty string is returned for `null`\r\n * and `undefined` values. The sign of `-0` is preserved.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to process.\r\n * @returns {string} Returns the string.\r\n * @example\r\n *\r\n * _.toString(null);\r\n * // => ''\r\n *\r\n * _.toString(-0);\r\n * // => '-0'\r\n *\r\n * _.toString([1, 2, 3]);\r\n * // => '1,2,3'\r\n */\r\nfunction toString(value) {\r\n  return value == null ? \"\" : baseToString(value);\r\n}\r\n\r\n/**\r\n * Gets the value at `path` of `object`. If the resolved value is\r\n * `undefined`, the `defaultValue` is returned in its place.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.7.0\r\n * @category Object\r\n * @param {Object} object The object to query.\r\n * @param {Array|string} path The path of the property to get.\r\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\r\n * @returns {*} Returns the resolved value.\r\n * @example\r\n *\r\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\r\n *\r\n * _.get(object, 'a[0].b.c');\r\n * // => 3\r\n *\r\n * _.get(object, ['a', '0', 'b', 'c']);\r\n * // => 3\r\n *\r\n * _.get(object, 'a.b.c', 'default');\r\n * // => 'default'\r\n */\r\nfunction get(object, path, defaultValue) {\r\n  var result = object == null ? undefined : baseGet(object, path);\r\n  return result === undefined ? defaultValue : result;\r\n}\r\n\r\nexport default get;\r\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Changeable = void 0;\nclass Changeable {\n    UpdateFrom(data) {\n        const keys = Object.keys(this);\n        for (const key of keys) {\n            if (data.hasOwnProperty(key)) {\n                if (typeof this[key] == \"object\" &&\n                    data[key] != null &&\n                    this[key] instanceof Changeable) {\n                    this[key].UpdateFrom(data[key]);\n                }\n                else {\n                    this[key] = data[key];\n                }\n            }\n        }\n    }\n}\nexports.Changeable = Changeable;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorldSettingsFactory = exports.LightSettingsFactory = exports.GroundedSkyboxSettingsFactory = exports.BackgroundSettingsFactory = exports.EnvironmentSettingsFactory = exports.DEFAULT_BACKGROUND_COLOR = exports.ENVMAP_RESOLUTIONS = void 0;\nconst utils_1 = require(\"../Project/utils\");\nconst math_1 = require(\"../math\");\nexports.ENVMAP_RESOLUTIONS = [\"1k\", \"2k\", \"4k\", \"8k\"];\nexports.DEFAULT_BACKGROUND_COLOR = \"#e6e6e6\";\nclass EnvironmentSettingsFactory {\n    static CreateNew() {\n        return {\n            type: \"default\",\n            name: \"\",\n            customId: -1,\n            resolution: \"1k\",\n            rotation: new math_1.Quaternion(0, 0, 0, 1),\n            intensity: 1\n        };\n    }\n    static Create(raw) {\n        return {\n            type: raw[(0, utils_1.nameof)('type')] || \"default\",\n            name: raw[(0, utils_1.nameof)('name')] || \"\",\n            customId: raw[(0, utils_1.nameof)('customId')] || -1,\n            resolution: raw[(0, utils_1.nameof)('resolution')] || \"1k\",\n            rotation: raw[(0, utils_1.nameof)('rotation')] ? new math_1.Quaternion(raw[(0, utils_1.nameof)('rotation')]) : new math_1.Quaternion(0, 0, 0, 1),\n            intensity: raw[(0, utils_1.nameof)('intensity')] || 1\n        };\n    }\n}\nexports.EnvironmentSettingsFactory = EnvironmentSettingsFactory;\nclass BackgroundSettingsFactory {\n    static CreateNew() {\n        return {\n            type: \"color\",\n            blurriness: 0,\n            color: exports.DEFAULT_BACKGROUND_COLOR,\n            imageId: \"\"\n        };\n    }\n    static Create(raw) {\n        return {\n            type: raw[(0, utils_1.nameof)('type')] || \"color\",\n            blurriness: raw[(0, utils_1.nameof)('blurriness')] || 0,\n            color: raw[(0, utils_1.nameof)('color')] || exports.DEFAULT_BACKGROUND_COLOR,\n            imageId: raw[(0, utils_1.nameof)('imageId')] || \"\"\n        };\n    }\n}\nexports.BackgroundSettingsFactory = BackgroundSettingsFactory;\nclass GroundedSkyboxSettingsFactory {\n    static CreateNew() {\n        return {\n            isEnabled: false,\n            height: 1.5,\n            radius: 3\n        };\n    }\n    static Create(raw) {\n        return {\n            isEnabled: Boolean(raw[(0, utils_1.nameof)('isEnabled')]),\n            height: raw[(0, utils_1.nameof)('height')] || 1.5,\n            radius: raw[(0, utils_1.nameof)('radius')] || 3\n        };\n    }\n}\nexports.GroundedSkyboxSettingsFactory = GroundedSkyboxSettingsFactory;\nclass LightSettingsFactory {\n    static CreateNew() {\n        return {\n            intensity: 1,\n            isOn: false,\n            rotation: new math_1.Quaternion(0, 0, 0, 1),\n            color: \"#ffffff\"\n        };\n    }\n    static Create(raw) {\n        var _a;\n        return {\n            intensity: raw[(0, utils_1.nameof)('intensity')] || 1,\n            isOn: Boolean((_a = raw[(0, utils_1.nameof)('isOn')]) !== null && _a !== void 0 ? _a : false),\n            rotation: raw[(0, utils_1.nameof)('rotation')] ? new math_1.Quaternion(raw[(0, utils_1.nameof)('rotation')]) : new math_1.Quaternion(0, 0, 0, 1),\n            color: raw[(0, utils_1.nameof)('color')] || \"#ffffff\"\n        };\n    }\n}\nexports.LightSettingsFactory = LightSettingsFactory;\nclass WorldSettingsFactory {\n    static CreateNew() {\n        return {\n            environment: EnvironmentSettingsFactory.CreateNew(),\n            background: BackgroundSettingsFactory.CreateNew(),\n            groundedSkybox: GroundedSkyboxSettingsFactory.CreateNew(),\n            light: LightSettingsFactory.CreateNew()\n        };\n    }\n    static Create(raw) {\n        return {\n            environment: EnvironmentSettingsFactory.Create(raw[(0, utils_1.nameof)('environment')] || {}),\n            background: BackgroundSettingsFactory.Create(raw[(0, utils_1.nameof)('background')] || {}),\n            groundedSkybox: GroundedSkyboxSettingsFactory.Create(raw[(0, utils_1.nameof)('groundedSkybox')] || {}),\n            light: LightSettingsFactory.Create(raw[(0, utils_1.nameof)('light')] || {})\n        };\n    }\n    static PrepareForFrontend(worldSettings) {\n        let result = WorldSettingsFactory.Create(worldSettings);\n        result.light.rotation = result.light.rotation.toRH();\n        result.environment.rotation = result.environment.rotation.toRH();\n        return result;\n    }\n}\nexports.WorldSettingsFactory = WorldSettingsFactory;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Batching = void 0;\nconst generator_1 = require(\"./generator\");\nconst product_parts_1 = require(\"../Product/product_parts\");\nconst filesystem_1 = require(\"../filesystem\");\nvar Batching;\n(function (Batching) {\n    var MergedMesh = generator_1.Generator.MergedMesh;\n    class Batch {\n        constructor(geometry, material) {\n            this.geometry = geometry;\n            this.material = material;\n        }\n        GenerateFrontendData() {\n            const result = product_parts_1.GeometryPartFactory.CreateNew();\n            result.type = product_parts_1.ProductPartType.Geometry;\n            result.geometry = filesystem_1.Filesystem.Cache.GetCachedItem(this.geometry).id;\n            result.material = filesystem_1.Filesystem.Cache.GetCachedItem(this.material).id;\n            return result;\n        }\n    }\n    Batching.Batch = Batch;\n    class BatchCollection {\n        constructor() {\n            this.elements = {};\n        }\n        CreateOrUpdateBatchByMaterial(name, geometry, material) {\n            let result;\n            let pair = Object.entries(this.elements).find((e) => e[1].material.GetHashCode() == material.GetHashCode());\n            if (pair == null) {\n                result = new Batch(geometry, material);\n                this.elements[name] = result;\n            }\n            else {\n                result = pair[1];\n                result.geometry = new MergedMesh(result.geometry, geometry);\n                this.elements[pair[0] + \"_\" + name] = result;\n                delete this.elements[pair[0]];\n            }\n            return result;\n        }\n        UpdateFrontendData(target) {\n            for (let name in this.elements)\n                target.children[name] = this.elements[name].GenerateFrontendData();\n        }\n    }\n    Batching.BatchCollection = BatchCollection;\n})(Batching || (exports.Batching = Batching = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Generator = void 0;\nconst unwrapper_1 = require(\"./unwrapper\");\nconst filesystem_1 = require(\"../filesystem\");\nconst meshslice_1 = require(\"./meshslice\");\nconst shape_1 = require(\"../Product/shape\");\nconst math_1 = require(\"../math\");\nvar Generator;\n(function (Generator) {\n    var TriplanarUnwrapper = unwrapper_1.Unwrapper.TriplanarUnwrapper;\n    var Cacheable = filesystem_1.Filesystem.Cacheable;\n    var LightmapUnwrapper = unwrapper_1.Unwrapper.LightmapUnwrapper;\n    class Triangulator {\n        constructor(points) {\n            this.m_points = points;\n        }\n        Triangulate() {\n            const indices = [];\n            const n = this.m_points.length;\n            if (n < 3)\n                return indices;\n            const V = [];\n            if (this.Area() > 0) {\n                for (let v = 0; v < n; v++)\n                    V[v] = v;\n            }\n            else {\n                for (let v = 0; v < n; v++)\n                    V[v] = n - 1 - v;\n            }\n            let nv = n;\n            let count = 2 * nv;\n            for (let m = 0, v = nv - 1; nv > 2;) {\n                if (count-- <= 0)\n                    return indices;\n                let u = v;\n                if (nv <= u)\n                    u = 0;\n                v = u + 1;\n                if (nv <= v)\n                    v = 0;\n                let w = v + 1;\n                if (nv <= w)\n                    w = 0;\n                if (this.Snip(u, v, w, nv, V)) {\n                    let a, b, c, s, t;\n                    a = V[u];\n                    b = V[v];\n                    c = V[w];\n                    indices.push(a);\n                    indices.push(b);\n                    indices.push(c);\n                    m++;\n                    for (s = v, t = v + 1; t < nv; s++, t++)\n                        V[s] = V[t];\n                    nv--;\n                    count = 2 * nv;\n                }\n            }\n            return indices;\n        }\n        Area() {\n            const n = this.m_points.length;\n            let A = 0;\n            let p, q;\n            for (p = n - 1, q = 0; q < n; p = q++) {\n                const pval = this.m_points[p];\n                const qval = this.m_points[q];\n                A += pval.x * qval.y - qval.x * pval.y;\n            }\n            return A * 0.5;\n        }\n        Snip(u, v, w, n, V) {\n            let p = 0;\n            const A = this.m_points[V[u]];\n            const B = this.m_points[V[v]];\n            const C = this.m_points[V[w]];\n            if (Number.EPSILON >\n                (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x))\n                return false;\n            for (p = 0; p < n; p++) {\n                if (p == u || p == v || p == w)\n                    continue;\n                const P = this.m_points[V[p]];\n                if (Triangulator.InsideTriangle(A, B, C, P))\n                    return false;\n            }\n            return true;\n        }\n        static InsideTriangle(A, B, C, P) {\n            const ax = C.x - B.x;\n            const ay = C.y - B.y;\n            const bx = A.x - C.x;\n            const by = A.y - C.y;\n            const cx = B.x - A.x;\n            const cy = B.y - A.y;\n            const apx = P.x - A.x;\n            const apy = P.y - A.y;\n            const bpx = P.x - B.x;\n            const bpy = P.y - B.y;\n            const cpx = P.x - C.x;\n            const cpy = P.y - C.y;\n            const aCROSSbp = ax * bpy - ay * bpx;\n            const cCROSSap = cx * apy - cy * apx;\n            const bCROSScp = bx * cpy - by * cpx;\n            return aCROSSbp >= 0.0 && bCROSScp >= 0.0 && cCROSSap >= 0.0;\n        }\n    }\n    Generator.Triangulator = Triangulator;\n    class Mesh extends Cacheable {\n        GetHashableData() {\n            return this.initialData;\n        }\n        constructor() {\n            super();\n            this.initialData = \"\";\n            this.vertices = [];\n            this.normals = [];\n            this.uvs = [];\n            this.uvs2 = [];\n            this.indices = [];\n            this.current_index = 0;\n            this.triplanarUnwrapper = null;\n        }\n        GenerateInternal() {\n            if (this.triplanarUnwrapper != null)\n                this.uvs = this.triplanarUnwrapper.Process();\n            this.uvs2 = new LightmapUnwrapper(this).Process();\n        }\n        AddTri(v1, v2, v3, uv1, uv2, uv3) {\n            this.vertices.push(v1);\n            this.vertices.push(v2);\n            this.vertices.push(v3);\n            this.uvs.push(uv1);\n            this.uvs.push(uv2);\n            this.uvs.push(uv3);\n            const normal = math_1.Vector3.cross(v1.sub(v2), v1.sub(v3)).normalized;\n            this.normals.push(normal);\n            this.normals.push(normal);\n            this.normals.push(normal);\n            this.indices = this.indices.concat([\n                this.current_index,\n                this.current_index + 1,\n                this.current_index + 2,\n            ]);\n            this.current_index += 3;\n        }\n        AddFace(v1, v2, v3, v4, uv1, uv2, uv3, uv4) {\n            const normal = math_1.Vector3.cross(v1.sub(v2), v1.sub(v3)).normalized;\n            if (!normal.isFinite())\n                return;\n            this.vertices.push(v1);\n            this.vertices.push(v2);\n            this.vertices.push(v3);\n            this.vertices.push(v4);\n            this.uvs.push(uv1);\n            this.uvs.push(uv2);\n            this.uvs.push(uv3);\n            this.uvs.push(uv4);\n            this.normals.push(normal);\n            this.normals.push(normal);\n            this.normals.push(normal);\n            this.normals.push(normal);\n            for (let i of Mesh.local_indices)\n                this.indices.push(i + this.current_index);\n            this.current_index += 4;\n        }\n        ApplyAdditionalData(mesh_data) {\n            if ((mesh_data === null || mesh_data === void 0 ? void 0 : mesh_data.uv2) != null) {\n                if (mesh_data === null || mesh_data === void 0 ? void 0 : mesh_data.uv2.some(function (d) {\n                    const v = new math_1.Vector2(d);\n                    return v.isNaN() || !v.isFinite();\n                })) {\n                    return;\n                }\n                this.uvs2 = mesh_data.uv2.map(function (d) {\n                    return new math_1.Vector2(d);\n                });\n            }\n        }\n        RecalculateNormals() {\n            if (this.vertices.length % 3 != 0)\n                return;\n            this.normals = [];\n            for (let i = 0; i < this.vertices.length; i += 3) {\n                const v1 = this.vertices[i];\n                const v2 = this.vertices[i + 1];\n                const v3 = this.vertices[i + 2];\n                const n = math_1.Vector3.cross(v2.sub(v1), v3.sub(v1)).normalized;\n                this.normals.push(n);\n                this.normals.push(n);\n                this.normals.push(n);\n            }\n        }\n    }\n    Mesh.local_indices = [0, 1, 3, 3, 1, 2];\n    Generator.Mesh = Mesh;\n    class PrimitiveMesh extends Mesh {\n        constructor(size, angle1 = 0, angle2 = 0, target_faces = [], offset = new math_1.Vector3(), rotation = new math_1.Quaternion(), scale = math_1.Vector3.one) {\n            super();\n            this.size = size;\n            this.cut_angle1 = (angle1 / 180.0) * Math.PI;\n            this.cut_angle2 = (angle2 / 180.0) * Math.PI;\n            this.offset = offset;\n            this.rotation = rotation;\n            this.scale = scale;\n            this.target_faces = target_faces;\n            if (size.isZero() || !size.isFinite())\n                return;\n            const temp = {\n                size: size,\n                angle1: angle1,\n                angle2: angle2,\n                offset: offset,\n                rotation: rotation,\n                scale: scale,\n                target_faces: target_faces,\n            };\n            this.initialData = JSON.stringify(temp);\n        }\n        NeedRenderFace(face_index) {\n            if (this.target_faces.length == 0)\n                return true;\n            return this.target_faces.includes(face_index);\n        }\n        GenerateInternal() {\n            const angle_offset1 = this.cut_angle1 == 0\n                ? 0\n                : this.size.x * Math.tan(Math.PI - this.cut_angle1);\n            const angle_offset2 = this.cut_angle2 == 0 ? 0 : this.size.x * Math.tan(this.cut_angle2);\n            let count = 24;\n            if (this.target_faces.length > 0)\n                count = this.target_faces.length * 4;\n            this.vertices = new Array(count);\n            this.normals = new Array(count);\n            this.uvs = new Array(count);\n            //this.indices = Array.from( Array(count).keys() );\n            this.indices = [];\n            const hs = this.size.div(2);\n            const raw_verts = [\n                //BOTTOM PLANE\n                new math_1.Vector3(-hs.x, -hs.y + angle_offset1, hs.z),\n                new math_1.Vector3(-hs.x, -hs.y + angle_offset1, -hs.z),\n                new math_1.Vector3(hs.x, -hs.y, -hs.z),\n                new math_1.Vector3(hs.x, -hs.y, hs.z),\n                //TOP PLANE\n                new math_1.Vector3(-hs.x, hs.y - angle_offset2, hs.z),\n                new math_1.Vector3(-hs.x, hs.y - angle_offset2, -hs.z),\n                new math_1.Vector3(hs.x, hs.y, -hs.z),\n                new math_1.Vector3(hs.x, hs.y, hs.z),\n            ];\n            let current_vertices_count = 0;\n            const self = this;\n            let TryAddFace = function (face_index, face_indices, local_uvs, normal) {\n                if (!self.NeedRenderFace(face_index))\n                    return;\n                for (let i = 0; i < 6; i++) {\n                    self.indices.push(current_vertices_count + PrimitiveMesh.global_indices[i]);\n                }\n                for (let i = 0; i < 4; i++) {\n                    self.vertices[current_vertices_count] = raw_verts[face_indices[i]];\n                    self.normals[current_vertices_count] = normal;\n                    self.uvs[current_vertices_count] = local_uvs[i];\n                    current_vertices_count++;\n                }\n            };\n            //FRONT FACE\n            {\n                const local_uvs = [\n                    new math_1.Vector2(0, angle_offset1),\n                    new math_1.Vector2(0, this.size.y - angle_offset2),\n                    new math_1.Vector2(this.size.x, this.size.y),\n                    new math_1.Vector2(this.size.x, 0),\n                ];\n                TryAddFace(0, PrimitiveMesh.front_indices, local_uvs, new math_1.Vector3(0, 0, 1));\n            }\n            //TOP FACE\n            {\n                const local_uvs = [\n                    new math_1.Vector2(0, 0),\n                    new math_1.Vector2(0, this.size.z),\n                    new math_1.Vector2(this.size.x, this.size.z),\n                    new math_1.Vector2(this.size.x, 0),\n                ];\n                TryAddFace(1, PrimitiveMesh.top_indices, local_uvs, new math_1.Vector3(0, 1, 0));\n            }\n            //BACK FACE\n            {\n                const local_uvs = [\n                    new math_1.Vector2(0, 0),\n                    new math_1.Vector2(0, this.size.y),\n                    new math_1.Vector2(this.size.x, this.size.y - angle_offset2),\n                    new math_1.Vector2(this.size.x, angle_offset1),\n                ];\n                TryAddFace(2, PrimitiveMesh.back_indices, local_uvs, new math_1.Vector3(0, 0, -1));\n            }\n            //BOTTOM FACE\n            {\n                const local_uvs = [\n                    new math_1.Vector2(0, 0),\n                    new math_1.Vector2(0, this.size.z),\n                    new math_1.Vector2(this.size.x, this.size.z),\n                    new math_1.Vector2(this.size.x, 0),\n                ];\n                TryAddFace(3, PrimitiveMesh.bottom_indices, local_uvs, new math_1.Vector3(0, -1, 0));\n            }\n            //LEFT FACE\n            {\n                const local_uvs = [\n                    new math_1.Vector2(this.size.z, 0),\n                    new math_1.Vector2(this.size.z, this.size.y),\n                    new math_1.Vector2(0, this.size.y),\n                    new math_1.Vector2(0, 0),\n                ];\n                TryAddFace(4, PrimitiveMesh.left_indices, local_uvs, new math_1.Vector3(-1, 0, 0));\n            }\n            //RIGHT FACE\n            {\n                const local_uvs = [\n                    new math_1.Vector2(this.size.z, 0),\n                    new math_1.Vector2(this.size.z, this.size.y),\n                    new math_1.Vector2(0, this.size.y),\n                    new math_1.Vector2(0, 0),\n                ];\n                TryAddFace(5, PrimitiveMesh.right_indices, local_uvs, new math_1.Vector3(1, 0, 0));\n            }\n            for (let i in this.vertices) {\n                this.vertices[i] = math_1.Vector3.scale(this.vertices[i], this.scale);\n                this.vertices[i] = this.rotation.rotate(this.vertices[i]);\n                this.vertices[i] = this.vertices[i].add(this.offset);\n            }\n            for (let i in this.normals)\n                this.normals[i] = this.rotation.rotate(this.normals[i]);\n            super.GenerateInternal();\n        }\n    }\n    PrimitiveMesh.front_indices = [0, 4, 7, 3];\n    PrimitiveMesh.back_indices = [2, 6, 5, 1];\n    PrimitiveMesh.top_indices = [4, 5, 6, 7];\n    PrimitiveMesh.bottom_indices = [1, 0, 3, 2];\n    PrimitiveMesh.left_indices = [1, 5, 4, 0];\n    PrimitiveMesh.right_indices = [3, 7, 6, 2];\n    PrimitiveMesh.global_indices = [0, 1, 2, 0, 2, 3];\n    Generator.PrimitiveMesh = PrimitiveMesh;\n    class CurvedMesh extends Mesh {\n        constructor(shapePoints, radius, startAngle, endAngle, cutAngle1, cutAngle2, precision, centered) {\n            super();\n            const temp = {\n                shapePoints: shapePoints,\n                radius: radius,\n                startAngle: startAngle,\n                endAngle: endAngle,\n                cutAngle1: cutAngle1,\n                cutAngle2: cutAngle2,\n                precision: precision,\n                centered: centered,\n            };\n            this.initialData = JSON.stringify(temp);\n            this.shapePoints = shapePoints;\n            this.radius = radius;\n            this.startAngle = startAngle;\n            this.endAngle = endAngle;\n            this.cutAngle1 = cutAngle1;\n            this.cutAngle2 = cutAngle2;\n            this.precision = precision;\n            this.centered = centered;\n        }\n        GenerateInternal() {\n            const segment_size = 3 / (this.radius * this.precision);\n            const count = Math.round((this.endAngle - this.startAngle) / segment_size);\n            let curvePoints = [];\n            for (let i = 0; i < count; i++) {\n                const alpha = this.startAngle + (this.endAngle - this.startAngle) * (i / count);\n                curvePoints.push(new math_1.Vector2(Math.cos((alpha / 180.0) * Math.PI), Math.sin((alpha / 180.0) * Math.PI)).mult(this.radius));\n                if (i == count - 1)\n                    curvePoints.push(new math_1.Vector2(Math.cos((this.endAngle / 180.0) * Math.PI), Math.sin((this.endAngle / 180.0) * Math.PI)).mult(this.radius));\n            }\n            if (this.centered) {\n                const min = new math_1.Vector2(Math.min(...Array.from(curvePoints, function (cp) {\n                    return cp.x;\n                })), Math.min(...Array.from(curvePoints, function (cp) {\n                    return cp.y;\n                })));\n                const max = new math_1.Vector2(Math.max(...Array.from(curvePoints, function (cp) {\n                    return cp.x;\n                })), Math.max(...Array.from(curvePoints, function (cp) {\n                    return cp.y;\n                })));\n                const offset = min.add(max.sub(min).div(2.0));\n                for (let i = 0; i < curvePoints.length; i++)\n                    curvePoints[i] = curvePoints[i].sub(offset);\n            }\n            let IsClockwise = function (shape) {\n                let sum = 0;\n                for (let i = 0; i < shape.length; i++) {\n                    let v1 = shape[i];\n                    let v2 = shape[(i + 1) % shape.length];\n                    sum += (v2.x - v1.x) * (v2.y + v1.y);\n                }\n                return sum > 0;\n            };\n            if (IsClockwise(this.shapePoints))\n                this.shapePoints = this.shapePoints.reverse();\n            if (this.centered) {\n                const min = new math_1.Vector2(Math.min(...Array.from(this.shapePoints, function (cp) {\n                    return cp.x;\n                })), Math.min(...Array.from(this.shapePoints, function (cp) {\n                    return cp.y;\n                })));\n                const max = new math_1.Vector2(Math.max(...Array.from(this.shapePoints, function (cp) {\n                    return cp.x;\n                })), Math.max(...Array.from(this.shapePoints, function (cp) {\n                    return cp.y;\n                })));\n                const offset = min.add(max.sub(min).div(2.0));\n                for (let i = 0; i < this.shapePoints.length; i++) {\n                    this.shapePoints[i] = this.shapePoints[i].sub(offset);\n                    this.shapePoints[i].x = -this.shapePoints[i].x;\n                    this.shapePoints[i].y = -this.shapePoints[i].y;\n                }\n            }\n            const temp_vertices = [];\n            const loop = false;\n            function GetForwardVector(i) {\n                let v1;\n                let v2;\n                if (i == curvePoints.length - 1) {\n                    if (loop) {\n                        v1 = new math_1.Vector3(curvePoints[i]);\n                        v2 = new math_1.Vector3(curvePoints[0]);\n                    }\n                    else {\n                        v1 = new math_1.Vector3(curvePoints[i - 1]);\n                        v2 = new math_1.Vector3(curvePoints[i]);\n                    }\n                }\n                else if (i == 0) {\n                    if (loop) {\n                        v1 = new math_1.Vector3(curvePoints[curvePoints.length - 1]);\n                        v2 = new math_1.Vector3(curvePoints[1]);\n                    }\n                    else {\n                        v1 = new math_1.Vector3(curvePoints[0]);\n                        v2 = new math_1.Vector3(curvePoints[1]);\n                    }\n                }\n                else {\n                    v1 = new math_1.Vector3(curvePoints[i - 1]);\n                    v2 = new math_1.Vector3(curvePoints[i + 1]);\n                }\n                return v2.sub(v1).normalized;\n            }\n            for (let i = 0; i < curvePoints.length; i++) {\n                const pos = new math_1.Vector3(curvePoints[i]);\n                const forward = GetForwardVector(i);\n                const rotation = math_1.Quaternion.lookRotation(forward, new math_1.Vector3(0, 0, 1));\n                for (let j = 0; j < this.shapePoints.length; j++)\n                    temp_vertices.push(pos\n                        .add(rotation.rotate(new math_1.Vector3(this.shapePoints[j])))\n                        .invertX());\n            }\n            let v = 0;\n            for (let i = 0; i < curvePoints.length - (loop ? 0 : 1); i++) {\n                let u = 0;\n                let v1 = 0;\n                let v2 = 0;\n                if (i == 0)\n                    v2 = math_1.Vector3.distance(temp_vertices[this.shapePoints.length], temp_vertices[0]);\n                else\n                    v2 = math_1.Vector3.distance(temp_vertices[i * this.shapePoints.length], temp_vertices[(i - 1) * this.shapePoints.length]);\n                for (let j = 0; j < this.shapePoints.length; j++) {\n                    let u1, u2, u3, u4 = 0;\n                    if (j == 0) {\n                        u1 = 0;\n                    }\n                    else {\n                        u1 = math_1.Vector2.distance(this.shapePoints[j], this.shapePoints[j - 1]);\n                    }\n                    if (j == this.shapePoints.length - 1) {\n                        u2 = math_1.Vector2.distance(this.shapePoints[j], this.shapePoints[0]);\n                    }\n                    else {\n                        u2 = math_1.Vector2.distance(this.shapePoints[j + 1], this.shapePoints[j]);\n                    }\n                    u3 = u2;\n                    u4 = u1;\n                    let rj = j + 1;\n                    if (j == this.shapePoints.length - 1)\n                        rj = 0;\n                    let i1 = i * this.shapePoints.length + j;\n                    let i2 = i * this.shapePoints.length + rj;\n                    let ri = i + 1;\n                    if (i == curvePoints.length - 1)\n                        ri = 0;\n                    let i3 = ri * this.shapePoints.length + rj;\n                    let i4 = ri * this.shapePoints.length + j;\n                    let uvs = [\n                        new math_1.Vector2(u + u1, v + v1),\n                        new math_1.Vector2(u + u2, v + v1),\n                        new math_1.Vector2(u + u3, v + v2),\n                        new math_1.Vector2(u + u4, v + v2),\n                    ];\n                    this.AddTri(temp_vertices[i1], temp_vertices[i2], temp_vertices[i3], uvs[0], uvs[1], uvs[2]);\n                    this.AddTri(temp_vertices[i1], temp_vertices[i3], temp_vertices[i4], uvs[0], uvs[2], uvs[3]);\n                    u += u2;\n                }\n                v += v2;\n            }\n            for (let n in this.normals)\n                this.normals[n] = this.normals[n].mult(-1);\n            const indices_count = this.indices.length;\n            const firstCurvePoint = new math_1.Vector3(curvePoints[0]);\n            const lastCurvePoint = new math_1.Vector3(curvePoints[curvePoints.length - 1]);\n            const shapeSize = shape_1.Shape.GetShapeSize(this.shapePoints);\n            if (this.cutAngle1 != 0) {\n                let point = lastCurvePoint.invertX();\n                const normal = math_1.Quaternion.euler(0, 0, this.endAngle - 90 + this.cutAngle1)\n                    .rotate(new math_1.Vector3(1, 0, 0))\n                    .invertX();\n                const perp = math_1.Quaternion.euler(0, 0, this.endAngle)\n                    .rotate(new math_1.Vector3(1, 0, 0))\n                    .invertX();\n                point = point.add(perp.mult(shapeSize.x / 2.0));\n                meshslice_1.MeshSlice.Slice(this, [math_1.Plane.fromPoint(normal, point)], indices_count / 2, indices_count);\n            }\n            if (this.cutAngle2 != 0) {\n                let point = firstCurvePoint.invertX();\n                const normal = math_1.Quaternion.euler(0, 0, this.startAngle + 90 - this.cutAngle2)\n                    .rotate(new math_1.Vector3(1, 0, 0))\n                    .invertX();\n                const perp = math_1.Quaternion.euler(0, 0, this.startAngle)\n                    .rotate(new math_1.Vector3(1, 0, 0))\n                    .invertX();\n                point = point.add(perp.mult(shapeSize.x / 2.0));\n                meshslice_1.MeshSlice.Slice(this, [math_1.Plane.fromPoint(normal, point)], 0, indices_count / 2);\n            }\n            super.GenerateInternal();\n        }\n    }\n    Generator.CurvedMesh = CurvedMesh;\n    class ShapedMesh extends Mesh {\n        constructor(size, shape, angle1, angle2, offset = new math_1.Vector3(), rotation = new math_1.Quaternion(), texture_scale = 1) {\n            super();\n            this.size = size;\n            this.shape = shape;\n            this.offset = offset;\n            this.rotation = rotation;\n            this.angle1 = (angle1 / 180.0) * Math.PI;\n            this.angle2 = (angle2 / 180.0) * Math.PI;\n            const temp = {\n                size: size,\n                shape: shape,\n                angle1: angle1,\n                angle2: angle2,\n                offset: offset,\n                rotation: rotation,\n                texture_scale: texture_scale,\n            };\n            this.initialData = JSON.stringify(temp);\n            this.texture_scale = texture_scale;\n        }\n        static NormalizeShape(shape) {\n            const result = [];\n            let min = new math_1.Vector2(Number.MAX_VALUE, Number.MAX_VALUE);\n            for (const s of shape) {\n                if (s.x < min.x)\n                    min.x = s.x;\n                if (s.y < min.y)\n                    min.y = s.y;\n            }\n            for (const s of shape)\n                result.push(s.sub(min));\n            return result;\n        }\n        GetWavePoints(size, s1, s2) {\n            const half_size = size.div(2.0);\n            let angle_offset1_s1 = 0;\n            let angle_offset2_s1 = 0;\n            let angle_offset1_s2 = 0;\n            let angle_offset2_s2 = 0;\n            if (this.angle1 != 0) {\n                angle_offset1_s1 = s1.x * Math.tan(Math.PI - this.angle1);\n                angle_offset1_s2 = s2.x * Math.tan(Math.PI - this.angle1);\n            }\n            if (this.angle2 != 0) {\n                angle_offset2_s1 = s1.x * Math.tan(this.angle2);\n                angle_offset2_s2 = s2.x * Math.tan(this.angle2);\n            }\n            return [\n                new math_1.Vector3(s2.x - half_size.x, -half_size.y + angle_offset1_s2, -s2.y + half_size.z).invertX(),\n                new math_1.Vector3(s2.x - half_size.x, half_size.y - angle_offset2_s2, -s2.y + half_size.z).invertX(),\n                new math_1.Vector3(s1.x - half_size.x, half_size.y - angle_offset2_s1, -s1.y + half_size.z).invertX(),\n                new math_1.Vector3(s1.x - half_size.x, -half_size.y + angle_offset1_s1, -s1.y + half_size.z).invertX(),\n            ];\n        }\n        GetWavePoint(size, s1) {\n            const half_size = size.div(2.0);\n            let angle_offset1_s1 = 0;\n            let angle_offset2_s1 = 0;\n            if (this.angle1 != 0)\n                angle_offset1_s1 = s1.x * Math.tan(Math.PI - this.angle1);\n            if (this.angle2 != 0)\n                angle_offset2_s1 = s1.x * Math.tan(this.angle2);\n            return [\n                new math_1.Vector3(s1.x - half_size.x, -half_size.y + angle_offset1_s1, -s1.y + half_size.z).invertX(),\n                new math_1.Vector3(s1.x - half_size.x, half_size.y - angle_offset2_s1, -s1.y + half_size.z).invertX(),\n            ];\n        }\n        GenerateInternal() {\n            let nshape = ShapedMesh.NormalizeShape(this.shape);\n            let orient = 0;\n            for (let i = 0; i < nshape.length; i++) {\n                let j = i == nshape.length - 1 ? 0 : i + 1;\n                if (math_1.Vector2.distance(nshape[i], nshape[j]) < 0.0001) {\n                    nshape.splice(j, 1);\n                    i--;\n                }\n                else {\n                    orient += (nshape[j].x - nshape[i].x) * (nshape[j].y + nshape[i].y);\n                }\n            }\n            if (orient < 0)\n                nshape = nshape.reverse();\n            let uv_offset = 0;\n            const upper_points = [];\n            const lower_points = [];\n            let s1, s2;\n            for (let i = 0; i < nshape.length; i++) {\n                s1 = nshape[i];\n                if (i + 1 != nshape.length)\n                    s2 = nshape[i + 1];\n                else\n                    s2 = nshape[0];\n                let uv1, uv2, uv3, uv4;\n                const vs = this.GetWavePoints(this.size, s1, s2);\n                upper_points.push(vs[3]);\n                upper_points.push(vs[0]);\n                lower_points.push(vs[2]);\n                lower_points.push(vs[1]);\n                const dvs = vs[1].sub(vs[3]);\n                const duv_x = Math.abs(new math_1.Vector2(dvs.x, dvs.z).length);\n                uv1 = new math_1.Vector2(uv_offset, vs[0].y);\n                uv2 = new math_1.Vector2(uv_offset, vs[1].y);\n                uv3 = new math_1.Vector2(uv_offset + duv_x, vs[2].y);\n                uv4 = new math_1.Vector2(uv_offset + duv_x, vs[3].y);\n                this.AddFace(vs[0], vs[1], vs[2], vs[3], uv1, uv2, uv3, uv4);\n                uv_offset += duv_x;\n            }\n            const triang = new Triangulator(nshape);\n            const tr = triang.Triangulate();\n            for (let j = 0; j < tr.length; j += 3) {\n                const vs0 = this.GetWavePoint(this.size, nshape[tr[j + 2]]);\n                const vs1 = this.GetWavePoint(this.size, nshape[tr[j + 1]]);\n                const vs2 = this.GetWavePoint(this.size, nshape[tr[j + 0]]);\n                const normal0 = math_1.Vector3.cross(vs2[0].sub(vs1[0]), vs2[0].sub(vs0[0])).normalized;\n                const normal1 = math_1.Vector3.cross(vs0[1].sub(vs1[1]), vs0[1].sub(vs2[1])).normalized;\n                function GetUV(vertex, normal) {\n                    return TriplanarUnwrapper.ProcessSingleVertex(vertex, normal, new math_1.Vector3(), new math_1.Quaternion(), 0, new math_1.Vector2(1, 1), new math_1.Vector2(), new math_1.Vector2());\n                }\n                const uvs0 = [\n                    GetUV(vs0[0], normal0),\n                    GetUV(vs1[0], normal0),\n                    GetUV(vs2[0], normal0),\n                ];\n                const uvs1 = [\n                    GetUV(vs0[1], normal1),\n                    GetUV(vs1[1], normal1),\n                    GetUV(vs2[1], normal1),\n                ];\n                this.AddTri(vs2[0], vs1[0], vs0[0], uvs0[2], uvs0[1], uvs0[0]);\n                this.AddTri(vs0[1], vs1[1], vs2[1], uvs1[0], uvs1[1], uvs1[2]);\n            }\n            for (let i in this.vertices)\n                this.vertices[i] = this.rotation\n                    .rotate(this.vertices[i])\n                    .add(this.offset);\n            for (let i in this.normals)\n                this.normals[i] = this.rotation.rotate(this.normals[i]);\n            this.indices = this.indices.reverse();\n            //this.RecalculateNormals();\n            super.GenerateInternal();\n        }\n    }\n    Generator.ShapedMesh = ShapedMesh;\n    class MergedMesh extends Mesh {\n        constructor(mesh1, mesh2) {\n            super();\n            this.mesh1 = mesh1;\n            this.mesh2 = mesh2;\n            this.initialData = mesh1.initialData + mesh2.initialData;\n        }\n        GenerateInternal() {\n            if (!this.mesh1.isGenerated)\n                this.mesh1.Generate();\n            if (!this.mesh2.isGenerated)\n                this.mesh2.Generate();\n            this.vertices.push(...this.mesh1.vertices.slice());\n            this.normals.push(...this.mesh1.normals.slice());\n            this.uvs.push(...this.mesh1.uvs.slice());\n            this.uvs2.push(...this.mesh1.uvs2.slice());\n            this.indices.push(...this.mesh1.indices.slice());\n            const verticesCount = this.vertices.length;\n            this.vertices.push(...this.mesh2.vertices.slice());\n            this.normals.push(...this.mesh2.normals.slice());\n            this.uvs.push(...this.mesh2.uvs.slice());\n            this.uvs2.push(...this.mesh2.uvs2.slice());\n            this.indices.push(...this.mesh2.indices.map((i) => i + verticesCount));\n        }\n    }\n    Generator.MergedMesh = MergedMesh;\n})(Generator || (exports.Generator = Generator = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MeshSlice = void 0;\nconst math_1 = require(\"../math\");\nclass MeshSlice {\n    static CutTriangle(vertices, plane, uvs) {\n        const result = {\n            vertices: vertices,\n            uvs: uvs,\n        };\n        if (vertices == null)\n            return null;\n        let state = 0; //0 - none, 1 - inside, 2 - outside, 3 - mixed\n        const inside_points = [];\n        for (const v of vertices) {\n            if (!plane.getSide(v)) {\n                if (state == 0)\n                    state = 2;\n                if (state == 1)\n                    state = 3;\n            }\n            else {\n                inside_points.push(v);\n                if (state == 0)\n                    state = 1;\n                if (state == 2)\n                    state = 3;\n            }\n        }\n        switch (state) {\n            case 1:\n                return result;\n            case 2:\n                return null;\n        }\n        if (inside_points.length == 1) {\n            const base_vert = inside_points[0];\n            const base_vert_index = vertices.indexOf(base_vert);\n            const other_points = vertices.filter((v) => v != inside_points[0]);\n            const r1 = new math_1.Ray(base_vert, other_points[0].sub(base_vert));\n            const r2 = new math_1.Ray(base_vert, other_points[1].sub(base_vert));\n            const e1 = plane.raycast(r1);\n            const e2 = plane.raycast(r2);\n            if (!e1.result || !e2.result)\n                return result;\n            const v1 = r1.GetPoint(e1.enter);\n            const v2 = r2.GetPoint(e2.enter);\n            const sd1 = math_1.Vector3.distance(base_vert, other_points[0]);\n            const sd2 = math_1.Vector3.distance(base_vert, other_points[1]);\n            const ed1 = math_1.Vector3.distance(base_vert, v1);\n            const ed2 = math_1.Vector3.distance(base_vert, v2);\n            const d1 = ed1 / sd1;\n            const d2 = ed2 / sd2;\n            const buv = uvs[base_vert_index];\n            const ouv1 = uvs[vertices.indexOf(other_points[0])];\n            const ouv2 = uvs[vertices.indexOf(other_points[1])];\n            uvs = [buv, math_1.Vector2.lerp(buv, ouv1, d1), math_1.Vector2.lerp(buv, ouv2, d2)];\n            switch (base_vert_index) {\n                case 0:\n                    result.uvs = [uvs[0], uvs[1], uvs[2]];\n                    result.vertices = [base_vert, v1, v2];\n                    break;\n                case 1:\n                    result.uvs = [uvs[1], uvs[0], uvs[2]];\n                    result.vertices = [v1, base_vert, v2];\n                    break;\n                default:\n                    result.uvs = [uvs[1], uvs[2], uvs[0]];\n                    result.vertices = [v1, v2, base_vert];\n                    break;\n            }\n        }\n        else {\n            const other_vert = vertices.find((v) => !inside_points.includes(v));\n            const other_vert_index = vertices.indexOf(other_vert);\n            const r1 = new math_1.Ray(inside_points[0], other_vert.sub(inside_points[0]));\n            const r2 = new math_1.Ray(inside_points[1], other_vert.sub(inside_points[1]));\n            const e1 = plane.raycast(r1);\n            const e2 = plane.raycast(r2);\n            if (!e1.result || !e2.result)\n                return result;\n            const v1 = r1.GetPoint(e1.enter);\n            const v2 = r2.GetPoint(e2.enter);\n            const sd1 = math_1.Vector3.distance(inside_points[0], other_vert);\n            const sd2 = math_1.Vector3.distance(inside_points[1], other_vert);\n            const ed1 = math_1.Vector3.distance(v1, other_vert);\n            const ed2 = math_1.Vector3.distance(v2, other_vert);\n            const d1 = ed1 / sd1;\n            const d2 = ed2 / sd2;\n            const buv1 = uvs[vertices.indexOf(inside_points[0])];\n            const buv2 = uvs[vertices.indexOf(inside_points[1])];\n            const ouv = uvs[other_vert_index];\n            uvs = [\n                buv1,\n                buv2,\n                math_1.Vector2.lerp(ouv, buv1, d1),\n                math_1.Vector2.lerp(ouv, buv2, d2),\n            ];\n            switch (other_vert_index) {\n                case 0:\n                    result.uvs = [uvs[2], uvs[0], uvs[1], uvs[2], uvs[1], uvs[3]];\n                    result.vertices = [\n                        v1,\n                        inside_points[0],\n                        inside_points[1],\n                        v1,\n                        inside_points[1],\n                        v2,\n                    ];\n                    break;\n                case 1:\n                    result.uvs = [uvs[0], uvs[3], uvs[1], uvs[3], uvs[0], uvs[2]];\n                    result.vertices = [\n                        inside_points[0],\n                        v2,\n                        inside_points[1],\n                        v2,\n                        inside_points[0],\n                        v1,\n                    ];\n                    break;\n                default:\n                    result.uvs = [uvs[0], uvs[1], uvs[2], uvs[2], uvs[1], uvs[3]];\n                    result.vertices = [\n                        inside_points[0],\n                        inside_points[1],\n                        v1,\n                        v1,\n                        inside_points[1],\n                        v2,\n                    ];\n                    break;\n            }\n        }\n        return result;\n    }\n    static Slice(mesh, planes, start_index = -1, end_index = -1) {\n        let res_verts = [];\n        let res_indices = [];\n        //let res_normals : Vector3[] = [];\n        let res_uvs = [];\n        const verts = mesh.vertices;\n        const normals = mesh.normals;\n        const indices = mesh.indices;\n        const uvs = mesh.uvs;\n        for (let i = 0; i < indices.length; i += 3) {\n            const v = [\n                verts[indices[i]],\n                verts[indices[i + 1]],\n                verts[indices[i + 2]],\n            ];\n            const uv = [uvs[indices[i]], uvs[indices[i + 1]], uvs[indices[i + 2]]];\n            let cut_uvs = uv;\n            let cut_res = v;\n            if ((start_index == -1 && end_index == -1) ||\n                (indices[i] >= start_index && indices[i] <= end_index)) {\n                for (const p of planes) {\n                    let local_res = [];\n                    let local_uvs = [];\n                    for (let j = 0; j < cut_res.length / 3; j++) {\n                        let j_res = [\n                            cut_res[j * 3],\n                            cut_res[j * 3 + 1],\n                            cut_res[j * 3 + 2],\n                        ];\n                        const j_uvs = [\n                            cut_uvs[j * 3],\n                            cut_uvs[j * 3 + 1],\n                            cut_uvs[j * 3 + 2],\n                        ];\n                        const slice = MeshSlice.CutTriangle(j_res, p, j_uvs);\n                        if (slice != null) {\n                            local_res = local_res.concat(slice.vertices);\n                            local_uvs = local_uvs.concat(slice.uvs);\n                        }\n                    }\n                    if (local_res.length == 0) {\n                        cut_res = null;\n                        break;\n                    }\n                    cut_res = local_res;\n                    cut_uvs = local_uvs;\n                }\n            }\n            if (cut_res != null) {\n                res_indices = res_indices.concat([...Array(cut_res.length).keys()].map((i) => i + res_verts.length));\n                res_verts = res_verts.concat(cut_res);\n                res_uvs = res_uvs.concat(cut_uvs);\n            }\n        }\n        mesh.vertices = res_verts;\n        mesh.indices = res_indices;\n        mesh.uvs = res_uvs;\n        mesh.RecalculateNormals();\n        for (let n in mesh.normals)\n            mesh.normals[n] = mesh.normals[n].mult(-1);\n    }\n}\nexports.MeshSlice = MeshSlice;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Unwrapper = void 0;\nconst math_1 = require(\"../math\");\nconst utils_1 = require(\"../utils\");\nvar Unwrapper;\n(function (Unwrapper) {\n    class Polygon {\n        constructor(...args) {\n            if (args.length == 1) {\n                this.mesh = args[0].mesh;\n                this.indices = Object.assign([], args[0].indices);\n                this.Areas = Object.assign({}, args[0].Areas);\n            }\n            else {\n                this.mesh = args[0];\n                this.indices = Object.assign([], args[1]);\n                this.Areas = {};\n            }\n            this.vertices = this.mesh.vertices;\n            this.normals = this.mesh.normals;\n        }\n        IsNeighbour(p, threshold) {\n            for (const i of p.indices) {\n                for (const k of this.indices) {\n                    const v1 = this.vertices[i];\n                    const v2 = this.vertices[k];\n                    const n1 = this.normals[i];\n                    const n2 = this.normals[k];\n                    if (v1.equals(v2) && math_1.Vector3.angle(n1, n2) <= threshold)\n                        return true;\n                }\n            }\n            return false;\n        }\n        Combine(p) {\n            this.indices = this.indices.concat(p.indices);\n        }\n        GenerateAreas() {\n            this.Areas = {};\n            const o = this.vertices[this.indices[0]];\n            let normal = new math_1.Vector3();\n            for (const i of this.indices)\n                normal = normal.add(this.normals[i]);\n            normal = normal.div(this.normals.length);\n            const oz = normal.normalized;\n            const ox = this.vertices[this.indices[1]].sub(o).normalized;\n            const oy = math_1.Vector3.cross(ox, oz).normalized;\n            const mat = new math_1.Matrix4x4();\n            mat[0][0] = ox.x;\n            mat[1][0] = ox.y;\n            mat[2][0] = ox.z;\n            mat[0][1] = oy.x;\n            mat[1][1] = oy.y;\n            mat[2][1] = oy.z;\n            mat[0][2] = oz.x;\n            mat[1][2] = oz.y;\n            mat[2][2] = oz.z;\n            for (const i of this.indices) {\n                const tr = mat.mult(this.vertices[i].sub(o));\n                this.Areas[i] = new math_1.Vector2(tr.x, tr.y);\n            }\n            const min = new math_1.Vector2(Number.MAX_VALUE, Number.MAX_VALUE);\n            for (const i of Object.keys(this.Areas).map((k) => Number.parseInt(k))) {\n                if (this.Areas[i].x < min.x)\n                    min.x = this.Areas[i].x;\n                if (this.Areas[i].y < min.y)\n                    min.y = this.Areas[i].y;\n            }\n            for (const i of Object.keys(this.Areas).map((k) => Number.parseInt(k)))\n                this.Areas[i] = this.Areas[i].sub(min);\n        }\n        Scale(m) {\n            for (const i of Object.keys(this.Areas).map((k) => Number.parseInt(k)))\n                this.Areas[i] = this.Areas[i].mult(m);\n        }\n        ApplyOffset(offset) {\n            for (const i of Object.keys(this.Areas).map((k) => Number.parseInt(k)))\n                this.Areas[i] = this.Areas[i].add(offset);\n        }\n        IsOutOfBounds() {\n            for (const i of Object.keys(this.Areas).map((k) => Number.parseInt(k))) {\n                if (this.Areas[i].x > 1 || this.Areas[i].y > 1)\n                    return true;\n            }\n            return false;\n        }\n    }\n    class LightmapUnwrapper {\n        constructor(mesh, threshold = 0, margin = 0.05) {\n            this.packIterations = 0;\n            this.maxPackIterations = 100;\n            this.threshold = threshold;\n            this.mesh = mesh;\n            this.margin = margin;\n            this.indices = this.mesh.indices;\n        }\n        GeneratePolygons() {\n            const result = [];\n            for (let i = 0; i < this.indices.length; i += 6) {\n                const poly = new Polygon(this.mesh, this.indices.slice(i, i + 5));\n                const local_threshold = this.threshold;\n                const found = result.find(function (r) {\n                    return r.IsNeighbour(poly, local_threshold);\n                });\n                if (found == null)\n                    result.push(poly);\n                else\n                    found.Combine(poly);\n            }\n            return result;\n        }\n        GetPolygonSize(...polys) {\n            const min = new math_1.Vector2(Number.MAX_VALUE, Number.MAX_VALUE);\n            const max = new math_1.Vector2(Number.MIN_VALUE, Number.MIN_VALUE);\n            for (const p of polys) {\n                for (const a of Object.keys(p.Areas).map((key) => p.Areas[parseInt(key)])) {\n                    if (a.x < min.x)\n                        min.x = a.x;\n                    if (a.x > max.x)\n                        max.x = a.x;\n                    if (a.y < min.y)\n                        min.y = a.y;\n                    if (a.y > max.y)\n                        max.y = a.y;\n                }\n            }\n            return max.sub(min);\n        }\n        GetPolygonAspect(...polys) {\n            const size = this.GetPolygonSize(...polys);\n            if (size.y > size.x)\n                return 1 / size.y;\n            return 1 / size.x;\n        }\n        Pack(polys, mult = 1) {\n            this.packIterations++;\n            if (this.packIterations > this.maxPackIterations)\n                return;\n            const clone = polys.map((p) => new Polygon(p));\n            const offset = new math_1.Vector2(this.margin, this.margin);\n            let next_offset_y = null;\n            for (let i = 0; i < clone.length; i++) {\n                const p = clone[i];\n                let temp = new Polygon(p);\n                temp.Scale(mult);\n                temp.ApplyOffset(offset);\n                if (temp.IsOutOfBounds()) {\n                    if (next_offset_y == null) {\n                        this.Pack(polys, mult * 0.9);\n                        return;\n                    }\n                    offset.y += next_offset_y + this.margin;\n                    next_offset_y = 0;\n                    offset.x = this.margin;\n                    temp = new Polygon(p);\n                    temp.Scale(mult);\n                    temp.ApplyOffset(offset);\n                    if (temp.IsOutOfBounds()) {\n                        this.Pack(polys, mult * 0.9);\n                        return;\n                    }\n                }\n                const next_size_y = this.GetPolygonSize(temp).y;\n                if (next_offset_y == null || next_size_y > next_offset_y)\n                    next_offset_y = next_size_y;\n                offset.x += this.GetPolygonSize(temp).x + this.margin;\n                clone[i] = temp;\n            }\n            for (let i = 0; i < polys.length; i++)\n                polys[i].Areas = clone[i].Areas;\n        }\n        Process() {\n            const result = new Array(this.mesh.vertices.length);\n            const polys = this.GeneratePolygons();\n            for (const p of polys)\n                p.GenerateAreas();\n            const aspect = this.GetPolygonAspect(...polys);\n            for (const p of polys)\n                p.Scale(aspect);\n            this.Pack(polys);\n            for (const p of polys) {\n                for (let k in p.Areas) {\n                    result[k] = p.Areas[k];\n                }\n            }\n            return result;\n        }\n    }\n    Unwrapper.LightmapUnwrapper = LightmapUnwrapper;\n    class TriplanarUnwrapper {\n        constructor(mesh, fitting, baseProcessing, comp) {\n            this.mesh = mesh;\n            this.fitting = fitting;\n            this.baseProcessing = baseProcessing;\n            this.componentImplementation = comp;\n        }\n        GetFittingOffset() {\n            let offset = new math_1.Vector2(0.25, 0.25);\n            if (this.fitting == null)\n                return offset;\n            if (this.fitting.group != null && this.fitting.group != \"\") {\n                const r = new math_1.Random((0, utils_1.GetHash)(this.fitting.group));\n                offset = offset.add(new math_1.Vector2(r.next(), r.next()));\n            }\n            return offset;\n        }\n        static ProcessSingleVertex(vertex, normal, position, rotation, uv_rotation, uv_scale, offset, real_size) {\n            let bf = rotation.rotate(normal).abs().normalized;\n            bf = bf.div(math_1.Vector3.dot(bf, math_1.Vector3.one));\n            const wpos = position.add(rotation.rotate(vertex));\n            let tx = wpos.zy();\n            tx.x += wpos.x;\n            let ty = wpos.xz();\n            ty.y += wpos.y;\n            let tz = wpos.xy();\n            if (uv_rotation != 0) {\n                tx = tx.rotate(uv_rotation);\n                ty = ty.rotate(uv_rotation);\n                tz = tz.rotate(uv_rotation);\n            }\n            tx = math_1.Vector2.scale(tx, uv_scale).add(offset).mult(bf.x);\n            ty = math_1.Vector2.scale(ty, uv_scale).add(offset).mult(bf.y);\n            tz = math_1.Vector2.scale(tz, uv_scale).add(offset).mult(bf.z);\n            let result = tx.add(ty).add(tz);\n            return result;\n        }\n        Process() {\n            const result = [];\n            const scale = this.baseProcessing == null ? new math_1.Vector2(1, 1) : new math_1.Vector2(this.baseProcessing.scale);\n            const uvRotation = this.baseProcessing == null ? 0 : this.baseProcessing.rotation;\n            let compRotation = this.componentImplementation.data.rotation.toRH();\n            let compPosition = this.componentImplementation.data.position.invertX().div(1000.0);\n            compPosition = compPosition.sub(this.componentImplementation.projectAssembler.GetProjectOffset().invertX());\n            let realSize = new math_1.Vector2(1, 1);\n            //if ( this.componentImplementation.data.material != \"\" && this.componentImplementation.data.material != null )\n            //{\n            //  const material = await this.componentImplementation.GetMaterialData(false, false);\n            //  let materialSize = material?.diffuse?.realSize;\n            //  if( materialSize != null )\n            //    realSize = materialSize;\n            //}\n            let offset = this.baseProcessing == null ? new math_1.Vector2() : new math_1.Vector2(this.baseProcessing.offset);\n            if (this.fitting != null)\n                offset = offset.add(this.GetFittingOffset());\n            offset.x = -offset.x * realSize.x;\n            offset.y = offset.y * realSize.y;\n            if (this.fitting != null) {\n                for (let i = 0; i < this.mesh.vertices.length; i++) {\n                    let uv = TriplanarUnwrapper.ProcessSingleVertex(this.mesh.vertices[i], this.mesh.normals[i], compPosition, compRotation, uvRotation, scale, offset, realSize);\n                    result.push(uv);\n                }\n            }\n            else if (this.baseProcessing != null) {\n                for (let i = 0; i < this.mesh.vertices.length; i++) {\n                    let uv = this.mesh.uvs[i];\n                    uv = uv.rotate(uvRotation);\n                    uv = math_1.Vector2.scale(uv, scale).add(offset);\n                    result.push(uv);\n                }\n            }\n            return result;\n        }\n    }\n    Unwrapper.TriplanarUnwrapper = TriplanarUnwrapper;\n})(Unwrapper || (exports.Unwrapper = Unwrapper = {}));\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PointsDistanceBuilder = exports.ManipulatorBuilder = exports.LightBuilder = exports.CameraBuilder = exports.ShadowPlaneBuilder = exports.VirtualObjectBuilder = exports.ModelGroupBuilder = exports.BuiltInBuilder = exports.ArrayBuilder = exports.PerforationBuilder = exports.LDSPBuilder = exports.MeshBuilder = exports.GeometryBuilder = exports.ProductPartBuilder = exports.ProductBuilder = void 0;\nconst product_1 = require(\"./product\");\nconst product_parts_1 = require(\"./product_parts\");\nconst filesystem_1 = require(\"../filesystem\");\nconst shape_1 = require(\"./shape\");\nconst batching_1 = require(\"../MeshUtils/batching\");\nconst generator_1 = require(\"../MeshUtils/generator\");\nconst material_1 = require(\"../material\");\nconst virtual_object_1 = require(\"./virtual_object\");\nconst logger_1 = require(\"../logger\");\nvar BatchCollection = batching_1.Batching.BatchCollection;\nvar PrimitiveMesh = generator_1.Generator.PrimitiveMesh;\nvar ShapedMesh = generator_1.Generator.ShapedMesh;\nvar Material = material_1.MaterialCore.Material;\nvar Texture = material_1.MaterialCore.Texture;\nvar DebugLevel = logger_1.Logger.DebugLevel;\nconst enums_1 = require(\"../Project/enums\");\nconst project_component_implementation_1 = require(\"../Project/Implementations/project_component_implementation\");\nconst environment_1 = require(\"../Environment/environment\");\nconst math_1 = require(\"../math\");\nclass ProductBuilder {\n    static PrepareEdgeShapeOnNeed() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (ProductBuilder.shape2x16 == null) {\n                let rawShapeData = yield filesystem_1.Filesystem.GetFile(\"https://lab.system123.ru/common/models/2x16.s123drawing\");\n                ProductBuilder.shape2x16 = new shape_1.Shape(rawShapeData);\n            }\n        });\n    }\n    constructor(caller) {\n        this.generateRelated = false;\n        this.generateInactive = false;\n        this.isScene = false;\n        this.isWebPBRExtrasActive = false;\n        this.isWebARActive = false;\n        this.core = caller;\n        this.projectAssembler = caller.projectAssembler;\n    }\n    Build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger_1.Logger.Log(\"ProductBuilder.Build: started\", DebugLevel.INFO);\n            yield ProductBuilder.PrepareEdgeShapeOnNeed();\n            const product = product_1.ProductFactory.CreateNew();\n            let tasks = [];\n            let partBuilders = [];\n            let virtualObjectBuilders = [];\n            logger_1.Logger.Log(\"ProductBuilder.Build: building parts\", DebugLevel.INFO);\n            for (let component of this.projectAssembler.allComponentImplementations) {\n                if (!this.generateInactive && !component.data.is_active)\n                    continue;\n                let builder = null;\n                switch (component.data.modifier.type) {\n                    case enums_1.ProjectComponentModifierType.DUMMY:\n                    case enums_1.ProjectComponentModifierType.SHAPE:\n                    case enums_1.ProjectComponentModifierType.MDF_WITH_FITTING:\n                    case enums_1.ProjectComponentModifierType.MDF_WITH_PAINT:\n                    case enums_1.ProjectComponentModifierType.SOLID_WOOD:\n                    case enums_1.ProjectComponentModifierType.GLASS:\n                        builder = new GeometryBuilder(this, component);\n                        break;\n                    case enums_1.ProjectComponentModifierType.MESH:\n                        builder = new MeshBuilder(this, component);\n                        break;\n                    case enums_1.ProjectComponentModifierType.LDSP:\n                        builder = new LDSPBuilder(this, component);\n                        break;\n                    case enums_1.ProjectComponentModifierType.ARRAY:\n                        builder = new ArrayBuilder(this, component);\n                        break;\n                    case enums_1.ProjectComponentModifierType.PERFORATION:\n                        builder = new PerforationBuilder(this, component);\n                        break;\n                    case enums_1.ProjectComponentModifierType.BUILTIN:\n                        builder = new BuiltInBuilder(this, component);\n                        break;\n                    case enums_1.ProjectComponentModifierType.MODEL_GROUP:\n                        builder = new ModelGroupBuilder(this, component);\n                        break;\n                }\n                if (builder == null) {\n                    logger_1.Logger.Log(\"ProductBuilder.Build: builder is null for component \" + component.data.name, DebugLevel.ERROR);\n                    continue;\n                }\n                tasks.push(builder.Build());\n                partBuilders.push(builder);\n            }\n            logger_1.Logger.Log(\"ProductBuilder.Build: building virtual objects\", DebugLevel.INFO);\n            for (let vo of this.projectAssembler.targetProject.virtual_objects) {\n                if (!this.generateInactive && vo.is_active === false)\n                    continue;\n                let builder = null;\n                switch (vo.modifier.type) {\n                    case enums_1.VirtualObjectModifierType.SHADOW_PLANE:\n                        builder = new ShadowPlaneBuilder(this, vo);\n                        break;\n                    case enums_1.VirtualObjectModifierType.CAMERA:\n                        builder = new CameraBuilder(this, vo);\n                        break;\n                    case enums_1.VirtualObjectModifierType.LIGHT:\n                        builder = new LightBuilder(this, vo);\n                        break;\n                    case enums_1.VirtualObjectModifierType.MANIPULATOR:\n                        builder = new ManipulatorBuilder(this, vo);\n                        break;\n                    case enums_1.VirtualObjectModifierType.POINT_DISTANCE:\n                        builder = new PointsDistanceBuilder(this, vo);\n                        break;\n                }\n                if (builder == null) {\n                    logger_1.Logger.Log(\"ProductBuilder.Build: builder is null for virtual object \" + vo.name, DebugLevel.ERROR);\n                    continue; //TODO error\n                }\n                tasks.push(builder.Build());\n                virtualObjectBuilders.push(builder);\n            }\n            logger_1.Logger.Log(\"ProductBuilder.Build: awaiting all tasks\", DebugLevel.INFO);\n            for (const result of yield Promise.allSettled(tasks)) {\n                if (result.status === \"fulfilled\") {\n                    logger_1.Logger.Log(\"ProductBuilder.Build: task fulfilled\", DebugLevel.VERBOSE);\n                }\n                else if (result.status === \"rejected\") {\n                    logger_1.Logger.Log(\"ProductBuilder.Build: task rejected - \" + result.reason, DebugLevel.ERROR);\n                }\n            }\n            logger_1.Logger.Log(\"ProductBuilder.Build: done awaiting all tasks\", DebugLevel.INFO);\n            const project = this.projectAssembler.targetProject;\n            product.connection_type = project.connection_type;\n            product.user_data = project.user_data;\n            if (!this.isScene) {\n                const rotation = new math_1.Quaternion();\n                const offset = rotation.rotate(this.projectAssembler.GetProjectOffset().invertX());\n                product.product_container.transform.position = offset.inversed();\n                product.product_container.transform.rotation = rotation;\n            }\n            product.product_container.normal = project.normal;\n            if (project.points_distance_lines_weight != null)\n                product.product_container.points_distance_lines_weight =\n                    project.points_distance_lines_weight / 1000;\n            if (project.points_distance_arrows_size != null)\n                product.product_container.points_distance_arrows_size =\n                    project.points_distance_arrows_size;\n            if (project.points_distance_text_size != null)\n                product.product_container.points_distance_text_size =\n                    project.points_distance_text_size;\n            if (project.points_distance_color != null)\n                product.product_container.points_distance_color =\n                    project.points_distance_color;\n            product.product_container.background_color = project.background_color;\n            logger_1.Logger.Log(\"ProductBuilder.Build: assembling children\", DebugLevel.INFO);\n            product.product_container.children = {};\n            for (let b of partBuilders) {\n                if (b.from == null || !b.isProperResult) {\n                    logger_1.Logger.Log(\"ProductBuilder.Build: skipping partBuilder with improper result\", DebugLevel.ERROR);\n                    continue;\n                }\n                product.product_container.children[b.from.data.guid] = b.result;\n            }\n            logger_1.Logger.Log(\"ProductBuilder.Build: assembling virtual objects\", DebugLevel.INFO);\n            for (let b of virtualObjectBuilders) {\n                if (b.from == null) {\n                    logger_1.Logger.Log(\"ProductBuilder.Build: skipping virtualObjectBuilder with null 'from'\", DebugLevel.ERROR);\n                    continue;\n                }\n                product.product_container.virtual_objects[b.from.name] = b.result;\n            }\n            product.world = environment_1.WorldSettingsFactory.PrepareForFrontend(project.world);\n            logger_1.Logger.Log(\"ProductBuilder.Build: finished\", DebugLevel.INFO);\n            return product;\n        });\n    }\n}\nexports.ProductBuilder = ProductBuilder;\nProductBuilder.shape2x16 = null;\nclass ProductPartBuilder {\n    constructor(caller, from) {\n        this.isProperResult = true;\n        this.caller = caller;\n        this.from = from;\n        this.result = this.CreateResult();\n    }\n    Build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger_1.Logger.Log(\"ProductPartBuilder.Build: started for \" + this.from.data.name, DebugLevel.VERBOSE);\n            this.result.transform.position = this.from.data.position.div(1000.0).invertX();\n            this.result.transform.rotation = this.from.data.rotation.toRH();\n            this.result.name = this.from.data.name;\n            this.result.order = this.from.data.order == null ? 0 : this.from.data.order;\n            this.result.build_order =\n                this.from.data.build_order == null ? 0 : this.from.data.build_order;\n            this.result.user_data =\n                this.from.data.user_data == null ? \"\" : this.from.data.user_data;\n            this.result.is_active = this.from.data.is_active;\n            logger_1.Logger.Log(\"ProductPartBuilder.Build: finished for \" + this.from.data.name, DebugLevel.VERBOSE);\n        });\n    }\n}\nexports.ProductPartBuilder = ProductPartBuilder;\nclass GeometryBuilder extends ProductPartBuilder {\n    CreateResult() {\n        return product_parts_1.GeometryPartFactory.CreateNew();\n    }\n    Build() {\n        const _super = Object.create(null, {\n            Build: { get: () => super.Build }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.Build.call(this);\n            this.result.type = product_parts_1.ProductPartType.Geometry;\n            this.result.geometry = yield this.from.GetMesh();\n            const material = yield this.from.GetMaterialData(this.caller.isWebPBRExtrasActive, this.caller.isWebARActive);\n            this.result.material = filesystem_1.Filesystem.Cache.GetCachedItem(material).id;\n        });\n    }\n}\nexports.GeometryBuilder = GeometryBuilder;\nclass MeshBuilder extends ProductPartBuilder {\n    CreateResult() {\n        return product_parts_1.MeshPartFactory.CreateNew();\n    }\n    Build() {\n        const _super = Object.create(null, {\n            Build: { get: () => super.Build }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.Build.call(this);\n            this.result.type = product_parts_1.ProductPartType.Mesh;\n            const modifier = this.from.data.modifier;\n            this.result.file = filesystem_1.Filesystem.GetRelativePath(modifier.mesh);\n            this.result.node = modifier.node_name;\n            if (this.result.node == null)\n                this.result.node = \"\";\n            if (modifier.use_scale) {\n                const size = this.from.data.size.div(1000.0);\n                const nsize = new math_1.Vector3(modifier.mesh_size);\n                if (nsize.x == 0)\n                    nsize.x = 0.001;\n                if (nsize.y == 0)\n                    nsize.y = 0.001;\n                if (nsize.z == 0)\n                    nsize.z = 0.001;\n                this.result.transform.scale = size.div(nsize);\n            }\n            if (!modifier.apply_offset &&\n                modifier.mesh_offset !== undefined) {\n                let n = new math_1.Vector3(modifier.mesh_offset).invertX();\n                if (modifier.use_scale)\n                    n = math_1.Vector3.scale(n, this.result.transform.scale);\n                n = new math_1.Quaternion(this.result.transform.rotation).rotate(n);\n                this.result.transform.position = this.from.data.position\n                    .div(1000.0)\n                    .invertX()\n                    .sub(n);\n            }\n            const material = yield this.from.GetMaterialData(this.caller.isWebPBRExtrasActive, this.caller.isWebARActive);\n            this.result.material = filesystem_1.Filesystem.Cache.GetCachedItem(material).id;\n            const processings = this.from.data.processings == null ? [] : this.from.data.processings;\n            const textureCoordinatesProcessing = processings.find((p) => p.type === 2);\n            if (textureCoordinatesProcessing != null) {\n                const uvs = {};\n                uvs.offset = textureCoordinatesProcessing.offset;\n                uvs.scale = textureCoordinatesProcessing.scale;\n                uvs.rotation = textureCoordinatesProcessing.rotation;\n                this.result[\"uvs\"] = uvs;\n            }\n        });\n    }\n}\nexports.MeshBuilder = MeshBuilder;\nclass LDSPBuilder extends ProductPartBuilder {\n    CreateResult() {\n        return product_parts_1.GroupPartFactory.CreateNew();\n    }\n    static GetEdgeCutAngles(index, edges) {\n        let cut_angle1 = 0;\n        let cut_angle2 = 0;\n        if (edges[index].type == enums_1.LDSPEdgeType.MM2) {\n            if (index == 0) {\n                if (edges[1].type == enums_1.LDSPEdgeType.MM2)\n                    cut_angle2 = -45;\n                if (edges[3].type == enums_1.LDSPEdgeType.MM2)\n                    cut_angle1 = 45;\n            }\n            if (index == 1) {\n                if (edges[0].type == enums_1.LDSPEdgeType.MM2)\n                    cut_angle2 = -45;\n                if (edges[2].type == enums_1.LDSPEdgeType.MM2)\n                    cut_angle1 = 45;\n            }\n            if (index == 2) {\n                if (edges[1].type == enums_1.LDSPEdgeType.MM2)\n                    cut_angle2 = -45;\n                if (edges[3].type == enums_1.LDSPEdgeType.MM2)\n                    cut_angle1 = 45;\n            }\n            if (index == 3) {\n                if (edges[0].type == enums_1.LDSPEdgeType.MM2)\n                    cut_angle1 = 45;\n                if (edges[2].type == enums_1.LDSPEdgeType.MM2)\n                    cut_angle2 = -45;\n            }\n        }\n        return [cut_angle1, cut_angle2];\n    }\n    Build() {\n        const _super = Object.create(null, {\n            Build: { get: () => super.Build }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.Build.call(this);\n            this.result.type = product_parts_1.ProductPartType.Group;\n            this.result.children = {};\n            const localShape = shape_1.Shape.GetShapeFromData(ProductBuilder.shape2x16, 0.002, this.from.data.size.z / 1000.0, false);\n            const modifier = this.from.data.modifier;\n            const sizeOffset = new math_1.Vector3();\n            sizeOffset.x =\n                (modifier.edges[0].type == enums_1.LDSPEdgeType.MM2 ? 2 : 0.03) +\n                    (modifier.edges[2].type == enums_1.LDSPEdgeType.MM2 ? 2 : 0.03);\n            sizeOffset.y =\n                (modifier.edges[1].type == enums_1.LDSPEdgeType.MM2 ? 2 : 0.03) +\n                    (modifier.edges[3].type == enums_1.LDSPEdgeType.MM2 ? 2 : 0.03);\n            const positionOffset = new math_1.Vector3();\n            positionOffset.x -=\n                modifier.edges[0].type == enums_1.LDSPEdgeType.MM2 ? 2 : 0.03;\n            positionOffset.x +=\n                modifier.edges[2].type == enums_1.LDSPEdgeType.MM2 ? 2 : 0.03;\n            positionOffset.y -=\n                modifier.edges[1].type == enums_1.LDSPEdgeType.MM2 ? 2 : 0.03;\n            positionOffset.y +=\n                modifier.edges[3].type == enums_1.LDSPEdgeType.MM2 ? 2 : 0.03;\n            const left = this.from.GetPointByAnchor(new math_1.Vector3(0.5, 0, 0)).addX(-sizeOffset.x / 2).div(1000);\n            const right = this.from.GetPointByAnchor(new math_1.Vector3(-0.5, 0, 0)).addX(sizeOffset.x / 2).div(1000);\n            const bottom = this.from.GetPointByAnchor(new math_1.Vector3(0, -0.5, 0)).addY(sizeOffset.y / 2).div(1000);\n            const top = this.from.GetPointByAnchor(new math_1.Vector3(0, 0.5, 0)).addY(-sizeOffset.y / 2).div(1000);\n            let plane_size = this.from.data.size.sub(sizeOffset).div(1000.0);\n            const offset = positionOffset.div(2000.0).invertX();\n            const mainMaterial = yield this.from.GetMaterialData(this.caller.isWebPBRExtrasActive, this.caller.isWebARActive);\n            const backMaterial = yield project_component_implementation_1.ProjectComponentImplementation.GetMaterialData(modifier.back_material, this.caller.projectAssembler.targetProject.guid, this.caller.isWebPBRExtrasActive, this.caller.isWebARActive);\n            const edgeMaterials = [];\n            for (const edge of modifier.edges) {\n                edgeMaterials.push(yield project_component_implementation_1.ProjectComponentImplementation.GetMaterialData(edge.material, this.caller.projectAssembler.targetProject.guid, this.caller.isWebPBRExtrasActive, this.caller.isWebARActive));\n            }\n            const batches = new BatchCollection();\n            //front\n            {\n                let geometry = new PrimitiveMesh(plane_size, modifier.cut_angle1, modifier.cut_angle2, [0], offset);\n                batches.CreateOrUpdateBatchByMaterial(\"front\", geometry, mainMaterial);\n            }\n            //back\n            {\n                let geometry = new PrimitiveMesh(plane_size, modifier.cut_angle1, modifier.cut_angle2, [2], offset);\n                batches.CreateOrUpdateBatchByMaterial(\"back\", geometry, backMaterial);\n            }\n            let heights = [\n                (this.from.GetPointByAnchor(new math_1.Vector3(0.5, -0.5, 0)).sub(this.from.GetPointByAnchor(new math_1.Vector3(0.5, 0.5, 0))).length - sizeOffset.y) / 1000.0,\n                (this.from.GetPointByAnchor(new math_1.Vector3(0.5, 0.5, 0)).sub(this.from.GetPointByAnchor(new math_1.Vector3(-0.5, 0.5, 0))).length - sizeOffset.x) / 1000.0,\n                (this.from.GetPointByAnchor(new math_1.Vector3(-0.5, -0.5, 0)).sub(this.from.GetPointByAnchor(new math_1.Vector3(-0.5, 0.5, 0))).length - sizeOffset.y) / 1000.0,\n                (this.from.GetPointByAnchor(new math_1.Vector3(0.5, -0.5, 0)).sub(this.from.GetPointByAnchor(new math_1.Vector3(-0.5, -0.5, 0))).length - sizeOffset.x) / 1000.0,\n            ];\n            for (let i = 0; i < 4; i++) {\n                let edgeData = modifier.edges[i];\n                const height = heights[i];\n                const depth = edgeData.type == enums_1.LDSPEdgeType.MM2 ? 0.0002 : 0.00004;\n                let position = new math_1.Vector3();\n                let rotation = new math_1.Quaternion();\n                switch (i) {\n                    case 0:\n                        position = left\n                            .add(positionOffset.div(2000.0))\n                            .add(new math_1.Vector3(depth / 2.0, 0, 0))\n                            .invertX();\n                        rotation = new math_1.Quaternion();\n                        break;\n                    case 1:\n                        position = top\n                            .add(positionOffset.div(2000.0))\n                            .add(new math_1.Vector3(0, depth / 2.0, 0))\n                            .invertX();\n                        rotation = math_1.Quaternion.euler(-180, 0, -90 + modifier.cut_angle2).toRH();\n                        break;\n                    case 2:\n                        position = right\n                            .add(positionOffset.div(2000.0))\n                            .add(new math_1.Vector3(-depth / 2.0, 0, 0))\n                            .invertX();\n                        rotation = math_1.Quaternion.euler(0, 180, 0).toRH();\n                        break;\n                    case 3:\n                        position = bottom\n                            .add(positionOffset.div(2000.0))\n                            .add(new math_1.Vector3(0, -depth / 2.0, 0))\n                            .invertX();\n                        rotation = math_1.Quaternion.euler(180, 0, 90 + modifier.cut_angle1).toRH();\n                        break;\n                }\n                const cut_angles = LDSPBuilder.GetEdgeCutAngles(i, modifier.edges);\n                let geometry;\n                if (modifier.edges[i].type == enums_1.LDSPEdgeType.MM2)\n                    geometry = new ShapedMesh(new math_1.Vector3(depth, height, this.from.data.size.z / 1000.0), localShape, cut_angles[0], cut_angles[1], position, rotation);\n                else\n                    geometry = new PrimitiveMesh(new math_1.Vector3(depth, height, this.from.data.size.z / 1000.0), cut_angles[0], cut_angles[1], [0, 1, 2, 3, 4, 5], position, rotation);\n                batches.CreateOrUpdateBatchByMaterial(\"edge\" + i, geometry, edgeMaterials[i]);\n            }\n            batches.UpdateFrontendData(this.result);\n            const processings = this.from.data.processings == null ? [] : this.from.data.processings;\n            const textureCoordinatesProcessing = processings.find((p) => p.type === 2);\n            if (textureCoordinatesProcessing != null) {\n                for (let key in this.result.children) {\n                    const uvs = {};\n                    uvs.offset = textureCoordinatesProcessing.offset;\n                    uvs.scale = textureCoordinatesProcessing.scale;\n                    uvs.rotation = textureCoordinatesProcessing.rotation;\n                    this.result.children[key][\"uvs\"] = uvs;\n                }\n            }\n        });\n    }\n}\nexports.LDSPBuilder = LDSPBuilder;\nclass PerforationBuilder extends ProductPartBuilder {\n    CreateResult() {\n        return product_parts_1.GroupPartFactory.CreateNew();\n    }\n    Build() {\n        const _super = Object.create(null, {\n            Build: { get: () => super.Build }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.Build.call(this);\n            this.result.type = product_parts_1.ProductPartType.Group;\n            this.result.children = {};\n            const batches = new BatchCollection();\n            const mesh = new PrimitiveMesh(this.from.data.size.div(1000.0));\n            const mainMaterial = yield this.from.GetMaterialData(this.caller.isWebPBRExtrasActive, this.caller.isWebARActive);\n            batches.CreateOrUpdateBatchByMaterial(\"main\", mesh, mainMaterial);\n            let targetPlaneMaterial = new Material();\n            targetPlaneMaterial.UpdateFrom(mainMaterial);\n            targetPlaneMaterial.ao = new Texture();\n            targetPlaneMaterial.diffuse = new Texture();\n            targetPlaneMaterial.metallic = new Texture();\n            targetPlaneMaterial.normal = new Texture();\n            targetPlaneMaterial.roughness = new Texture();\n            targetPlaneMaterial.emissive = new Texture();\n            targetPlaneMaterial.color = \"#000000\";\n            targetPlaneMaterial.web.alphaTest = 0.5;\n            targetPlaneMaterial.web.transparent = true;\n            const modifier = this.from.data.modifier;\n            for (let i = 0; i < modifier.depth; i++) {\n                const z = this.from.data.size.z / 1000.0;\n                const offset = ((i + 2.0) / modifier.depth) * (z / 2.1);\n                const planeMesh = new PrimitiveMesh(this.from.data.size.div(1000.0), 0, 0, [0, 2], new math_1.Vector3(0, 0, z / 2.0 - offset), new math_1.Quaternion(), new math_1.Vector3(1, 1, 0.00001));\n                const plane2Mesh = new PrimitiveMesh(this.from.data.size.div(1000.0), 0, 0, [0, 2], new math_1.Vector3(0, 0, z / 2.0 - offset), new math_1.Quaternion(), new math_1.Vector3(1, 1, 0.00001));\n                batches.CreateOrUpdateBatchByMaterial(\"plane_front\" + i, planeMesh, targetPlaneMaterial);\n                batches.CreateOrUpdateBatchByMaterial(\"plane_back\" + i, plane2Mesh, targetPlaneMaterial);\n            }\n            batches.UpdateFrontendData(this.result);\n        });\n    }\n}\nexports.PerforationBuilder = PerforationBuilder;\nclass ArrayBuilder extends ProductPartBuilder {\n    CreateResult() {\n        return product_parts_1.ArrayProductPartFactory.CreateNew();\n    }\n    Build() {\n        const _super = Object.create(null, {\n            Build: { get: () => super.Build }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.Build.call(this);\n            this.result.type = product_parts_1.ProductPartType.Array;\n            const modifier = this.from.data.modifier;\n            const childComponent = modifier.child;\n            if (childComponent == null) {\n                this.isProperResult = false;\n                return;\n            }\n            let childPartBuilder = null;\n            if (childComponent.modifier.type == enums_1.ProjectComponentModifierType.MESH)\n                childPartBuilder = new MeshBuilder(this.caller, new project_component_implementation_1.ProjectComponentImplementation(this.caller.projectAssembler, childComponent));\n            else if (childComponent.modifier.type == enums_1.ProjectComponentModifierType.DUMMY)\n                childPartBuilder = new GeometryBuilder(this.caller, new project_component_implementation_1.ProjectComponentImplementation(this.caller.projectAssembler, childComponent));\n            if (childPartBuilder == null)\n                return; //TODO exception\n            yield childPartBuilder.Build();\n            this.result.component = childPartBuilder.result;\n            this.result.component_transforms = [];\n            for (let i = 0; i < modifier.count; i++) {\n                const tr = math_1.TransformFactory.CreateNew();\n                tr.position = modifier.offset\n                    .mult(i)\n                    .sub(modifier.offset.mult(modifier.count - 1).div(2.0))\n                    .div(1000.0);\n                tr.rotation = new math_1.Quaternion(childComponent.rotation).toRH();\n                this.result.component_transforms.push(tr);\n            }\n        });\n    }\n}\nexports.ArrayBuilder = ArrayBuilder;\nclass BuiltInBuilder extends ProductPartBuilder {\n    CreateResult() {\n        return product_parts_1.CalculationProductPartFactory.CreateNew();\n    }\n    Build() {\n        const _super = Object.create(null, {\n            Build: { get: () => super.Build }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.Build.call(this);\n            this.result.type = product_parts_1.ProductPartType.Calculation;\n            const modifier = this.from.data.modifier;\n            this.result.file = modifier.related_project;\n            if (this.caller.generateRelated) {\n                const core = this.caller.core;\n                const childIIK = core.related_calculations[this.from.data.guid];\n                if (childIIK == null) {\n                    this.isProperResult = false;\n                    return;\n                }\n                this.result.content = childIIK.frontend;\n                this.result.transform.position = this.from.data.position.div(1000).invertX();\n                if (!this.caller.isScene)\n                    this.result.transform.position = this.result.transform.position.add(childIIK.projectAssembler.GetProjectOffset());\n                this.result.transform.rotation = this.from.data.rotation.toRH();\n            }\n        });\n    }\n}\nexports.BuiltInBuilder = BuiltInBuilder;\nclass ModelGroupBuilder extends ProductPartBuilder {\n    CreateResult() {\n        return product_parts_1.GroupPartFactory.CreateNew();\n    }\n    Build() {\n        const _super = Object.create(null, {\n            Build: { get: () => super.Build }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.Build.call(this);\n            this.result.type = product_parts_1.ProductPartType.Group;\n            const modifier = this.from.data.modifier;\n            this.result.children = {};\n            let i = 0;\n            for (let node of modifier.nodes) {\n                let part = product_parts_1.MeshPartFactory.CreateNew();\n                part.type = product_parts_1.ProductPartType.Mesh;\n                part.file = filesystem_1.Filesystem.GetRelativePath(modifier.file);\n                part.node = node;\n                let targetMaterial = yield project_component_implementation_1.ProjectComponentImplementation.GetMaterialData(modifier.materials[i], this.caller.projectAssembler.targetProject.guid, this.caller.isWebPBRExtrasActive, this.caller.isWebARActive);\n                part.material = filesystem_1.Filesystem.Cache.GetCachedItem(targetMaterial).id;\n                this.result.children[node] = part;\n                i++;\n            }\n        });\n    }\n}\nexports.ModelGroupBuilder = ModelGroupBuilder;\nclass VirtualObjectBuilder {\n    constructor(caller, from) {\n        this.caller = caller;\n        this.from = from;\n        this.result = virtual_object_1.VirtualObjectBaseFactory.CreateNew();\n    }\n    Build() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            this.result.guid = this.from.guid;\n            this.result.transform.position = this.from.position\n                .div(1000.0)\n                .invertX();\n            const anyModifier = this.from.modifier;\n            let targetRotation = null;\n            if (anyModifier.rotation != null)\n                targetRotation = new math_1.Quaternion(anyModifier.rotation);\n            if (((_a = anyModifier.settings) === null || _a === void 0 ? void 0 : _a.rotation) != null)\n                targetRotation = new math_1.Quaternion(anyModifier.settings.rotation);\n            if (targetRotation == null)\n                targetRotation = new math_1.Quaternion();\n            this.result.transform.rotation = targetRotation.toRH();\n            this.result.is_active = this.from.is_active;\n        });\n    }\n}\nexports.VirtualObjectBuilder = VirtualObjectBuilder;\nclass ShadowPlaneBuilder extends VirtualObjectBuilder {\n    Build() {\n        const _super = Object.create(null, {\n            Build: { get: () => super.Build }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.Build.call(this);\n            this.result.type = virtual_object_1.VirtualObjectType.ShadowPlane;\n            const modifier = this.from.modifier;\n            this.result.transform.scale = new math_1.Vector3(modifier.size.x / 1000.0, 1.0, modifier.size.y / 1000.0);\n            let data = virtual_object_1.ShadowPlaneDataFactory.CreateNew();\n            data.shadow_type = modifier.shadow_type;\n            if (modifier.shadow_type == enums_1.ShadowPlaneType.CUSTOM)\n                data.path = modifier.settings.path;\n            this.result.data = data;\n        });\n    }\n}\nexports.ShadowPlaneBuilder = ShadowPlaneBuilder;\nclass CameraBuilder extends VirtualObjectBuilder {\n    Build() {\n        const _super = Object.create(null, {\n            Build: { get: () => super.Build }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.Build.call(this);\n            this.result.type = virtual_object_1.VirtualObjectType.Camera;\n            let data = null;\n            const modifier = this.from.modifier;\n            switch (modifier.camera_type) {\n                case enums_1.CameraType.STATIC:\n                    data = virtual_object_1.CameraDataFactory.CreateNew();\n                    break;\n                case enums_1.CameraType.SEQUENCE:\n                    const sequenceData = virtual_object_1.SequenceCameraDataFactory.CreateNew();\n                    const settings = modifier.settings;\n                    sequenceData.radius = settings.distance / 1000.0;\n                    if (settings.height_offset != null)\n                        sequenceData.height_offset =\n                            settings.height_offset / 1000.0;\n                    sequenceData.constraints = settings.constraints;\n                    data = sequenceData;\n                    break;\n                case enums_1.CameraType.SPHERE:\n                    const sphereData = virtual_object_1.SphericalCameraDataFactory.CreateNew();\n                    if (modifier.spheric_rotation != null)\n                        sphereData.spheric_rotation = new math_1.Vector2(modifier.spheric_rotation).div(180.0).mult(Math.PI);\n                    data = sphereData;\n                    break;\n            }\n            if (data == null)\n                return; //TODO error\n            data.camera_type = modifier.camera_type;\n            data.is_pov = modifier.is_pov === true;\n            this.result.data = data;\n        });\n    }\n}\nexports.CameraBuilder = CameraBuilder;\nclass LightBuilder extends VirtualObjectBuilder {\n    Build() {\n        const _super = Object.create(null, {\n            Build: { get: () => super.Build }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.Build.call(this);\n            this.result.type = virtual_object_1.VirtualObjectType.Light;\n            const data = virtual_object_1.LightDataFactory.CreateNew();\n            const modifier = this.from.modifier;\n            const settings = modifier.settings;\n            data.light_type = modifier.light_type;\n            data.isOn = settings.isOn;\n            data.color = settings.color;\n            data.intensity = settings.intensity;\n            data.temperature = settings.temperature;\n            data.range = settings.range;\n            data.angle = settings.angle;\n            data.isCastingShadows = modifier.is_casting_shadows;\n            data.spotInnerAngle = settings.spot;\n            data.spotOuterAngle = settings.spotOuterAngle;\n            data.width = settings.width;\n            data.height = settings.height;\n            data.barnDoorAngle = settings.barnDoorAngle;\n            data.barnDoorLength = settings.barnDoorLength;\n            this.result.data = data;\n        });\n    }\n}\nexports.LightBuilder = LightBuilder;\nclass ManipulatorBuilder extends VirtualObjectBuilder {\n    Build() {\n        const _super = Object.create(null, {\n            Build: { get: () => super.Build }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.Build.call(this);\n            this.result.type = virtual_object_1.VirtualObjectType.Manipulator;\n            const data = virtual_object_1.ManipulatorDataFactory.CreateNew();\n            const modifier = this.from.modifier;\n            data.radius = modifier.radius / 1000.0;\n            data.visual_part = modifier.visual_part;\n            data.points_distance = modifier.points_distance;\n            data.press_sound = modifier.press_sound;\n            data.release_sound = modifier.release_sound;\n            this.result.data = data;\n        });\n    }\n}\nexports.ManipulatorBuilder = ManipulatorBuilder;\nclass PointsDistanceBuilder extends VirtualObjectBuilder {\n    Build() {\n        const _super = Object.create(null, {\n            Build: { get: () => super.Build }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.Build.call(this);\n            this.result.type = virtual_object_1.VirtualObjectType.Distance;\n            const data = virtual_object_1.PointDistanceDataFactory.CreateNew();\n            const modifier = this.from.modifier;\n            data.color = modifier.color;\n            const project = this.caller.projectAssembler.targetProject;\n            //    .\n            let prePoint1 = this.caller.projectAssembler.FindPointByPath(modifier.point1);\n            let prePoint2 = this.caller.projectAssembler.FindPointByPath(modifier.point2);\n            if (prePoint1 == null || prePoint2 == null)\n                return; //TODO error\n            let position1 = this.caller.projectAssembler.GetPointPosition(prePoint1);\n            let position2 = this.caller.projectAssembler.GetPointPosition(prePoint2);\n            if (position1 == null || position2 == null)\n                return; //TODO error\n            let point1 = position1.div(1000.0).invertX();\n            let point2 = position2.div(1000.0).invertX();\n            data.lines = {};\n            data.lines.ledge1 = {};\n            data.lines.ledge1.point1 = point1;\n            data.lines.ledge2 = {};\n            data.lines.ledge2.point1 = point2;\n            data.lines.distance_line = {};\n            if (modifier.ledge_size != null && project.points_distance_ledge_end_size != null) {\n                let ledge_size = (modifier.ledge_size -\n                    project.points_distance_ledge_end_size) /\n                    1000;\n                let full_ledge_size = modifier.ledge_size / 1000;\n                let ledge1_point2;\n                let ledge2_point2;\n                let distance_line_point1;\n                let distance_line_point2;\n                if (!modifier.is_projection) {\n                    switch (modifier.ledge_type) {\n                        case 0:\n                            ledge1_point2 = new math_1.Vector3(point1.x, point1.y + full_ledge_size, point1.z);\n                            ledge2_point2 = new math_1.Vector3(point2.x, point2.y + full_ledge_size, point2.z);\n                            distance_line_point1 = new math_1.Vector3(point1.x, point1.y + ledge_size, point1.z);\n                            distance_line_point2 = new math_1.Vector3(point2.x, point2.y + ledge_size, point2.z);\n                            break;\n                        case 1:\n                            ledge1_point2 = new math_1.Vector3(point1.x, point1.y - full_ledge_size, point1.z);\n                            ledge2_point2 = new math_1.Vector3(point2.x, point2.y - full_ledge_size, point2.z);\n                            distance_line_point1 = new math_1.Vector3(point1.x, point1.y - ledge_size, point1.z);\n                            distance_line_point2 = new math_1.Vector3(point2.x, point2.y - ledge_size, point2.z);\n                            break;\n                        case 2:\n                            ledge1_point2 = new math_1.Vector3(point1.x - full_ledge_size, point1.y, point1.z);\n                            ledge2_point2 = new math_1.Vector3(point2.x - full_ledge_size, point2.y, point2.z);\n                            distance_line_point1 = new math_1.Vector3(point1.x - ledge_size, point1.y, point1.z);\n                            distance_line_point2 = new math_1.Vector3(point2.x - ledge_size, point2.y, point2.z);\n                            break;\n                        case 3:\n                            ledge1_point2 = new math_1.Vector3(point1.x + full_ledge_size, point1.y, point1.z);\n                            ledge2_point2 = new math_1.Vector3(point2.x + full_ledge_size, point2.y, point2.z);\n                            distance_line_point1 = new math_1.Vector3(point1.x + ledge_size, point1.y, point1.z);\n                            distance_line_point2 = new math_1.Vector3(point2.x + ledge_size, point2.y, point2.z);\n                            break;\n                        case 4:\n                            ledge1_point2 = new math_1.Vector3(point1.x, point1.y, point1.z + full_ledge_size);\n                            ledge2_point2 = new math_1.Vector3(point2.x, point2.y, point2.z + full_ledge_size);\n                            distance_line_point1 = new math_1.Vector3(point1.x, point1.y, point1.z + ledge_size);\n                            distance_line_point2 = new math_1.Vector3(point2.x, point2.y, point2.z + ledge_size);\n                            break;\n                        case 5:\n                            ledge1_point2 = new math_1.Vector3(point1.x, point1.y, point1.z - full_ledge_size);\n                            ledge2_point2 = new math_1.Vector3(point2.x, point2.y, point2.z - full_ledge_size);\n                            distance_line_point1 = new math_1.Vector3(point1.x, point1.y, point1.z - ledge_size);\n                            distance_line_point2 = new math_1.Vector3(point2.x, point2.y, point2.z - ledge_size);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                else {\n                    switch (modifier.ledge_type) {\n                        case 0:\n                            if (point1.y >= point2.y) {\n                                ledge1_point2 = new math_1.Vector3(point1.x, point1.y + full_ledge_size, point1.z);\n                                ledge2_point2 = new math_1.Vector3(point2.x, point2.y + full_ledge_size + Math.abs(point1.y - point2.y), point2.z);\n                                distance_line_point1 = new math_1.Vector3(point1.x, point1.y + ledge_size, point1.z);\n                                distance_line_point2 = new math_1.Vector3(point2.x, point2.y + ledge_size + Math.abs(point1.y - point2.y), point2.z);\n                            }\n                            else {\n                                ledge1_point2 = new math_1.Vector3(point1.x, point1.y + full_ledge_size + Math.abs(point1.y - point2.y), point1.z);\n                                ledge2_point2 = new math_1.Vector3(point2.x, point2.y + full_ledge_size, point2.z);\n                                distance_line_point1 = new math_1.Vector3(point1.x, point1.y + ledge_size + Math.abs(point1.y - point2.y), point1.z);\n                                distance_line_point2 = new math_1.Vector3(point2.x, point2.y + ledge_size, point2.z);\n                            }\n                            break;\n                        case 1:\n                            if (point1.y >= point2.y) {\n                                ledge1_point2 = new math_1.Vector3(point1.x, point1.y - full_ledge_size - Math.abs(point1.y - point2.y), point1.z);\n                                ledge2_point2 = new math_1.Vector3(point2.x, point2.y - full_ledge_size, point2.z);\n                                distance_line_point1 = new math_1.Vector3(point1.x, point1.y - ledge_size - Math.abs(point1.y - point2.y), point1.z);\n                                distance_line_point2 = new math_1.Vector3(point2.x, point2.y - ledge_size, point2.z);\n                            }\n                            else {\n                                ledge1_point2 = new math_1.Vector3(point1.x, point1.y - full_ledge_size, point1.z);\n                                ledge2_point2 = new math_1.Vector3(point2.x, point2.y - full_ledge_size - Math.abs(point1.y - point2.y), point2.z);\n                                distance_line_point1 = new math_1.Vector3(point1.x, point1.y - ledge_size, point1.z);\n                                distance_line_point2 = new math_1.Vector3(point2.x, point2.y - ledge_size - Math.abs(point1.y - point2.y), point2.z);\n                            }\n                            break;\n                        case 2:\n                            if (point1.x >= point2.x) {\n                                ledge1_point2 = new math_1.Vector3(point1.x - full_ledge_size - Math.abs(point1.x - point2.x), point1.y, point1.z);\n                                ledge2_point2 = new math_1.Vector3(point2.x - full_ledge_size, point2.y, point2.z);\n                                distance_line_point1 = new math_1.Vector3(point1.x - ledge_size - Math.abs(point1.x - point2.x), point1.y, point1.z);\n                                distance_line_point2 = new math_1.Vector3(point2.x - ledge_size, point2.y, point2.z);\n                            }\n                            else {\n                                ledge1_point2 = new math_1.Vector3(point1.x - full_ledge_size, point1.y, point1.z);\n                                ledge2_point2 = new math_1.Vector3(point2.x - full_ledge_size - Math.abs(point1.x - point2.x), point2.y, point2.z);\n                                distance_line_point1 = new math_1.Vector3(point1.x - ledge_size, point1.y, point1.z);\n                                distance_line_point2 = new math_1.Vector3(point2.x - ledge_size - Math.abs(point1.x - point2.x), point2.y, point2.z);\n                            }\n                            break;\n                        case 3:\n                            if (point1.x >= point2.x) {\n                                ledge1_point2 = new math_1.Vector3(point1.x + full_ledge_size, point1.y, point1.z);\n                                ledge2_point2 = new math_1.Vector3(point2.x + full_ledge_size + Math.abs(point1.x - point2.x), point2.y, point2.z);\n                                distance_line_point1 = new math_1.Vector3(point1.x + ledge_size, point1.y, point1.z);\n                                distance_line_point2 = new math_1.Vector3(point2.x + ledge_size + Math.abs(point1.x - point2.x), point2.y, point2.z);\n                            }\n                            else {\n                                ledge1_point2 = new math_1.Vector3(point1.x + full_ledge_size + Math.abs(point1.x - point2.x), point1.y, point1.z);\n                                ledge2_point2 = new math_1.Vector3(point2.x + full_ledge_size, point2.y, point2.z);\n                                distance_line_point1 = new math_1.Vector3(point1.x + ledge_size + Math.abs(point1.x - point2.x), point1.y, point1.z);\n                                distance_line_point2 = new math_1.Vector3(point2.x + ledge_size, point2.y, point2.z);\n                            }\n                            break;\n                        case 4:\n                            if (point1.z >= point2.z) {\n                                ledge1_point2 = new math_1.Vector3(point1.x, point1.y, point1.z + full_ledge_size);\n                                ledge2_point2 = new math_1.Vector3(point2.x, point2.y, point2.z + full_ledge_size + Math.abs(point1.z - point2.z));\n                                distance_line_point1 = new math_1.Vector3(point1.x, point1.y, point1.z + ledge_size);\n                                distance_line_point2 = new math_1.Vector3(point2.x, point2.y, point2.z + ledge_size + Math.abs(point1.z - point2.z));\n                            }\n                            else {\n                                ledge1_point2 = new math_1.Vector3(point1.x, point1.y, point1.z + full_ledge_size + Math.abs(point1.z - point2.z));\n                                ledge2_point2 = new math_1.Vector3(point2.x, point2.y, point2.z + full_ledge_size);\n                                distance_line_point1 = new math_1.Vector3(point1.x, point1.y, point1.z + ledge_size + Math.abs(point1.z - point2.z));\n                                distance_line_point2 = new math_1.Vector3(point2.x, point2.y, point2.z + ledge_size);\n                            }\n                            break;\n                        case 5:\n                            if (point1.z >= point2.z) {\n                                ledge1_point2 = new math_1.Vector3(point1.x, point1.y, point1.z - full_ledge_size - Math.abs(point1.z - point2.z));\n                                ledge2_point2 = new math_1.Vector3(point2.x, point2.y, point2.z - full_ledge_size);\n                                distance_line_point1 = new math_1.Vector3(point1.x, point1.y, point1.z - ledge_size - Math.abs(point1.z - point2.z));\n                                distance_line_point2 = new math_1.Vector3(point2.x, point2.y, point2.z - ledge_size);\n                            }\n                            else {\n                                ledge1_point2 = new math_1.Vector3(point1.x, point1.y, point1.z - full_ledge_size);\n                                ledge2_point2 = new math_1.Vector3(point2.x, point2.y, point2.z - full_ledge_size - Math.abs(point1.z - point2.z));\n                                distance_line_point1 = new math_1.Vector3(point1.x, point1.y, point1.z - ledge_size);\n                                distance_line_point2 = new math_1.Vector3(point2.x, point2.y, point2.z - ledge_size - Math.abs(point1.z - point2.z));\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                //    .\n                data.lines.ledge1.point2 = ledge1_point2;\n                data.lines.ledge2.point2 = ledge2_point2;\n                //    .\n                data.lines.distance_line.point1 = distance_line_point1;\n                data.lines.distance_line.point2 = distance_line_point2;\n                // .\n                let points_distance = math_1.Vector3.distance(data.lines.distance_line.point1, data.lines.distance_line.point2);\n                switch (project.points_distance_measurement_unit) {\n                    case 0:\n                        data.text = Math.round(points_distance * 1000) + \" \";\n                        break;\n                    case 1:\n                        data.text = (points_distance * 100).toFixed(1) + \" \";\n                        break;\n                    case 2:\n                        data.text = points_distance.toFixed(2) + \" \";\n                        break;\n                    default:\n                        break;\n                }\n                //   .\n                let distance_line_center = data.lines.distance_line.point1.add(data.lines.distance_line.point2).div(2.0);\n                let text_offset = modifier.text_offset / 1000;\n                switch (modifier.text_offset_axis) {\n                    case 0:\n                        data.text_position = new math_1.Vector3(distance_line_center.x, distance_line_center.y + text_offset, distance_line_center.z);\n                        break;\n                    case 1:\n                        data.text_position = new math_1.Vector3(distance_line_center.x, distance_line_center.y - text_offset, distance_line_center.z);\n                        break;\n                    case 2:\n                        data.text_position = new math_1.Vector3(distance_line_center.x - text_offset, distance_line_center.y, distance_line_center.z);\n                        break;\n                    case 3:\n                        data.text_position = new math_1.Vector3(distance_line_center.x + text_offset, distance_line_center.y, distance_line_center.z);\n                        break;\n                    case 4:\n                        data.text_position = new math_1.Vector3(distance_line_center.x, distance_line_center.y, distance_line_center.z + text_offset);\n                        break;\n                    case 5:\n                        data.text_position = new math_1.Vector3(distance_line_center.x, distance_line_center.y, distance_line_center.z - text_offset);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            this.result.data = data;\n        });\n    }\n}\nexports.PointsDistanceBuilder = PointsDistanceBuilder;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProductFactory = exports.ProductContainerFactory = void 0;\nconst virtual_object_1 = require(\"./virtual_object\");\nconst product_parts_1 = require(\"./product_parts\");\nconst environment_1 = require(\"../Environment/environment\");\nconst math_1 = require(\"../math\");\nconst utils_1 = require(\"../Project/utils\");\nclass ProductContainerFactory {\n    static CreateNew() {\n        return {\n            virtual_objects: {},\n            children: {},\n            transform: math_1.TransformFactory.CreateNew(),\n            normal: new math_1.Vector3(),\n            background_color: \"\",\n            type: \"group\",\n            points_distance_lines_weight: 0.0015,\n            points_distance_arrows_size: 10,\n            points_distance_text_size: 20,\n            points_distance_color: \"#0011AD\",\n        };\n    }\n    static Create(raw) {\n        var _a, _b, _c, _d, _e, _f;\n        if (!raw) {\n            return ProductContainerFactory.CreateNew();\n        }\n        return {\n            virtual_objects: raw[(0, utils_1.nameof)(\"virtual_objects\")]\n                ? Object.fromEntries(Object.entries(raw[(0, utils_1.nameof)(\"virtual_objects\")])\n                    .map(([key, value]) => [key, virtual_object_1.VirtualObjectBaseFactory.Create(value)])) : {},\n            children: raw[(0, utils_1.nameof)(\"children\")]\n                ? Object.fromEntries(Object.entries(raw[(0, utils_1.nameof)(\"children\")])\n                    .map(([key, value]) => [key, product_parts_1.ProductPartBaseFactory.Create(value)])) : {},\n            transform: raw[(0, utils_1.nameof)(\"transform\")] ? math_1.TransformFactory.Create(raw[(0, utils_1.nameof)(\"transform\")]) : math_1.TransformFactory.CreateNew(),\n            normal: raw[(0, utils_1.nameof)(\"normal\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"normal\")]) : new math_1.Vector3(),\n            background_color: (_a = raw[(0, utils_1.nameof)(\"background_color\")]) !== null && _a !== void 0 ? _a : \"\",\n            type: (_b = raw[(0, utils_1.nameof)(\"type\")]) !== null && _b !== void 0 ? _b : \"group\",\n            points_distance_lines_weight: (_c = raw[(0, utils_1.nameof)(\"points_distance_lines_weight\")]) !== null && _c !== void 0 ? _c : 0.0015,\n            points_distance_arrows_size: (_d = raw[(0, utils_1.nameof)(\"points_distance_arrows_size\")]) !== null && _d !== void 0 ? _d : 10,\n            points_distance_text_size: (_e = raw[(0, utils_1.nameof)(\"points_distance_text_size\")]) !== null && _e !== void 0 ? _e : 20,\n            points_distance_color: (_f = raw[(0, utils_1.nameof)(\"points_distance_color\")]) !== null && _f !== void 0 ? _f : \"#0011AD\",\n        };\n    }\n}\nexports.ProductContainerFactory = ProductContainerFactory;\nclass ProductFactory {\n    static CreateNew() {\n        return {\n            product_container: ProductContainerFactory.CreateNew(),\n            user_data: \"isMovable=0\",\n            connection_type: \"floor\",\n            world: environment_1.WorldSettingsFactory.CreateNew(),\n        };\n    }\n    static Create(raw) {\n        var _a, _b;\n        if (!raw) {\n            return ProductFactory.CreateNew();\n        }\n        return {\n            product_container: raw[(0, utils_1.nameof)(\"product_container\")] ? ProductContainerFactory.Create(raw[(0, utils_1.nameof)(\"product_container\")]) : ProductContainerFactory.CreateNew(),\n            user_data: (_a = raw[(0, utils_1.nameof)(\"user_data\")]) !== null && _a !== void 0 ? _a : \"isMovable=0\",\n            connection_type: (_b = raw[(0, utils_1.nameof)(\"connection_type\")]) !== null && _b !== void 0 ? _b : \"floor\",\n            world: raw[(0, utils_1.nameof)(\"world\")] ? environment_1.WorldSettingsFactory.Create(raw[(0, utils_1.nameof)(\"world\")]) : environment_1.WorldSettingsFactory.CreateNew(),\n        };\n    }\n}\nexports.ProductFactory = ProductFactory;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CalculationProductPartFactory = exports.ArrayProductPartFactory = exports.GeometryPartFactory = exports.MeshPartFactory = exports.GroupPartFactory = exports.ProductPartBaseFactory = exports.UVTransformFactory = exports.ProductPartType = void 0;\nconst product_1 = require(\"./product\");\nconst utils_1 = require(\"../Project/utils\");\nconst math_1 = require(\"../math\");\nvar ProductPartType;\n(function (ProductPartType) {\n    ProductPartType[\"Group\"] = \"model_group\";\n    ProductPartType[\"Mesh\"] = \"model_node\";\n    ProductPartType[\"Geometry\"] = \"geometry\";\n    ProductPartType[\"Calculation\"] = \"calculation\";\n    ProductPartType[\"Array\"] = \"array\";\n})(ProductPartType || (exports.ProductPartType = ProductPartType = {}));\nclass UVTransformFactory {\n    static CreateNew() {\n        return {\n            offset: new math_1.Vector2(),\n            scale: new math_1.Vector2(1, 1),\n            rotation: 0,\n        };\n    }\n    static Create(raw) {\n        var _a;\n        if (!raw) {\n            return UVTransformFactory.CreateNew();\n        }\n        return {\n            offset: raw[(0, utils_1.nameof)(\"offset\")] ? new math_1.Vector2(raw[(0, utils_1.nameof)(\"offset\")]) : new math_1.Vector2(),\n            scale: raw[(0, utils_1.nameof)(\"scale\")] ? new math_1.Vector2(raw[(0, utils_1.nameof)(\"scale\")]) : new math_1.Vector2(1, 1),\n            rotation: (_a = raw[(0, utils_1.nameof)(\"rotation\")]) !== null && _a !== void 0 ? _a : 0,\n        };\n    }\n}\nexports.UVTransformFactory = UVTransformFactory;\nclass ProductPartBaseFactory {\n    static CreateNew() {\n        return {\n            transform: math_1.TransformFactory.CreateNew(),\n            name: \"\",\n            build_order: 0,\n            order: 0,\n            user_data: \"\",\n            is_active: true,\n            type: ProductPartType.Group,\n        };\n    }\n    static CreateInternal(raw) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        return {\n            transform: math_1.TransformFactory.Create((_a = raw[(0, utils_1.nameof)(\"transform\")]) !== null && _a !== void 0 ? _a : {}),\n            name: (_b = raw[(0, utils_1.nameof)(\"name\")]) !== null && _b !== void 0 ? _b : \"\",\n            build_order: (_c = raw[(0, utils_1.nameof)(\"build_order\")]) !== null && _c !== void 0 ? _c : 0,\n            order: (_d = raw[(0, utils_1.nameof)(\"order\")]) !== null && _d !== void 0 ? _d : 0,\n            user_data: (_e = raw[(0, utils_1.nameof)(\"user_data\")]) !== null && _e !== void 0 ? _e : \"\",\n            is_active: (_f = raw[(0, utils_1.nameof)(\"is_active\")]) !== null && _f !== void 0 ? _f : true,\n            type: (_g = raw[(0, utils_1.nameof)(\"type\")]) !== null && _g !== void 0 ? _g : ProductPartType.Group,\n        };\n    }\n    static Create(raw) {\n        if (!raw) {\n            throw new Error(\"raw is undefined for ProductPartBaseFactory.Create\");\n        }\n        switch (raw[(0, utils_1.nameof)(\"type\")]) {\n            case ProductPartType.Group:\n                return GroupPartFactory.Create(raw);\n            case ProductPartType.Mesh:\n                return MeshPartFactory.Create(raw);\n            case ProductPartType.Geometry:\n                return GeometryPartFactory.Create(raw);\n            case ProductPartType.Calculation:\n                return CalculationProductPartFactory.Create(raw);\n            case ProductPartType.Array:\n                return ArrayProductPartFactory.Create(raw);\n            default:\n                throw new Error(`Unknown product part type: ${raw[(0, utils_1.nameof)(\"type\")]}`);\n        }\n    }\n}\nexports.ProductPartBaseFactory = ProductPartBaseFactory;\nclass GroupPartFactory extends ProductPartBaseFactory {\n    static CreateNew() {\n        return Object.assign(Object.assign({}, ProductPartBaseFactory.CreateNew()), { children: {}, type: ProductPartType.Group, uvs: UVTransformFactory.CreateNew() });\n    }\n    static Create(raw) {\n        var _a;\n        if (!raw) {\n            return GroupPartFactory.CreateNew();\n        }\n        return Object.assign(Object.assign({}, ProductPartBaseFactory.CreateInternal(raw)), { children: (_a = raw[(0, utils_1.nameof)(\"children\")]) !== null && _a !== void 0 ? _a : {}, type: ProductPartType.Group, uvs: raw[(0, utils_1.nameof)(\"uvs\")] ? UVTransformFactory.Create(raw[(0, utils_1.nameof)(\"uvs\")]) : UVTransformFactory.CreateNew() });\n    }\n}\nexports.GroupPartFactory = GroupPartFactory;\nclass MeshPartFactory extends ProductPartBaseFactory {\n    static CreateNew() {\n        return Object.assign(Object.assign({}, ProductPartBaseFactory.CreateNew()), { file: \"\", node: \"\", material: \"\", type: ProductPartType.Mesh, uvs: UVTransformFactory.CreateNew() });\n    }\n    static Create(raw) {\n        var _a, _b, _c;\n        if (!raw) {\n            return MeshPartFactory.CreateNew();\n        }\n        return Object.assign(Object.assign({}, ProductPartBaseFactory.CreateInternal(raw)), { file: (_a = raw[(0, utils_1.nameof)(\"file\")]) !== null && _a !== void 0 ? _a : \"\", node: (_b = raw[(0, utils_1.nameof)(\"node\")]) !== null && _b !== void 0 ? _b : \"\", material: (_c = raw[(0, utils_1.nameof)(\"material\")]) !== null && _c !== void 0 ? _c : \"\", type: ProductPartType.Mesh, uvs: raw[(0, utils_1.nameof)(\"uvs\")] ? UVTransformFactory.Create(raw[(0, utils_1.nameof)(\"uvs\")]) : UVTransformFactory.CreateNew() });\n    }\n}\nexports.MeshPartFactory = MeshPartFactory;\nclass GeometryPartFactory extends ProductPartBaseFactory {\n    static CreateNew() {\n        return Object.assign(Object.assign({}, ProductPartBaseFactory.CreateNew()), { geometry: \"\", material: \"\", type: ProductPartType.Geometry, uvs: UVTransformFactory.CreateNew() });\n    }\n    static Create(raw) {\n        var _a, _b;\n        if (!raw) {\n            return GeometryPartFactory.CreateNew();\n        }\n        return Object.assign(Object.assign({}, ProductPartBaseFactory.CreateInternal(raw)), { geometry: (_a = raw[(0, utils_1.nameof)(\"geometry\")]) !== null && _a !== void 0 ? _a : \"\", material: (_b = raw[(0, utils_1.nameof)(\"material\")]) !== null && _b !== void 0 ? _b : \"\", type: ProductPartType.Geometry, uvs: raw[(0, utils_1.nameof)(\"uvs\")] ? UVTransformFactory.Create(raw[(0, utils_1.nameof)(\"uvs\")]) : UVTransformFactory.CreateNew() });\n    }\n}\nexports.GeometryPartFactory = GeometryPartFactory;\nclass ArrayProductPartFactory extends ProductPartBaseFactory {\n    static CreateNew() {\n        return Object.assign(Object.assign({}, ProductPartBaseFactory.CreateNew()), { component: ProductPartBaseFactory.CreateNew(), component_transforms: [], type: ProductPartType.Array });\n    }\n    static Create(raw) {\n        if (!raw) {\n            return ArrayProductPartFactory.CreateNew();\n        }\n        return Object.assign(Object.assign({}, ProductPartBaseFactory.CreateInternal(raw)), { component: raw[(0, utils_1.nameof)(\"component\")] ? ProductPartBaseFactory.Create(raw[(0, utils_1.nameof)(\"component\")]) : ProductPartBaseFactory.CreateNew(), component_transforms: raw[(0, utils_1.nameof)(\"component_transforms\")] ? raw[(0, utils_1.nameof)(\"component_transforms\")].map((t) => math_1.TransformFactory.Create(t)) : [], type: ProductPartType.Array });\n    }\n}\nexports.ArrayProductPartFactory = ArrayProductPartFactory;\nclass CalculationProductPartFactory extends ProductPartBaseFactory {\n    static CreateNew() {\n        return Object.assign(Object.assign({}, ProductPartBaseFactory.CreateNew()), { file: \"\", content: null, type: ProductPartType.Calculation });\n    }\n    static Create(raw) {\n        var _a;\n        if (!raw) {\n            return CalculationProductPartFactory.CreateNew();\n        }\n        return Object.assign(Object.assign({}, ProductPartBaseFactory.CreateInternal(raw)), { file: (_a = raw[(0, utils_1.nameof)(\"file\")]) !== null && _a !== void 0 ? _a : \"\", content: raw[(0, utils_1.nameof)(\"content\")] ? product_1.ProductFactory.Create(raw[(0, utils_1.nameof)(\"content\")]) : null, type: ProductPartType.Calculation });\n    }\n}\nexports.CalculationProductPartFactory = CalculationProductPartFactory;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Shape = void 0;\nconst math_1 = require(\"../math\");\nclass Shape {\n    constructor(rawData) {\n        this.offset_left = 0;\n        this.offset_right = 0;\n        this.offset_top = 0;\n        this.offset_bottom = 0;\n        this.data = [];\n        this.offset_left = rawData.offset_left;\n        this.offset_right = rawData.offset_right;\n        this.offset_top = rawData.offset_top;\n        this.offset_bottom = rawData.offset_bottom;\n        for (let v of rawData.data)\n            this.data.push(new math_1.Vector2(v));\n    }\n    static GetShapeSize(data) {\n        if (data == null)\n            return new math_1.Vector2();\n        const min = new math_1.Vector2(1, 1).mult(Number.MAX_VALUE);\n        const max = new math_1.Vector2(1, 1).mult(Number.MIN_VALUE);\n        for (let s of data) {\n            if (s.x < min.x)\n                min.x = s.x;\n            if (s.x > max.x)\n                max.x = s.x;\n            if (s.y < min.y)\n                min.y = s.y;\n            if (s.y > max.y)\n                max.y = s.y;\n        }\n        return max.sub(min);\n    }\n    static GetShapeFromData(shape, width, height, is_mirrored) {\n        if (height == null)\n            height = 16;\n        function CenterShape(data) {\n            const result = [];\n            let sum = new math_1.Vector2();\n            for (const s of data)\n                sum = sum.add(s);\n            sum = sum.div(data.length);\n            for (const s of data)\n                result.push(s.sub(sum));\n            return result;\n        }\n        function MirrorShape(data) {\n            for (let v of data)\n                v.x = -v.x;\n            return data.reverse();\n        }\n        let result = [];\n        if (shape.data == null) {\n            for (let i = 0; i < shape.length; i++)\n                result[i] = new math_1.Vector2(shape[i]);\n            result = CenterShape(result);\n            if (is_mirrored)\n                result = MirrorShape(result);\n            return result;\n        }\n        for (let i = 0; i < shape.data.length; i++)\n            result[i] = new math_1.Vector2(shape.data[i]);\n        result = CenterShape(result);\n        if (is_mirrored)\n            result = MirrorShape(result);\n        if (shape.offset_left == 0 &&\n            shape.offset_right == 0 &&\n            shape.offset_top == 0 &&\n            shape.offset_bottom == 0)\n            return result;\n        const size = Shape.GetShapeSize(result);\n        if (shape.offset_top == null)\n            shape.offset_top = 0;\n        if (shape.offset_bottom == null)\n            shape.offset_bottom = 0;\n        const ol = shape.offset_left / 1000.0;\n        const or = shape.offset_right / 1000.0;\n        const ot = shape.offset_top / 1000.0;\n        const ob = shape.offset_bottom / 1000.0;\n        const dx = (width - size.x) / 2.0;\n        const dy = (height - size.y) / 2.0;\n        if (ol != 0 && or != 0) {\n            for (let i = 0; i < result.length; i++) {\n                const v = result[i];\n                if (v.x < ol - size.x / 2.0)\n                    v.x -= dx;\n                if (v.x > -or + size.x / 2.0)\n                    v.x += dx;\n                result[i] = v;\n            }\n        }\n        else if (ol != 0) {\n            for (let i = 0; i < result.length; i++) {\n                const v = result[i];\n                if (v.x < ol - size.x / 2.0)\n                    v.x -= dx;\n                if (v.x > ol - size.x / 2.0)\n                    v.x += dx;\n                result[i] = v;\n            }\n        }\n        else if (or != 0) {\n            for (let i = 0; i < result.length; i++) {\n                const v = result[i];\n                if (v.x < -or + size.x / 2.0)\n                    v.x -= dx;\n                if (v.x > -or + size.x / 2.0)\n                    v.x += dx;\n                result[i] = v;\n            }\n        }\n        if (ob != 0 && ot != 0) {\n            for (let i = 0; i < result.length; i++) {\n                const v = result[i];\n                if (v.y < ob - size.y / 2.0)\n                    v.y -= dy;\n                if (v.y > -ot + size.y / 2.0)\n                    v.y += dy;\n                result[i] = v;\n            }\n        }\n        else if (ob != 0) {\n            for (let i = 0; i < result.length; i++) {\n                const v = result[i];\n                if (v.y < ob - size.y / 2.0)\n                    v.y -= dy;\n                if (v.y > ob - size.y / 2.0)\n                    v.y += dy;\n                result[i] = v;\n            }\n        }\n        else if (ot != 0) {\n            for (let i = 0; i < result.length; i++) {\n                const v = result[i];\n                if (v.y < -ot + size.y / 2.0)\n                    v.y -= dy;\n                if (v.y > -ot + size.y / 2.0)\n                    v.y += dy;\n                result[i] = v;\n            }\n        }\n        return result;\n    }\n}\nexports.Shape = Shape;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VirtualObjectBaseFactory = exports.PointDistanceDataFactory = exports.ManipulatorDataFactory = exports.LightDataFactory = exports.SequenceCameraDataFactory = exports.SequenceCameraConstraintsFactory = exports.TargetConstraintFactory = exports.ElevationConstraintFactory = exports.AzimuthConstraintFactory = exports.DistanceConstraintFactory = exports.CameraConstraintFactory = exports.SphericalCameraDataFactory = exports.CameraDataFactory = exports.ShadowPlaneFileDataFactory = exports.ShadowPlaneDataFactory = exports.VirtualObjectDataFactory = exports.VirtualObjectType = void 0;\nconst enums_1 = require(\"../Project/enums\");\nconst math_1 = require(\"../math\");\nconst utils_1 = require(\"../Project/utils\");\nvar VirtualObjectType;\n(function (VirtualObjectType) {\n    VirtualObjectType[\"ShadowPlane\"] = \"shadow_plane\";\n    VirtualObjectType[\"Camera\"] = \"camera\";\n    VirtualObjectType[\"Light\"] = \"light\";\n    VirtualObjectType[\"Manipulator\"] = \"manipulator\";\n    VirtualObjectType[\"Distance\"] = \"points_distance\";\n})(VirtualObjectType || (exports.VirtualObjectType = VirtualObjectType = {}));\nclass VirtualObjectDataFactory {\n    static CreateNew() {\n        return {};\n    }\n    static Create(raw) {\n        if (!raw) {\n            return VirtualObjectDataFactory.CreateNew();\n        }\n        return {};\n    }\n}\nexports.VirtualObjectDataFactory = VirtualObjectDataFactory;\nclass ShadowPlaneDataFactory {\n    static CreateNew() {\n        return {\n            shadow_type: enums_1.ShadowPlaneType.SQUARE,\n            path: \"\",\n        };\n    }\n    static Create(raw) {\n        var _a;\n        if (!raw) {\n            return ShadowPlaneDataFactory.CreateNew();\n        }\n        return {\n            shadow_type: (_a = raw[(0, utils_1.nameof)(\"shadow_type\")]) !== null && _a !== void 0 ? _a : enums_1.ShadowPlaneType.SQUARE,\n            path: raw[(0, utils_1.nameof)(\"path\")],\n        };\n    }\n}\nexports.ShadowPlaneDataFactory = ShadowPlaneDataFactory;\nclass ShadowPlaneFileDataFactory {\n    static CreateNew() {\n        return {\n            shadow_type: enums_1.ShadowPlaneType.SQUARE,\n            path: \"\",\n        };\n    }\n    static Create(raw) {\n        var _a, _b;\n        if (!raw) {\n            return ShadowPlaneFileDataFactory.CreateNew();\n        }\n        return {\n            shadow_type: (_a = raw[(0, utils_1.nameof)(\"shadow_type\")]) !== null && _a !== void 0 ? _a : enums_1.ShadowPlaneType.SQUARE,\n            path: (_b = raw[(0, utils_1.nameof)(\"path\")]) !== null && _b !== void 0 ? _b : \"\",\n        };\n    }\n}\nexports.ShadowPlaneFileDataFactory = ShadowPlaneFileDataFactory;\nclass CameraDataFactory {\n    static CreateNew() {\n        return {\n            camera_type: enums_1.CameraType.STATIC,\n            order: 0,\n            is_pov: false,\n        };\n    }\n    static Create(raw) {\n        var _a, _b, _c;\n        if (!raw) {\n            return CameraDataFactory.CreateNew();\n        }\n        return {\n            camera_type: (_a = raw[(0, utils_1.nameof)(\"camera_type\")]) !== null && _a !== void 0 ? _a : enums_1.CameraType.STATIC,\n            order: (_b = raw[(0, utils_1.nameof)(\"order\")]) !== null && _b !== void 0 ? _b : 0,\n            is_pov: (_c = raw[(0, utils_1.nameof)(\"is_pov\")]) !== null && _c !== void 0 ? _c : false,\n        };\n    }\n}\nexports.CameraDataFactory = CameraDataFactory;\nclass SphericalCameraDataFactory {\n    static CreateNew() {\n        return Object.assign(Object.assign({}, CameraDataFactory.CreateNew()), { spheric_rotation: new math_1.Vector2() });\n    }\n    static Create(raw) {\n        if (!raw) {\n            return SphericalCameraDataFactory.CreateNew();\n        }\n        return Object.assign(Object.assign({}, CameraDataFactory.Create(raw)), { spheric_rotation: raw[(0, utils_1.nameof)(\"spheric_rotation\")] ? new math_1.Vector2(raw[(0, utils_1.nameof)(\"spheric_rotation\")]) : new math_1.Vector2() });\n    }\n}\nexports.SphericalCameraDataFactory = SphericalCameraDataFactory;\nclass CameraConstraintFactory {\n    static CreateNew() {\n        return {\n            is_active: false,\n        };\n    }\n    static Create(raw) {\n        var _a;\n        if (!raw) {\n            return CameraConstraintFactory.CreateNew();\n        }\n        return {\n            is_active: (_a = raw[(0, utils_1.nameof)(\"is_active\")]) !== null && _a !== void 0 ? _a : false,\n        };\n    }\n}\nexports.CameraConstraintFactory = CameraConstraintFactory;\nclass DistanceConstraintFactory {\n    static CreateNew() {\n        return Object.assign(Object.assign({}, CameraConstraintFactory.CreateNew()), { min: 0, max: 0 });\n    }\n    static Create(raw) {\n        var _a, _b;\n        if (!raw) {\n            return DistanceConstraintFactory.CreateNew();\n        }\n        return Object.assign(Object.assign({}, CameraConstraintFactory.Create(raw)), { min: (_a = raw[(0, utils_1.nameof)(\"min\")]) !== null && _a !== void 0 ? _a : 0, max: (_b = raw[(0, utils_1.nameof)(\"max\")]) !== null && _b !== void 0 ? _b : 0 });\n    }\n}\nexports.DistanceConstraintFactory = DistanceConstraintFactory;\nclass AzimuthConstraintFactory {\n    static CreateNew() {\n        return Object.assign(Object.assign({}, CameraConstraintFactory.CreateNew()), { left: 0, right: 0 });\n    }\n    static Create(raw) {\n        var _a, _b;\n        if (!raw) {\n            return AzimuthConstraintFactory.CreateNew();\n        }\n        return Object.assign(Object.assign({}, CameraConstraintFactory.Create(raw)), { left: (_a = raw[(0, utils_1.nameof)(\"left\")]) !== null && _a !== void 0 ? _a : 0, right: (_b = raw[(0, utils_1.nameof)(\"right\")]) !== null && _b !== void 0 ? _b : 0 });\n    }\n}\nexports.AzimuthConstraintFactory = AzimuthConstraintFactory;\nclass ElevationConstraintFactory {\n    static CreateNew() {\n        return Object.assign(Object.assign({}, CameraConstraintFactory.CreateNew()), { down: 0, up: 0 });\n    }\n    static Create(raw) {\n        var _a, _b;\n        if (!raw) {\n            return ElevationConstraintFactory.CreateNew();\n        }\n        return Object.assign(Object.assign({}, CameraConstraintFactory.Create(raw)), { down: (_a = raw[(0, utils_1.nameof)(\"down\")]) !== null && _a !== void 0 ? _a : 0, up: (_b = raw[(0, utils_1.nameof)(\"up\")]) !== null && _b !== void 0 ? _b : 0 });\n    }\n}\nexports.ElevationConstraintFactory = ElevationConstraintFactory;\nclass TargetConstraintFactory {\n    static CreateNew() {\n        return Object.assign(Object.assign({}, CameraConstraintFactory.CreateNew()), { type: \"\", radius: 0 });\n    }\n    static Create(raw) {\n        var _a, _b;\n        if (!raw) {\n            return TargetConstraintFactory.CreateNew();\n        }\n        return Object.assign(Object.assign({}, CameraConstraintFactory.Create(raw)), { type: (_a = raw[(0, utils_1.nameof)(\"type\")]) !== null && _a !== void 0 ? _a : \"\", radius: (_b = raw[(0, utils_1.nameof)(\"radius\")]) !== null && _b !== void 0 ? _b : 0 });\n    }\n}\nexports.TargetConstraintFactory = TargetConstraintFactory;\nclass SequenceCameraConstraintsFactory {\n    static CreateNew() {\n        return {\n            distance: DistanceConstraintFactory.CreateNew(),\n            azimuth: AzimuthConstraintFactory.CreateNew(),\n            elevation: ElevationConstraintFactory.CreateNew(),\n            target: TargetConstraintFactory.CreateNew(),\n        };\n    }\n    static Create(raw) {\n        if (!raw) {\n            return SequenceCameraConstraintsFactory.CreateNew();\n        }\n        return {\n            distance: raw[(0, utils_1.nameof)(\"distance\")] ? DistanceConstraintFactory.Create(raw[(0, utils_1.nameof)(\"distance\")]) : DistanceConstraintFactory.CreateNew(),\n            azimuth: raw[(0, utils_1.nameof)(\"azimuth\")] ? AzimuthConstraintFactory.Create(raw[(0, utils_1.nameof)(\"azimuth\")]) : AzimuthConstraintFactory.CreateNew(),\n            elevation: raw[(0, utils_1.nameof)(\"elevation\")] ? ElevationConstraintFactory.Create(raw[(0, utils_1.nameof)(\"elevation\")]) : ElevationConstraintFactory.CreateNew(),\n            target: raw[(0, utils_1.nameof)(\"target\")] ? TargetConstraintFactory.Create(raw[(0, utils_1.nameof)(\"target\")]) : TargetConstraintFactory.CreateNew(),\n        };\n    }\n}\nexports.SequenceCameraConstraintsFactory = SequenceCameraConstraintsFactory;\nclass SequenceCameraDataFactory {\n    static CreateNew() {\n        return Object.assign(Object.assign({}, CameraDataFactory.CreateNew()), { radius: 0, height_offset: 0, constraints: SequenceCameraConstraintsFactory.CreateNew() });\n    }\n    static Create(raw) {\n        var _a, _b;\n        if (!raw) {\n            return SequenceCameraDataFactory.CreateNew();\n        }\n        return Object.assign(Object.assign({}, CameraDataFactory.Create(raw)), { radius: (_a = raw[(0, utils_1.nameof)(\"radius\")]) !== null && _a !== void 0 ? _a : 0, height_offset: (_b = raw[(0, utils_1.nameof)(\"height_offset\")]) !== null && _b !== void 0 ? _b : 0, constraints: raw[(0, utils_1.nameof)(\"constraints\")] ? SequenceCameraConstraintsFactory.Create(raw[(0, utils_1.nameof)(\"constraints\")]) : SequenceCameraConstraintsFactory.CreateNew() });\n    }\n}\nexports.SequenceCameraDataFactory = SequenceCameraDataFactory;\nclass LightDataFactory {\n    static CreateNew() {\n        return {\n            light_type: enums_1.LightType.DIRECTIONAL,\n            isOn: true,\n            color: \"\",\n            intensity: 1,\n            temperature: 0,\n            range: 0,\n            angle: 0,\n            isCastingShadows: true,\n            spotInnerAngle: 0,\n            spotOuterAngle: 0,\n            width: 0,\n            height: 0,\n            barnDoorAngle: 0,\n            barnDoorLength: 0,\n        };\n    }\n    static Create(raw) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n        if (!raw) {\n            return LightDataFactory.CreateNew();\n        }\n        return {\n            light_type: (_a = raw[(0, utils_1.nameof)(\"light_type\")]) !== null && _a !== void 0 ? _a : enums_1.LightType.DIRECTIONAL,\n            isOn: (_b = raw[(0, utils_1.nameof)(\"isOn\")]) !== null && _b !== void 0 ? _b : true,\n            color: (_c = raw[(0, utils_1.nameof)(\"color\")]) !== null && _c !== void 0 ? _c : \"\",\n            intensity: (_d = raw[(0, utils_1.nameof)(\"intensity\")]) !== null && _d !== void 0 ? _d : 1,\n            temperature: (_e = raw[(0, utils_1.nameof)(\"temperature\")]) !== null && _e !== void 0 ? _e : 0,\n            range: (_f = raw[(0, utils_1.nameof)(\"range\")]) !== null && _f !== void 0 ? _f : 0,\n            angle: (_g = raw[(0, utils_1.nameof)(\"angle\")]) !== null && _g !== void 0 ? _g : 0,\n            isCastingShadows: (_h = raw[(0, utils_1.nameof)(\"isCastingShadows\")]) !== null && _h !== void 0 ? _h : true,\n            spotInnerAngle: (_j = raw[(0, utils_1.nameof)(\"spotInnerAngle\")]) !== null && _j !== void 0 ? _j : 0,\n            spotOuterAngle: (_k = raw[(0, utils_1.nameof)(\"spotOuterAngle\")]) !== null && _k !== void 0 ? _k : 0,\n            width: (_l = raw[(0, utils_1.nameof)(\"width\")]) !== null && _l !== void 0 ? _l : 0,\n            height: (_m = raw[(0, utils_1.nameof)(\"height\")]) !== null && _m !== void 0 ? _m : 0,\n            barnDoorAngle: (_o = raw[(0, utils_1.nameof)(\"barnDoorAngle\")]) !== null && _o !== void 0 ? _o : 0,\n            barnDoorLength: (_p = raw[(0, utils_1.nameof)(\"barnDoorLength\")]) !== null && _p !== void 0 ? _p : 0,\n        };\n    }\n}\nexports.LightDataFactory = LightDataFactory;\nclass ManipulatorDataFactory {\n    static CreateNew() {\n        return {\n            radius: 0,\n            visual_part: \"\",\n            points_distance: \"\",\n            press_sound: \"\",\n            release_sound: \"\",\n        };\n    }\n    static Create(raw) {\n        var _a, _b, _c, _d, _e;\n        if (!raw) {\n            return ManipulatorDataFactory.CreateNew();\n        }\n        return {\n            radius: (_a = raw[(0, utils_1.nameof)(\"radius\")]) !== null && _a !== void 0 ? _a : 0,\n            visual_part: (_b = raw[(0, utils_1.nameof)(\"visual_part\")]) !== null && _b !== void 0 ? _b : \"\",\n            points_distance: (_c = raw[(0, utils_1.nameof)(\"points_distance\")]) !== null && _c !== void 0 ? _c : \"\",\n            press_sound: (_d = raw[(0, utils_1.nameof)(\"press_sound\")]) !== null && _d !== void 0 ? _d : \"\",\n            release_sound: (_e = raw[(0, utils_1.nameof)(\"release_sound\")]) !== null && _e !== void 0 ? _e : \"\",\n        };\n    }\n}\nexports.ManipulatorDataFactory = ManipulatorDataFactory;\nclass PointDistanceDataFactory {\n    static CreateNew() {\n        return {\n            lines: {},\n            color: \"\",\n            text: \"\",\n            text_position: new math_1.Vector3(),\n        };\n    }\n    static Create(raw) {\n        var _a, _b, _c;\n        if (!raw) {\n            return PointDistanceDataFactory.CreateNew();\n        }\n        return {\n            lines: (_a = raw[(0, utils_1.nameof)(\"lines\")]) !== null && _a !== void 0 ? _a : {},\n            color: (_b = raw[(0, utils_1.nameof)(\"color\")]) !== null && _b !== void 0 ? _b : \"\",\n            text: (_c = raw[(0, utils_1.nameof)(\"text\")]) !== null && _c !== void 0 ? _c : \"\",\n            text_position: raw[(0, utils_1.nameof)(\"text_position\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"text_position\")]) : new math_1.Vector3(),\n        };\n    }\n}\nexports.PointDistanceDataFactory = PointDistanceDataFactory;\nclass VirtualObjectBaseFactory {\n    static CreateNew() {\n        return {\n            guid: \"\",\n            type: VirtualObjectType.Camera,\n            transform: math_1.TransformFactory.CreateNew(),\n            data: VirtualObjectDataFactory.CreateNew(),\n            is_active: true,\n        };\n    }\n    static Create(raw) {\n        var _a, _b, _c;\n        if (!raw) {\n            return VirtualObjectBaseFactory.CreateNew();\n        }\n        const type = (_a = raw[(0, utils_1.nameof)(\"type\")]) !== null && _a !== void 0 ? _a : VirtualObjectType.Camera;\n        let dataFactory;\n        switch (type) {\n            case VirtualObjectType.ShadowPlane:\n                dataFactory = ShadowPlaneDataFactory;\n                break;\n            case VirtualObjectType.Camera:\n                dataFactory = CameraDataFactory;\n                break;\n            case VirtualObjectType.Light:\n                dataFactory = LightDataFactory;\n                break;\n            case VirtualObjectType.Manipulator:\n                dataFactory = ManipulatorDataFactory;\n                break;\n            case VirtualObjectType.Distance:\n                dataFactory = PointDistanceDataFactory;\n                break;\n            default:\n                dataFactory = VirtualObjectDataFactory;\n        }\n        return {\n            guid: (_b = raw[(0, utils_1.nameof)(\"guid\")]) !== null && _b !== void 0 ? _b : \"\",\n            type,\n            transform: raw[(0, utils_1.nameof)(\"transform\")] ? math_1.TransformFactory.Create(raw[(0, utils_1.nameof)(\"transform\")]) : math_1.TransformFactory.CreateNew(),\n            data: raw[(0, utils_1.nameof)(\"data\")] ? dataFactory.Create(raw[(0, utils_1.nameof)(\"data\")]) : dataFactory.CreateNew(),\n            is_active: (_c = raw[(0, utils_1.nameof)(\"is_active\")]) !== null && _c !== void 0 ? _c : true,\n        };\n    }\n}\nexports.VirtualObjectBaseFactory = VirtualObjectBaseFactory;\n","\"use strict\";\n// Array \nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectComponentArrayModifierFactory = void 0;\nconst project_component_1 = require(\"./project_component\");\nconst utils_1 = require(\"../../utils\");\nconst enums_1 = require(\"../../enums\");\nconst math_1 = require(\"../../../math\");\nclass ProjectComponentArrayModifierFactory {\n    static Create(raw) {\n        var _a;\n        return {\n            type: enums_1.ProjectComponentModifierType.ARRAY,\n            offset: raw[(0, utils_1.nameof)(\"offset\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"offset\")]) : new math_1.Vector3(0, 0, 0),\n            count: (_a = raw[(0, utils_1.nameof)(\"count\")]) !== null && _a !== void 0 ? _a : 1,\n            child: raw[(0, utils_1.nameof)(\"child\")] ? project_component_1.ProjectComponentFactory.Create(raw[(0, utils_1.nameof)(\"child\")]) : null,\n        };\n    }\n}\nexports.ProjectComponentArrayModifierFactory = ProjectComponentArrayModifierFactory;\n","\"use strict\";\n// BuiltIn \nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectComponentBuiltInModifierFactory = exports.BuiltInMarginFactory = void 0;\nconst utils_1 = require(\"../../utils\");\nconst enums_1 = require(\"../../enums\");\nclass BuiltInMarginFactory {\n    static Create(raw) {\n        return {\n            face: raw[(0, utils_1.nameof)('face')],\n            values: raw[(0, utils_1.nameof)('values')] || {},\n        };\n    }\n}\nexports.BuiltInMarginFactory = BuiltInMarginFactory;\nclass ProjectComponentBuiltInModifierFactory {\n    static CreateNew() {\n        return {\n            type: enums_1.ProjectComponentModifierType.BUILTIN,\n            related_project: \"\",\n            apply_offset: true,\n            show_inputs: true,\n            category: \"\",\n            target_slot: \"\",\n            allow_iik_slotting: false,\n            margins: [],\n        };\n    }\n    static Create(raw) {\n        var _a, _b, _c, _d, _e, _f;\n        return {\n            type: enums_1.ProjectComponentModifierType.BUILTIN,\n            related_project: (_a = raw[(0, utils_1.nameof)('related_project')]) !== null && _a !== void 0 ? _a : \"\",\n            apply_offset: (_b = raw[(0, utils_1.nameof)('apply_offset')]) !== null && _b !== void 0 ? _b : true,\n            show_inputs: (_c = raw[(0, utils_1.nameof)('show_inputs')]) !== null && _c !== void 0 ? _c : true,\n            category: (_d = raw[(0, utils_1.nameof)('category')]) !== null && _d !== void 0 ? _d : \"\",\n            target_slot: (_e = raw[(0, utils_1.nameof)('target_slot')]) !== null && _e !== void 0 ? _e : \"\",\n            allow_iik_slotting: (_f = raw[(0, utils_1.nameof)('allow_iik_slotting')]) !== null && _f !== void 0 ? _f : true,\n            margins: (raw[(0, utils_1.nameof)('margins')] || []).map((margin) => BuiltInMarginFactory.Create(margin)),\n        };\n    }\n}\nexports.ProjectComponentBuiltInModifierFactory = ProjectComponentBuiltInModifierFactory;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectComponentModifierFactory = void 0;\nconst ldsp_modifier_1 = require(\"./ldsp_modifier\");\nconst shape_modifier_1 = require(\"./shape_modifier\");\nconst mesh_modifier_1 = require(\"./mesh_modifier\");\nconst dummy_modifier_1 = require(\"./dummy_modifier\");\nconst array_modifier_1 = require(\"./array_modifier\");\nconst builtin_modifier_1 = require(\"./builtin_modifier\");\nconst OtherFactories = __importStar(require(\"./other_modifiers\"));\nconst utils_1 = require(\"../../utils\");\nconst enums_1 = require(\"../../enums\");\nclass ProjectComponentModifierFactory {\n    static CreateNew() {\n        return dummy_modifier_1.ProjectComponentDummyModifierFactory.Create({\n            cut_angle1: 0,\n            cut_angle2: 0,\n            target_faces: []\n        });\n    }\n    static Create(raw) {\n        const type = raw[(0, utils_1.nameof)(\"type\")];\n        switch (type) {\n            case enums_1.ProjectComponentModifierType.LDSP:\n                return ldsp_modifier_1.ProjectComponentLDSPModifierFactory.Create(raw);\n            case enums_1.ProjectComponentModifierType.SHAPE:\n                return shape_modifier_1.ProjectComponentShapeModifierFactory.Create(raw);\n            case enums_1.ProjectComponentModifierType.MESH:\n                return mesh_modifier_1.ProjectComponentMeshModifierFactory.Create(raw);\n            case enums_1.ProjectComponentModifierType.DUMMY:\n                return dummy_modifier_1.ProjectComponentDummyModifierFactory.Create(raw);\n            case enums_1.ProjectComponentModifierType.ARRAY:\n                return array_modifier_1.ProjectComponentArrayModifierFactory.Create(raw);\n            case enums_1.ProjectComponentModifierType.BUILTIN:\n                return builtin_modifier_1.ProjectComponentBuiltInModifierFactory.Create(raw);\n            case enums_1.ProjectComponentModifierType.GLASS:\n                return OtherFactories.ProjectComponentGlassModifierFactory.Create(raw);\n            case enums_1.ProjectComponentModifierType.LIGHT_SOURCE:\n                return OtherFactories.ProjectComponentLightSourceModifierFactory.Create(raw);\n            case enums_1.ProjectComponentModifierType.MDF_WITH_PAINT:\n                return OtherFactories.ProjectComponentMDFWithPaintModifierFactory.Create(raw);\n            case enums_1.ProjectComponentModifierType.MDF_WITH_FITTING:\n                return OtherFactories.ProjectComponentMDFWithFittingModifierFactory.Create(raw);\n            case enums_1.ProjectComponentModifierType.SOLID_WOOD:\n                return OtherFactories.ProjectComponentSolidWoodModifierFactory.Create(raw);\n            case enums_1.ProjectComponentModifierType.MODEL_GROUP:\n                return OtherFactories.ProjectComponentModelGroupModifierFactory.Create(raw);\n            case enums_1.ProjectComponentModifierType.PERFORATION:\n                return OtherFactories.ProjectComponentPerforationModifierFactory.Create(raw);\n            default:\n                throw new Error(`Unknown modifier type: ${type}`);\n        }\n    }\n}\nexports.ProjectComponentModifierFactory = ProjectComponentModifierFactory;\n","\"use strict\";\n// Dummy \nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectComponentDummyModifierFactory = exports.ProjectComponentSimpleModifierFactory = void 0;\nconst utils_1 = require(\"../../utils\");\nconst enums_1 = require(\"../../enums\");\nclass ProjectComponentSimpleModifierFactory {\n    static Create(raw) {\n        var _a, _b, _c;\n        return {\n            type: enums_1.ProjectComponentModifierType.DUMMY,\n            cut_angle1: (_a = raw[(0, utils_1.nameof)(\"cut_angle1\")]) !== null && _a !== void 0 ? _a : 0,\n            cut_angle2: (_b = raw[(0, utils_1.nameof)(\"cut_angle2\")]) !== null && _b !== void 0 ? _b : 0,\n            target_faces: (_c = raw[(0, utils_1.nameof)(\"target_faces\")]) !== null && _c !== void 0 ? _c : [],\n        };\n    }\n}\nexports.ProjectComponentSimpleModifierFactory = ProjectComponentSimpleModifierFactory;\nclass ProjectComponentDummyModifierFactory {\n    static Create(raw) {\n        return Object.assign(Object.assign({}, ProjectComponentSimpleModifierFactory.Create(raw)), { type: enums_1.ProjectComponentModifierType.DUMMY });\n    }\n}\nexports.ProjectComponentDummyModifierFactory = ProjectComponentDummyModifierFactory;\n","\"use strict\";\n// LDSP \nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectComponentLDSPModifierFactory = exports.LDSPEdgeFactory = void 0;\nconst utils_1 = require(\"../../utils\");\nconst enums_1 = require(\"../../enums\");\nconst math_1 = require(\"../../../math\");\nclass LDSPEdgeFactory {\n    static Create(raw) {\n        var _a, _b;\n        return {\n            type: ((_a = raw[(0, utils_1.nameof)(\"type\")]) !== null && _a !== void 0 ? _a : enums_1.LDSPEdgeType.NONE),\n            material: (_b = raw[(0, utils_1.nameof)(\"material\")]) !== null && _b !== void 0 ? _b : \"\",\n            size: raw[(0, utils_1.nameof)(\"size\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"size\")]) : new math_1.Vector3(0, 0, 0),\n        };\n    }\n}\nexports.LDSPEdgeFactory = LDSPEdgeFactory;\nclass ProjectComponentLDSPModifierFactory {\n    static Create(raw) {\n        var _a, _b, _c;\n        return {\n            type: enums_1.ProjectComponentModifierType.LDSP,\n            cut_angle1: (_a = raw[(0, utils_1.nameof)(\"cut_angle1\")]) !== null && _a !== void 0 ? _a : 0,\n            cut_angle2: (_b = raw[(0, utils_1.nameof)(\"cut_angle2\")]) !== null && _b !== void 0 ? _b : 0,\n            back_material: (_c = raw[(0, utils_1.nameof)(\"back_material\")]) !== null && _c !== void 0 ? _c : \"\",\n            edges: (raw[(0, utils_1.nameof)(\"edges\")] || []).map((edge) => LDSPEdgeFactory.Create(edge)),\n            real_size: raw[(0, utils_1.nameof)(\"real_size\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"real_size\")]) : new math_1.Vector3(0, 0, 0),\n        };\n    }\n}\nexports.ProjectComponentLDSPModifierFactory = ProjectComponentLDSPModifierFactory;\n","\"use strict\";\n// Mesh \nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectComponentMeshModifierFactory = void 0;\nconst utils_1 = require(\"../../utils\");\nconst enums_1 = require(\"../../enums\");\nconst math_1 = require(\"../../../math\");\nclass ProjectComponentMeshModifierFactory {\n    static Create(raw) {\n        var _a, _b, _c, _d;\n        return {\n            type: enums_1.ProjectComponentModifierType.MESH,\n            mesh: (_a = raw[(0, utils_1.nameof)(\"mesh\")]) !== null && _a !== void 0 ? _a : \"\",\n            node_name: (_b = raw[(0, utils_1.nameof)(\"node_name\")]) !== null && _b !== void 0 ? _b : \"\",\n            use_scale: (_c = raw[(0, utils_1.nameof)(\"use_scale\")]) !== null && _c !== void 0 ? _c : true,\n            apply_offset: (_d = raw[(0, utils_1.nameof)(\"apply_offset\")]) !== null && _d !== void 0 ? _d : true,\n            mesh_size: raw[(0, utils_1.nameof)(\"mesh_size\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"mesh_size\")]) : new math_1.Vector3(1, 1, 1),\n            mesh_offset: raw[(0, utils_1.nameof)(\"mesh_offset\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"mesh_offset\")]) : new math_1.Vector3(0, 0, 0),\n        };\n    }\n}\nexports.ProjectComponentMeshModifierFactory = ProjectComponentMeshModifierFactory;\n","\"use strict\";\n//   \nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectComponentGlassModifierFactory = exports.ProjectComponentSolidWoodModifierFactory = exports.ProjectComponentMDFWithFittingModifierFactory = exports.ProjectComponentMDFWithPaintModifierFactory = exports.ProjectComponentLightSourceModifierFactory = exports.ProjectComponentModelGroupModifierFactory = exports.ProjectComponentPanelModifierFactory = exports.ProjectComponentPerforationModifierFactory = void 0;\nconst shape_modifier_1 = require(\"./shape_modifier\");\nconst dummy_modifier_1 = require(\"./dummy_modifier\");\nconst utils_1 = require(\"../../utils\");\nconst enums_1 = require(\"../../enums\");\nclass ProjectComponentPerforationModifierFactory {\n    static Create(raw) {\n        var _a;\n        return {\n            type: enums_1.ProjectComponentModifierType.PERFORATION,\n            depth: (_a = raw[(0, utils_1.nameof)(\"depth\")]) !== null && _a !== void 0 ? _a : 0,\n        };\n    }\n}\nexports.ProjectComponentPerforationModifierFactory = ProjectComponentPerforationModifierFactory;\nclass ProjectComponentPanelModifierFactory {\n    static Create(raw) {\n        var _a, _b;\n        return {\n            type: enums_1.ProjectComponentModifierType.PANEL,\n            center_depth: (_a = raw[(0, utils_1.nameof)(\"center_depth\")]) !== null && _a !== void 0 ? _a : 0,\n            shape: (_b = raw[(0, utils_1.nameof)(\"shape\")]) !== null && _b !== void 0 ? _b : \"\",\n        };\n    }\n}\nexports.ProjectComponentPanelModifierFactory = ProjectComponentPanelModifierFactory;\nclass ProjectComponentModelGroupModifierFactory {\n    static Create(raw) {\n        var _a, _b, _c;\n        return {\n            type: enums_1.ProjectComponentModifierType.MODEL_GROUP,\n            file: (_a = raw[(0, utils_1.nameof)(\"file\")]) !== null && _a !== void 0 ? _a : \"\",\n            materials: (_b = raw[(0, utils_1.nameof)(\"materials\")]) !== null && _b !== void 0 ? _b : [],\n            nodes: (_c = raw[(0, utils_1.nameof)(\"nodes\")]) !== null && _c !== void 0 ? _c : [],\n        };\n    }\n}\nexports.ProjectComponentModelGroupModifierFactory = ProjectComponentModelGroupModifierFactory;\nclass ProjectComponentLightSourceModifierFactory {\n    static Create(raw) {\n        var _a, _b;\n        return {\n            type: enums_1.ProjectComponentModifierType.LIGHT_SOURCE,\n            cap_type: (_a = raw[(0, utils_1.nameof)(\"cap_type\")]) !== null && _a !== void 0 ? _a : \"\",\n            light: (_b = raw[(0, utils_1.nameof)(\"light\")]) !== null && _b !== void 0 ? _b : \"\",\n        };\n    }\n}\nexports.ProjectComponentLightSourceModifierFactory = ProjectComponentLightSourceModifierFactory;\nclass ProjectComponentMDFWithPaintModifierFactory {\n    static Create(raw) {\n        return Object.assign(Object.assign({}, shape_modifier_1.ProjectComponentShapedModifierFactory.Create(raw)), { type: enums_1.ProjectComponentModifierType.MDF_WITH_PAINT });\n    }\n}\nexports.ProjectComponentMDFWithPaintModifierFactory = ProjectComponentMDFWithPaintModifierFactory;\nclass ProjectComponentMDFWithFittingModifierFactory {\n    static Create(raw) {\n        return Object.assign(Object.assign({}, shape_modifier_1.ProjectComponentShapedModifierFactory.Create(raw)), { type: enums_1.ProjectComponentModifierType.MDF_WITH_FITTING });\n    }\n}\nexports.ProjectComponentMDFWithFittingModifierFactory = ProjectComponentMDFWithFittingModifierFactory;\nclass ProjectComponentSolidWoodModifierFactory {\n    static Create(raw) {\n        return Object.assign(Object.assign({}, shape_modifier_1.ProjectComponentShapedModifierFactory.Create(raw)), { type: enums_1.ProjectComponentModifierType.SOLID_WOOD });\n    }\n}\nexports.ProjectComponentSolidWoodModifierFactory = ProjectComponentSolidWoodModifierFactory;\nclass ProjectComponentGlassModifierFactory {\n    static Create(raw) {\n        return Object.assign(Object.assign({}, dummy_modifier_1.ProjectComponentSimpleModifierFactory.Create(raw)), { type: enums_1.ProjectComponentModifierType.GLASS });\n    }\n}\nexports.ProjectComponentGlassModifierFactory = ProjectComponentGlassModifierFactory;\n","\"use strict\";\n//    \nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextureFittingFactory = exports.BaseTextureCoordinateProcessingFactory = exports.ProcessingFactory = void 0;\nconst project_item_1 = require(\"../project_item\");\nconst utils_1 = require(\"../../utils\");\nconst enums_1 = require(\"../../enums\");\nconst math_1 = require(\"../../../math\");\nclass ProcessingFactory {\n    static Create(raw) {\n        const type = raw[(0, utils_1.nameof)(\"type\")];\n        switch (type) {\n            case enums_1.ProcessingType.BASE_TEXTURE_COORDINATE:\n                return BaseTextureCoordinateProcessingFactory.Create(raw);\n            case enums_1.ProcessingType.TEXTURE_FITTING:\n                return TextureFittingFactory.Create(raw);\n            default:\n                throw new Error(`Unknown processing type: ${type}`);\n        }\n    }\n}\nexports.ProcessingFactory = ProcessingFactory;\nclass BaseTextureCoordinateProcessingFactory {\n    static Create(raw) {\n        var _a;\n        return Object.assign(Object.assign({}, project_item_1.ProjectItemFactory.Create(raw)), { type: enums_1.ProcessingType.BASE_TEXTURE_COORDINATE, offset: raw[(0, utils_1.nameof)(\"offset\")] ? new math_1.Vector2(raw[(0, utils_1.nameof)(\"offset\")]) : new math_1.Vector2(0, 0), scale: raw[(0, utils_1.nameof)(\"scale\")] ? new math_1.Vector2(raw[(0, utils_1.nameof)(\"scale\")]) : new math_1.Vector2(1, 1), rotation: (_a = raw[(0, utils_1.nameof)(\"rotation\")]) !== null && _a !== void 0 ? _a : 0 });\n    }\n}\nexports.BaseTextureCoordinateProcessingFactory = BaseTextureCoordinateProcessingFactory;\nclass TextureFittingFactory {\n    static Create(raw) {\n        var _a;\n        return Object.assign(Object.assign({}, project_item_1.ProjectItemFactory.Create(raw)), { type: enums_1.ProcessingType.TEXTURE_FITTING, group: (_a = raw[(0, utils_1.nameof)(\"group\")]) !== null && _a !== void 0 ? _a : '' });\n    }\n}\nexports.TextureFittingFactory = TextureFittingFactory;\n","\"use strict\";\n//    \nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectComponentFactory = void 0;\nconst processing_1 = require(\"./processing\");\nconst component_modifier_1 = require(\"./component_modifier\");\nconst connectable_project_item_1 = require(\"../connectable_project_item\");\nconst utils_1 = require(\"../../utils\");\nconst math_1 = require(\"../../../math\");\nconst product_parts_1 = require(\"../../../Product/product_parts\");\nconst filesystem_1 = require(\"../../../filesystem\");\nconst iik_1 = require(\"../../../iik\");\nconst builtin_modifier_1 = require(\"./builtin_modifier\");\nclass ProjectComponentFactory {\n    static CreateNew() {\n        return Object.assign(Object.assign({}, connectable_project_item_1.ConnectableProjectItemFactory.CreateNew()), { position: new math_1.Vector3(0, 0, 0), rotation: new math_1.Quaternion(0, 0, 0, 1), size: new math_1.Vector3(1, 1, 1), material: \"\", color: \"#FFFFFF\", ignore_bounds: false, bake: \"\", modifier: component_modifier_1.ProjectComponentModifierFactory.CreateNew(), processings: [], is_active: true, max_texture_size: 2048, build_order: 0, detailing_order: 0, order: 0, user_data: '', component_type: \"component\", description: '', disassemble_multiplier: 1.0 });\n    }\n    static Create(raw) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n        return Object.assign(Object.assign({}, connectable_project_item_1.ConnectableProjectItemFactory.Create(raw)), { position: raw[(0, utils_1.nameof)(\"position\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"position\")]) : new math_1.Vector3(0, 0, 0), rotation: raw[(0, utils_1.nameof)(\"rotation\")] ? new math_1.Quaternion(raw[(0, utils_1.nameof)(\"rotation\")]) : new math_1.Quaternion(0, 0, 0, 1), size: raw[(0, utils_1.nameof)(\"size\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"size\")]) : new math_1.Vector3(1, 1, 1), material: (_a = raw[(0, utils_1.nameof)(\"material\")]) !== null && _a !== void 0 ? _a : \"\", color: (_b = raw[(0, utils_1.nameof)(\"color\")]) !== null && _b !== void 0 ? _b : \"\", ignore_bounds: (_c = raw[(0, utils_1.nameof)(\"ignore_bounds\")]) !== null && _c !== void 0 ? _c : false, bake: (_d = raw[(0, utils_1.nameof)(\"bake\")]) !== null && _d !== void 0 ? _d : \"\", modifier: component_modifier_1.ProjectComponentModifierFactory.Create(raw[(0, utils_1.nameof)(\"modifier\")]), processings: ((_e = raw[(0, utils_1.nameof)(\"processings\")]) !== null && _e !== void 0 ? _e : []).map((p) => processing_1.ProcessingFactory.Create(p)), is_active: (_f = raw[(0, utils_1.nameof)(\"is_active\")]) !== null && _f !== void 0 ? _f : true, max_texture_size: (_g = raw[(0, utils_1.nameof)(\"max_texture_size\")]) !== null && _g !== void 0 ? _g : 2048, build_order: (_h = raw[(0, utils_1.nameof)(\"build_order\")]) !== null && _h !== void 0 ? _h : 0, detailing_order: (_j = raw[(0, utils_1.nameof)(\"detailing_order\")]) !== null && _j !== void 0 ? _j : 0, order: (_k = raw[(0, utils_1.nameof)(\"order\")]) !== null && _k !== void 0 ? _k : 0, user_data: (_l = raw[(0, utils_1.nameof)(\"user_data\")]) !== null && _l !== void 0 ? _l : \"\", component_type: (_m = raw[(0, utils_1.nameof)(\"component_type\")]) !== null && _m !== void 0 ? _m : \"component\", description: (_o = raw[(0, utils_1.nameof)(\"description\")]) !== null && _o !== void 0 ? _o : \"\", disassemble_multiplier: (_p = raw[(0, utils_1.nameof)(\"disassemble_multiplier\")]) !== null && _p !== void 0 ? _p : 1.0 });\n    }\n    ;\n    static UpdateFromProductPart(component, productPart, inputs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d, _e;\n            if (productPart.type != product_parts_1.ProductPartType.Calculation) {\n                throw new Error(\"ProjectComponent can only be updated from ProductPartBase of type BuiltIn.\");\n            }\n            component.build_order = (_a = productPart.build_order) !== null && _a !== void 0 ? _a : 0;\n            component.order = (_b = productPart.order) !== null && _b !== void 0 ? _b : 0;\n            component.user_data = (_c = productPart.user_data) !== null && _c !== void 0 ? _c : \"\";\n            component.name = (_d = productPart.name) !== null && _d !== void 0 ? _d : productPart;\n            component.is_active = productPart.is_active;\n            const calculationPart = productPart;\n            const relatedProjectGuid = calculationPart.file.replace(\"s123calc://\", \"\");\n            const calculationStat = yield filesystem_1.Filesystem.Get(\"api/Calculation/GetCalculationStat?guid=\" + relatedProjectGuid);\n            const relatedProjectFilename = (_e = calculationStat === null || calculationStat === void 0 ? void 0 : calculationStat.filename) !== null && _e !== void 0 ? _e : \"\";\n            const relatedProjectData = yield filesystem_1.Filesystem.Get(`s123://calculationResults/${relatedProjectGuid}/${relatedProjectFilename}`);\n            const relatedCore = new iik_1.IIK.IIKCore(relatedProjectData);\n            relatedCore.has_frontend = false;\n            relatedCore.inputs = inputs !== null && inputs !== void 0 ? inputs : [];\n            yield relatedCore.Calculate();\n            const relatedProjectAssembler = relatedCore.projectAssembler;\n            component.position = productPart.transform.position.toRH().mult(1000.0);\n            component.rotation = productPart.transform.rotation.toRH();\n            component.size = relatedProjectAssembler.GetProjectBounds().size.mult(1000.0);\n            const modifier = builtin_modifier_1.ProjectComponentBuiltInModifierFactory.CreateNew();\n            modifier.related_project = calculationPart.file;\n            component.modifier = modifier;\n            return component;\n        });\n    }\n}\nexports.ProjectComponentFactory = ProjectComponentFactory;\n","\"use strict\";\n// Shape \nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectComponentShapeModifierFactory = exports.ProjectComponentShapedModifierFactory = void 0;\nconst utils_1 = require(\"../../utils\");\nconst enums_1 = require(\"../../enums\");\nclass ProjectComponentShapedModifierFactory {\n    static Create(raw) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        return {\n            type: enums_1.ProjectComponentModifierType.SHAPE,\n            cut_angle1: (_a = raw[(0, utils_1.nameof)(\"cut_angle1\")]) !== null && _a !== void 0 ? _a : 0,\n            cut_angle2: (_b = raw[(0, utils_1.nameof)(\"cut_angle2\")]) !== null && _b !== void 0 ? _b : 0,\n            radius: (_c = raw[(0, utils_1.nameof)(\"radius\")]) !== null && _c !== void 0 ? _c : 0,\n            start_angle: (_d = raw[(0, utils_1.nameof)(\"start_angle\")]) !== null && _d !== void 0 ? _d : 0,\n            end_angle: (_e = raw[(0, utils_1.nameof)(\"end_angle\")]) !== null && _e !== void 0 ? _e : 0,\n            precision: (_f = raw[(0, utils_1.nameof)(\"precision\")]) !== null && _f !== void 0 ? _f : 0,\n            width: (_g = raw[(0, utils_1.nameof)(\"width\")]) !== null && _g !== void 0 ? _g : 0,\n            depth: (_h = raw[(0, utils_1.nameof)(\"depth\")]) !== null && _h !== void 0 ? _h : 0,\n            is_mirrored: (_j = raw[(0, utils_1.nameof)(\"is_mirrored\")]) !== null && _j !== void 0 ? _j : false,\n            shape: (_k = raw[(0, utils_1.nameof)(\"shape\")]) !== null && _k !== void 0 ? _k : \"\",\n        };\n    }\n}\nexports.ProjectComponentShapedModifierFactory = ProjectComponentShapedModifierFactory;\nclass ProjectComponentShapeModifierFactory {\n    static Create(raw) {\n        return Object.assign(Object.assign({}, ProjectComponentShapedModifierFactory.Create(raw)), { type: enums_1.ProjectComponentModifierType.SHAPE });\n    }\n}\nexports.ProjectComponentShapeModifierFactory = ProjectComponentShapeModifierFactory;\n","\"use strict\";\n//   \nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CameraModifierFactory = exports.SequenceCameraSettingsFactory = exports.SequenceCameraConstraintsFactory = exports.TargetConstraintFactory = exports.ElevationConstraintFactory = exports.AzimuthConstraintFactory = exports.DistanceConstraintFactory = exports.CameraSettingsFactory = void 0;\nconst enums_1 = require(\"../../enums\");\nconst utils_1 = require(\"../../utils\");\nconst math_1 = require(\"../../../math\");\nclass CameraSettingsFactory {\n    static Create(raw) {\n        return {\n        //        \n        };\n    }\n}\nexports.CameraSettingsFactory = CameraSettingsFactory;\nclass DistanceConstraintFactory {\n    static Create(raw) {\n        var _a, _b, _c;\n        return {\n            is_active: (_a = raw[(0, utils_1.nameof)(\"is_active\")]) !== null && _a !== void 0 ? _a : false,\n            min: (_b = raw[(0, utils_1.nameof)(\"min\")]) !== null && _b !== void 0 ? _b : 0,\n            max: (_c = raw[(0, utils_1.nameof)(\"max\")]) !== null && _c !== void 0 ? _c : 0,\n        };\n    }\n}\nexports.DistanceConstraintFactory = DistanceConstraintFactory;\nclass AzimuthConstraintFactory {\n    static Create(raw) {\n        var _a, _b, _c;\n        return {\n            is_active: (_a = raw[(0, utils_1.nameof)(\"is_active\")]) !== null && _a !== void 0 ? _a : false,\n            left: (_b = raw[(0, utils_1.nameof)(\"left\")]) !== null && _b !== void 0 ? _b : 0,\n            right: (_c = raw[(0, utils_1.nameof)(\"right\")]) !== null && _c !== void 0 ? _c : 0,\n        };\n    }\n}\nexports.AzimuthConstraintFactory = AzimuthConstraintFactory;\nclass ElevationConstraintFactory {\n    static Create(raw) {\n        var _a, _b, _c;\n        return {\n            is_active: (_a = raw[(0, utils_1.nameof)(\"is_active\")]) !== null && _a !== void 0 ? _a : false,\n            down: (_b = raw[(0, utils_1.nameof)(\"down\")]) !== null && _b !== void 0 ? _b : 0,\n            up: (_c = raw[(0, utils_1.nameof)(\"up\")]) !== null && _c !== void 0 ? _c : 0,\n        };\n    }\n}\nexports.ElevationConstraintFactory = ElevationConstraintFactory;\nclass TargetConstraintFactory {\n    static Create(raw) {\n        var _a, _b, _c;\n        return {\n            is_active: (_a = raw[(0, utils_1.nameof)(\"is_active\")]) !== null && _a !== void 0 ? _a : false,\n            type: (_b = raw[(0, utils_1.nameof)(\"type\")]) !== null && _b !== void 0 ? _b : 'fixed',\n            radius: (_c = raw[(0, utils_1.nameof)(\"radius\")]) !== null && _c !== void 0 ? _c : 0,\n        };\n    }\n}\nexports.TargetConstraintFactory = TargetConstraintFactory;\nclass SequenceCameraConstraintsFactory {\n    static Create(raw) {\n        var _a, _b, _c, _d;\n        return {\n            distance: DistanceConstraintFactory.Create((_a = raw === null || raw === void 0 ? void 0 : raw[(0, utils_1.nameof)(\"distance\")]) !== null && _a !== void 0 ? _a : {}),\n            azimuth: AzimuthConstraintFactory.Create((_b = raw === null || raw === void 0 ? void 0 : raw[(0, utils_1.nameof)(\"azimuth\")]) !== null && _b !== void 0 ? _b : {}),\n            elevation: ElevationConstraintFactory.Create((_c = raw === null || raw === void 0 ? void 0 : raw[(0, utils_1.nameof)(\"elevation\")]) !== null && _c !== void 0 ? _c : {}),\n            target: TargetConstraintFactory.Create((_d = raw === null || raw === void 0 ? void 0 : raw[(0, utils_1.nameof)(\"target\")]) !== null && _d !== void 0 ? _d : {}),\n        };\n    }\n}\nexports.SequenceCameraConstraintsFactory = SequenceCameraConstraintsFactory;\nclass SequenceCameraSettingsFactory {\n    static Create(raw) {\n        var _a, _b, _c, _d;\n        return Object.assign(Object.assign({}, CameraSettingsFactory.Create(raw)), { height_offset: (_a = raw[(0, utils_1.nameof)(\"height_offset\")]) !== null && _a !== void 0 ? _a : 0, distance: (_b = raw[(0, utils_1.nameof)(\"distance\")]) !== null && _b !== void 0 ? _b : 0, auto_distance: (_c = raw[(0, utils_1.nameof)(\"auto_distance\")]) !== null && _c !== void 0 ? _c : false, frames_count: (_d = raw[(0, utils_1.nameof)(\"frames_count\")]) !== null && _d !== void 0 ? _d : 0, target: raw[(0, utils_1.nameof)(\"target\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"target\")]) : new math_1.Vector3(0, 0, 0), constraints: SequenceCameraConstraintsFactory.Create(raw[(0, utils_1.nameof)(\"constraints\")]) });\n    }\n}\nexports.SequenceCameraSettingsFactory = SequenceCameraSettingsFactory;\nclass CameraModifierFactory {\n    static Create(raw) {\n        var _a, _b, _c;\n        return {\n            rotation: raw[(0, utils_1.nameof)(\"rotation\")]\n                ? new math_1.Quaternion(raw[(0, utils_1.nameof)(\"rotation\")])\n                : new math_1.Quaternion(),\n            type: enums_1.VirtualObjectModifierType.CAMERA,\n            spheric_rotation: raw[(0, utils_1.nameof)(\"spheric_rotation\")] ? new math_1.Vector2(raw[(0, utils_1.nameof)(\"spheric_rotation\")]) : new math_1.Vector2(0, 0),\n            camera_type: raw[(0, utils_1.nameof)(\"camera_type\")],\n            order: (_a = raw[(0, utils_1.nameof)(\"order\")]) !== null && _a !== void 0 ? _a : 0,\n            is_pov: (_b = raw[(0, utils_1.nameof)(\"is_pov\")]) !== null && _b !== void 0 ? _b : false,\n            settings: raw[(0, utils_1.nameof)(\"settings\")]\n                ? SequenceCameraSettingsFactory.Create(raw[(0, utils_1.nameof)(\"settings\")])\n                : CameraSettingsFactory.Create({}),\n            need_detailing: (_c = raw[(0, utils_1.nameof)(\"need_detailing\")]) !== null && _c !== void 0 ? _c : false,\n        };\n    }\n}\nexports.CameraModifierFactory = CameraModifierFactory;\n","\"use strict\";\n//    \nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LightSourceModifierFactory = exports.AreaLightSourceSettingsFactory = exports.SpotLightSourceSettingsFactory = exports.PointLightSourceSettingsFactory = exports.DirectionalLightSourceSettingsFactory = exports.RotatableLightSourceSettingsFactory = exports.LightSourceSettingsFactory = void 0;\nconst enums_1 = require(\"../../enums\");\nconst utils_1 = require(\"../../utils\");\nconst math_1 = require(\"../../../math\");\nclass LightSourceSettingsFactory {\n    static Create(raw) {\n        var _a, _b, _c;\n        return {\n            color: (_a = raw[(0, utils_1.nameof)(\"color\")]) !== null && _a !== void 0 ? _a : \"\",\n            intensity: (_b = raw[(0, utils_1.nameof)(\"intensity\")]) !== null && _b !== void 0 ? _b : 1.0,\n            isOn: (_c = raw[(0, utils_1.nameof)(\"isOn\")]) !== null && _c !== void 0 ? _c : true,\n        };\n    }\n}\nexports.LightSourceSettingsFactory = LightSourceSettingsFactory;\nclass RotatableLightSourceSettingsFactory {\n    static Create(raw) {\n        return Object.assign(Object.assign({}, LightSourceSettingsFactory.Create(raw)), { rotation: raw[(0, utils_1.nameof)(\"rotation\")] ? new math_1.Quaternion(raw[(0, utils_1.nameof)(\"rotation\")]) : new math_1.Quaternion(0, 0, 0, 1) });\n    }\n}\nexports.RotatableLightSourceSettingsFactory = RotatableLightSourceSettingsFactory;\nclass DirectionalLightSourceSettingsFactory {\n    static Create(raw) {\n        return Object.assign({}, RotatableLightSourceSettingsFactory.Create(raw));\n    }\n}\nexports.DirectionalLightSourceSettingsFactory = DirectionalLightSourceSettingsFactory;\nclass PointLightSourceSettingsFactory {\n    static Create(raw) {\n        var _a;\n        return Object.assign(Object.assign({}, LightSourceSettingsFactory.Create(raw)), { range: (_a = raw[(0, utils_1.nameof)(\"range\")]) !== null && _a !== void 0 ? _a : 10.0 });\n    }\n}\nexports.PointLightSourceSettingsFactory = PointLightSourceSettingsFactory;\nclass SpotLightSourceSettingsFactory {\n    static Create(raw) {\n        var _a, _b;\n        return Object.assign(Object.assign({}, RotatableLightSourceSettingsFactory.Create(raw)), { range: (_a = raw[(0, utils_1.nameof)(\"range\")]) !== null && _a !== void 0 ? _a : 10.0, angle: (_b = raw[(0, utils_1.nameof)(\"angle\")]) !== null && _b !== void 0 ? _b : 45.0 });\n    }\n}\nexports.SpotLightSourceSettingsFactory = SpotLightSourceSettingsFactory;\nclass AreaLightSourceSettingsFactory {\n    static Create(raw) {\n        var _a, _b, _c, _d;\n        return Object.assign(Object.assign({}, RotatableLightSourceSettingsFactory.Create(raw)), { width: (_a = raw[(0, utils_1.nameof)(\"width\")]) !== null && _a !== void 0 ? _a : 1.0, height: (_b = raw[(0, utils_1.nameof)(\"height\")]) !== null && _b !== void 0 ? _b : 1.0, barnDoorAngle: (_c = raw[(0, utils_1.nameof)(\"barnDoorAngle\")]) !== null && _c !== void 0 ? _c : 0.0, barnDoorLength: (_d = raw[(0, utils_1.nameof)(\"barnDoorLength\")]) !== null && _d !== void 0 ? _d : 0.0 });\n    }\n}\nexports.AreaLightSourceSettingsFactory = AreaLightSourceSettingsFactory;\nclass LightSourceModifierFactory {\n    static Create(raw) {\n        var _a;\n        const lightType = raw[(0, utils_1.nameof)(\"light_type\")];\n        let settings;\n        switch (lightType) {\n            case enums_1.LightType.DIRECTIONAL:\n                settings = DirectionalLightSourceSettingsFactory.Create(raw[(0, utils_1.nameof)(\"settings\")]);\n                break;\n            case enums_1.LightType.POINT:\n                settings = PointLightSourceSettingsFactory.Create(raw[(0, utils_1.nameof)(\"settings\")]);\n                break;\n            case enums_1.LightType.SPOT:\n                settings = SpotLightSourceSettingsFactory.Create(raw[(0, utils_1.nameof)(\"settings\")]);\n                break;\n            case enums_1.LightType.AREA:\n                settings = AreaLightSourceSettingsFactory.Create(raw[(0, utils_1.nameof)(\"settings\")]);\n                break;\n            default:\n                throw new Error(`Unknown light type: ${lightType}`);\n        }\n        let rotation = raw[(0, utils_1.nameof)(\"rotation\")] ? new math_1.Quaternion(raw[(0, utils_1.nameof)(\"rotation\")]) : new math_1.Quaternion(0, 0, 0, 1);\n        return {\n            type: enums_1.VirtualObjectModifierType.LIGHT,\n            rotation,\n            light_type: lightType,\n            is_casting_shadows: (_a = raw[(0, utils_1.nameof)(\"is_casting_shadows\")]) !== null && _a !== void 0 ? _a : true,\n            settings,\n        };\n    }\n}\nexports.LightSourceModifierFactory = LightSourceModifierFactory;\n","\"use strict\";\n//  \nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VirtualManipulatorFactory = void 0;\nconst enums_1 = require(\"../../enums\");\nconst utils_1 = require(\"../../utils\");\nconst math_1 = require(\"../../../math\");\nclass VirtualManipulatorFactory {\n    static Create(raw) {\n        var _a, _b, _c, _d, _e;\n        return {\n            type: enums_1.VirtualObjectModifierType.MANIPULATOR,\n            rotation: raw[(0, utils_1.nameof)(\"rotation\")] ? new math_1.Quaternion(raw[(0, utils_1.nameof)(\"rotation\")]) : new math_1.Quaternion(0, 0, 0, 1),\n            radius: (_a = raw[(0, utils_1.nameof)(\"radius\")]) !== null && _a !== void 0 ? _a : 0.1,\n            visual_part: (_b = raw[(0, utils_1.nameof)(\"visual_part\")]) !== null && _b !== void 0 ? _b : \"\",\n            points_distance: (_c = raw[(0, utils_1.nameof)(\"points_distance\")]) !== null && _c !== void 0 ? _c : \"\",\n            press_sound: (_d = raw[(0, utils_1.nameof)(\"press_sound\")]) !== null && _d !== void 0 ? _d : \"\",\n            release_sound: (_e = raw[(0, utils_1.nameof)(\"release_sound\")]) !== null && _e !== void 0 ? _e : \"\",\n        };\n    }\n}\nexports.VirtualManipulatorFactory = VirtualManipulatorFactory;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PointsDistanceModifierFactory = void 0;\nconst enums_1 = require(\"../../enums\");\nconst utils_1 = require(\"../../utils\");\nconst math_1 = require(\"../../../math\");\nclass PointsDistanceModifierFactory {\n    static Create(raw) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        return {\n            type: enums_1.VirtualObjectModifierType.POINT_DISTANCE,\n            rotation: raw[(0, utils_1.nameof)(\"rotation\")] ? new math_1.Quaternion(raw[(0, utils_1.nameof)(\"rotation\")]) : new math_1.Quaternion(0, 0, 0, 1),\n            color: (_a = raw[(0, utils_1.nameof)(\"color\")]) !== null && _a !== void 0 ? _a : \"#FFFFFF\",\n            ledge_size: (_b = raw[(0, utils_1.nameof)(\"ledge_size\")]) !== null && _b !== void 0 ? _b : 0.1,\n            text_offset: (_c = raw[(0, utils_1.nameof)(\"text_offset\")]) !== null && _c !== void 0 ? _c : 0.1,\n            text_offset_axis: (_d = raw[(0, utils_1.nameof)(\"text_offset_axis\")]) !== null && _d !== void 0 ? _d : enums_1.PointsDistanceAxis.Top,\n            ledge_type: (_e = raw[(0, utils_1.nameof)(\"ledge_type\")]) !== null && _e !== void 0 ? _e : enums_1.PointsDistanceAxis.Top,\n            is_projection: (_f = raw[(0, utils_1.nameof)(\"is_projection\")]) !== null && _f !== void 0 ? _f : false,\n            point1: (_g = raw[(0, utils_1.nameof)(\"point1\")]) !== null && _g !== void 0 ? _g : \"\",\n            point2: (_h = raw[(0, utils_1.nameof)(\"point2\")]) !== null && _h !== void 0 ? _h : \"\",\n        };\n    }\n}\nexports.PointsDistanceModifierFactory = PointsDistanceModifierFactory;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ShadowPlaneModifierFactory = exports.CustomShadowPlaneSettingsFactory = exports.ShadowPlaneSettingsFactory = void 0;\nconst enums_1 = require(\"../../enums\");\nconst utils_1 = require(\"../../utils\");\nconst math_1 = require(\"../../../math\");\nclass ShadowPlaneSettingsFactory {\n    static Create(raw) {\n        return {\n        //        \n        };\n    }\n}\nexports.ShadowPlaneSettingsFactory = ShadowPlaneSettingsFactory;\nclass CustomShadowPlaneSettingsFactory {\n    static Create(raw) {\n        return Object.assign(Object.assign({}, ShadowPlaneSettingsFactory.Create(raw)), { path: raw[(0, utils_1.nameof)(\"path\")] || \"\" });\n    }\n}\nexports.CustomShadowPlaneSettingsFactory = CustomShadowPlaneSettingsFactory;\nclass ShadowPlaneModifierFactory {\n    static Create(raw) {\n        var _a;\n        let settings = raw[(0, utils_1.nameof)(\"settings\")];\n        return {\n            type: enums_1.VirtualObjectModifierType.SHADOW_PLANE,\n            rotation: raw[(0, utils_1.nameof)(\"rotation\")] ? new math_1.Quaternion(raw[(0, utils_1.nameof)(\"rotation\")]) : new math_1.Quaternion(0, 0, 0, 1),\n            size: raw[(0, utils_1.nameof)(\"size\")] ? new math_1.Vector2(raw[(0, utils_1.nameof)(\"size\")]) : new math_1.Vector2(1, 1),\n            shadow_type: (_a = raw[(0, utils_1.nameof)(\"shadow_type\")]) !== null && _a !== void 0 ? _a : enums_1.ShadowPlaneType.SQUARE,\n            settings: settings\n                ? CustomShadowPlaneSettingsFactory.Create(settings)\n                : ShadowPlaneSettingsFactory.Create({}),\n        };\n    }\n}\nexports.ShadowPlaneModifierFactory = ShadowPlaneModifierFactory;\n","\"use strict\";\n//    \nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VirtualObjectFactory = void 0;\nconst virtual_object_modifier_1 = require(\"./virtual_object_modifier\");\nconst connectable_project_item_1 = require(\"../connectable_project_item\");\nconst utils_1 = require(\"../../utils\");\nconst math_1 = require(\"../../../math\");\nclass VirtualObjectFactory {\n    static Create(raw) {\n        var _a;\n        return Object.assign(Object.assign({}, connectable_project_item_1.ConnectableProjectItemFactory.Create(raw)), { position: raw[(0, utils_1.nameof)(\"position\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"position\")]) : new math_1.Vector3(0, 0, 0), rotation: raw[(0, utils_1.nameof)(\"rotation\")] ? new math_1.Quaternion(raw[(0, utils_1.nameof)(\"rotation\")]) : new math_1.Quaternion(0, 0, 0, 1), modifier: virtual_object_modifier_1.VirtualObjectModifierFactory.Create(raw[(0, utils_1.nameof)(\"modifier\")]), is_active: (_a = raw[(0, utils_1.nameof)(\"is_active\")]) !== null && _a !== void 0 ? _a : true });\n    }\n}\nexports.VirtualObjectFactory = VirtualObjectFactory;\n","\"use strict\";\n//     \nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VirtualObjectModifierFactory = void 0;\nconst enums_1 = require(\"../../enums\");\nconst camera_modifier_1 = require(\"./camera_modifier\");\nconst light_modifier_1 = require(\"./light_modifier\");\nconst manipulator_modifier_1 = require(\"./manipulator_modifier\");\nconst points_distance_modifier_1 = require(\"./points_distance_modifier\");\nconst shadow_plane_modifier_1 = require(\"./shadow_plane_modifier\");\nclass VirtualObjectModifierFactory {\n    static Create(raw) {\n        switch (raw.type) {\n            case enums_1.VirtualObjectModifierType.CAMERA:\n                return camera_modifier_1.CameraModifierFactory.Create(raw);\n            case enums_1.VirtualObjectModifierType.LIGHT:\n                return light_modifier_1.LightSourceModifierFactory.Create(raw);\n            case enums_1.VirtualObjectModifierType.MANIPULATOR:\n                return manipulator_modifier_1.VirtualManipulatorFactory.Create(raw);\n            case enums_1.VirtualObjectModifierType.POINT_DISTANCE:\n                return points_distance_modifier_1.PointsDistanceModifierFactory.Create(raw);\n            case enums_1.VirtualObjectModifierType.SHADOW_PLANE:\n                return shadow_plane_modifier_1.ShadowPlaneModifierFactory.Create(raw);\n            default:\n                throw new Error(`Unknown virtual object modifier type: ${raw.type}`);\n        }\n    }\n}\nexports.VirtualObjectModifierFactory = VirtualObjectModifierFactory;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConnectableProjectItemFactory = void 0;\nconst project_item_1 = require(\"./project_item\");\nconst positioning_point_1 = require(\"./positioning_point\");\nconst utils_1 = require(\"../utils\");\nconst math_1 = require(\"../../math\");\nclass ConnectableProjectItemFactory {\n    static CreateNew() {\n        return Object.assign(Object.assign({}, project_item_1.ProjectItemFactory.CreateNew()), { positioning_points: [], position: new math_1.Vector3(0, 0, 0), rotation: new math_1.Quaternion(0, 0, 0, 1) });\n    }\n    static Create(raw) {\n        return Object.assign(Object.assign({}, project_item_1.ProjectItemFactory.Create(raw)), { positioning_points: (raw[(0, utils_1.nameof)(\"positioning_points\")] || []).map((p) => positioning_point_1.PositioningPointFactory.Create(p)), position: raw[(0, utils_1.nameof)(\"position\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"position\")]) : new math_1.Vector3(0, 0, 0), rotation: raw[(0, utils_1.nameof)(\"rotation\")] ? new math_1.Quaternion(raw[(0, utils_1.nameof)(\"rotation\")]) : new math_1.Quaternion(0, 0, 0, 1) });\n    }\n}\nexports.ConnectableProjectItemFactory = ConnectableProjectItemFactory;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConnectionPointFactory = void 0;\nconst project_item_1 = require(\"./project_item\");\nconst utils_1 = require(\"../utils\");\nclass ConnectionPointFactory {\n    static Create(raw) {\n        var _a, _b;\n        return Object.assign(Object.assign({}, project_item_1.ProjectItemFactory.Create(raw)), { point1: (_a = raw[(0, utils_1.nameof)(\"point1\")]) !== null && _a !== void 0 ? _a : \"\", point2: (_b = raw[(0, utils_1.nameof)(\"point2\")]) !== null && _b !== void 0 ? _b : \"\" });\n    }\n}\nexports.ConnectionPointFactory = ConnectionPointFactory;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PositioningPointFactory = void 0;\nconst project_item_1 = require(\"./project_item\");\nconst utils_1 = require(\"../utils\");\nconst math_1 = require(\"../../math\");\nclass PositioningPointFactory {\n    static Create(raw) {\n        var _a, _b, _c, _d;\n        return Object.assign(Object.assign({}, project_item_1.ProjectItemFactory.Create(raw)), { offset: raw[(0, utils_1.nameof)(\"offset\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"offset\")]) : new math_1.Vector3(), anchor_x: (_a = raw[(0, utils_1.nameof)(\"anchor_x\")]) !== null && _a !== void 0 ? _a : 0, anchor_y: (_b = raw[(0, utils_1.nameof)(\"anchor_y\")]) !== null && _b !== void 0 ? _b : 0, anchor_z: (_c = raw[(0, utils_1.nameof)(\"anchor_z\")]) !== null && _c !== void 0 ? _c : 0, getFromModifier: (_d = raw[(0, utils_1.nameof)(\"getFromModifier\")]) !== null && _d !== void 0 ? _d : false });\n    }\n}\nexports.PositioningPointFactory = PositioningPointFactory;\n","\"use strict\";\n//   \nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectFactory = void 0;\nconst project_component_1 = require(\"./ProjectComponent/project_component\");\nconst virtual_object_1 = require(\"./VirtualObject/virtual_object\");\nconst connection_point_1 = require(\"./connection_point\");\nconst environment_1 = require(\"../../Environment/environment\");\nconst enums_1 = require(\"../enums\");\nconst utils_1 = require(\"../utils\");\nconst graph_1 = require(\"../../graph\");\nconst math_1 = require(\"../../math\");\nconst product_parts_1 = require(\"../../Product/product_parts\");\nclass ProjectFactory {\n    static CreateNew() {\n        return {\n            guid: \"\",\n            components: [],\n            virtual_objects: [],\n            connection_points: [],\n            type: '',\n            background_color: '#FFFFFF',\n            anchor_x: enums_1.Anchor.Center,\n            anchor_y: enums_1.Anchor.Min,\n            anchor_z: enums_1.Anchor.Center,\n            offset: new math_1.Vector3(0, 0, 0),\n            normal: new math_1.Vector3(0, 0, 1),\n            user_data: '',\n            connection_type: \"floor\",\n            graph: new graph_1.Graph.Graph(),\n            world: environment_1.WorldSettingsFactory.CreateNew(),\n            points_distance_ledge_end_size: 0.1,\n            points_distance_lines_weight: 0.01,\n            points_distance_arrows_size: 0.05,\n            points_distance_text_size: 0.02,\n            points_distance_measurement_unit: enums_1.MeasurementUnit.Meters,\n            points_distance_color: '#000000',\n        };\n    }\n    static Create(raw) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n        return {\n            guid: (_a = raw[(0, utils_1.nameof)(\"guid\")]) !== null && _a !== void 0 ? _a : \"\",\n            components: ((_b = raw[(0, utils_1.nameof)(\"components\")]) !== null && _b !== void 0 ? _b : []).map((c) => project_component_1.ProjectComponentFactory.Create(c)),\n            virtual_objects: ((_c = raw[(0, utils_1.nameof)(\"virtual_objects\")]) !== null && _c !== void 0 ? _c : []).map((v) => virtual_object_1.VirtualObjectFactory.Create(v)),\n            connection_points: ((_d = raw[(0, utils_1.nameof)(\"connection_points\")]) !== null && _d !== void 0 ? _d : []).map((cp) => connection_point_1.ConnectionPointFactory.Create(cp)),\n            type: (_e = raw[(0, utils_1.nameof)(\"type\")]) !== null && _e !== void 0 ? _e : '',\n            background_color: (_f = raw[(0, utils_1.nameof)(\"background_color\")]) !== null && _f !== void 0 ? _f : '#FFFFFF',\n            anchor_x: (_g = raw[(0, utils_1.nameof)(\"anchor_x\")]) !== null && _g !== void 0 ? _g : 0,\n            anchor_y: (_h = raw[(0, utils_1.nameof)(\"anchor_y\")]) !== null && _h !== void 0 ? _h : 0,\n            anchor_z: (_j = raw[(0, utils_1.nameof)(\"anchor_z\")]) !== null && _j !== void 0 ? _j : 0,\n            offset: raw[(0, utils_1.nameof)(\"offset\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"offset\")]) : new math_1.Vector3(0, 0, 0),\n            normal: raw[(0, utils_1.nameof)(\"normal\")] ? new math_1.Vector3(raw[(0, utils_1.nameof)(\"normal\")]) : new math_1.Vector3(0, 0, 1),\n            user_data: (_k = raw[(0, utils_1.nameof)(\"user_data\")]) !== null && _k !== void 0 ? _k : '',\n            connection_type: (_l = raw[(0, utils_1.nameof)(\"connection_type\")]) !== null && _l !== void 0 ? _l : \"\",\n            graph: new graph_1.Graph.Graph(raw[(0, utils_1.nameof)(\"graph\")]), //TODO Graph DTO\n            world: environment_1.WorldSettingsFactory.Create((_m = raw[(0, utils_1.nameof)(\"world\")]) !== null && _m !== void 0 ? _m : {}),\n            points_distance_ledge_end_size: (_o = raw[(0, utils_1.nameof)(\"points_distance_ledge_end_size\")]) !== null && _o !== void 0 ? _o : 0.1,\n            points_distance_lines_weight: (_p = raw[(0, utils_1.nameof)(\"points_distance_lines_weight\")]) !== null && _p !== void 0 ? _p : 0.01,\n            points_distance_arrows_size: (_q = raw[(0, utils_1.nameof)(\"points_distance_arrows_size\")]) !== null && _q !== void 0 ? _q : 0.05,\n            points_distance_text_size: (_r = raw[(0, utils_1.nameof)(\"points_distance_text_size\")]) !== null && _r !== void 0 ? _r : 0.02,\n            points_distance_measurement_unit: ((_s = raw[(0, utils_1.nameof)(\"points_distance_measurement_unit\")]) !== null && _s !== void 0 ? _s : enums_1.MeasurementUnit.Millimeters),\n            points_distance_color: (_t = raw[(0, utils_1.nameof)(\"points_distance_color\")]) !== null && _t !== void 0 ? _t : '#000000',\n        };\n    }\n    static UpdateFromProduct(project, product, relatedInputs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (product.world != null)\n                project.world = environment_1.WorldSettingsFactory.Create(product.world);\n            else\n                project.world = environment_1.WorldSettingsFactory.CreateNew();\n            const relatedInputsResult = (_a = project.graph.related_inputs) !== null && _a !== void 0 ? _a : {};\n            const container = product.product_container;\n            for (const childGuid in container.children) {\n                const child = container.children[childGuid];\n                if (child.type != product_parts_1.ProductPartType.Calculation)\n                    continue;\n                let component = project.components.find(c => c.guid == childGuid);\n                const componentInputs = (_b = relatedInputs[childGuid]) !== null && _b !== void 0 ? _b : [];\n                if (component == null) {\n                    component = project_component_1.ProjectComponentFactory.CreateNew();\n                    component.guid = childGuid;\n                    project.components.push(component);\n                    relatedInputsResult[childGuid] = componentInputs;\n                }\n                yield project_component_1.ProjectComponentFactory.UpdateFromProductPart(component, child, relatedInputsResult[childGuid]);\n            }\n            return project;\n        });\n    }\n}\nexports.ProjectFactory = ProjectFactory;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectItemFactory = void 0;\nconst utils_1 = require(\"../utils\");\nconst utils_2 = require(\"../../utils\");\nclass ProjectItemFactory {\n    static CreateNew() {\n        return {\n            name: \"\",\n            path: \"\",\n            guid: (0, utils_2.CreateUUID)(),\n        };\n    }\n    static Create(raw) {\n        return {\n            name: raw[(0, utils_1.nameof)(\"name\")],\n            path: raw[(0, utils_1.nameof)(\"path\")],\n            guid: raw[(0, utils_1.nameof)(\"guid\")],\n        };\n    }\n}\nexports.ProjectItemFactory = ProjectItemFactory;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConnectableProjectItemImplementation = void 0;\nconst project_item_implementation_1 = require(\"./project_item_implementation\");\nclass ConnectableProjectItemImplementation extends project_item_implementation_1.ProjectItemImplementation {\n    constructor() {\n        super(...arguments);\n        this.children = new Set();\n    }\n    TranslateWithChildren(dv, processed) {\n        if (processed != null && processed.includes(this))\n            return;\n        if (processed == null)\n            processed = [];\n        this.data.position = this.data.position.add(dv);\n        processed.push(this);\n        for (const child of this.children)\n            child.TranslateWithChildren(dv, processed);\n    }\n}\nexports.ConnectableProjectItemImplementation = ConnectableProjectItemImplementation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PositioningPointImplementation = void 0;\nconst project_item_implementation_1 = require(\"./project_item_implementation\");\nconst filesystem_1 = require(\"../../filesystem\");\nvar Hashable = filesystem_1.Filesystem.Hashable;\nclass PositioningPointImplementation extends project_item_implementation_1.ProjectItemImplementation {\n    constructor(connectableImplementation, data) {\n        super(data);\n        this.fullPath = `${connectableImplementation.fullPath}/${data.path}/${data.name}`;\n        this.fullPathHash = Hashable.GetHashCode(this.fullPath);\n    }\n}\nexports.PositioningPointImplementation = PositioningPointImplementation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectAssembler = void 0;\nconst connectable_project_item_implementation_1 = require(\"./connectable_project_item_implementation\");\nconst project_component_implementation_1 = require(\"./project_component_implementation\");\nconst positioning_point_implementation_1 = require(\"./positioning_point_implementation\");\nconst enums_1 = require(\"../enums\");\nconst filesystem_1 = require(\"../../filesystem\");\nconst math_1 = require(\"../../math\");\nvar Hashable = filesystem_1.Filesystem.Hashable;\nclass ProjectAssembler {\n    constructor(core) {\n        var _a;\n        this.allPoints = [];\n        this.allPointsImplementation = [];\n        this.allComponentImplementations = [];\n        this.allVirtualObjectImplementations = [];\n        this.pathCachedComponents = new Map();\n        this.cachedPoints = new Map();\n        this.pathHashCachedPoints = new Map();\n        this.connectableCache = new Map();\n        this.sessionCache = new Map();\n        this.core = core;\n        this.targetProject = core.project;\n        this.allPoints = [\n            ...this.targetProject.components.flatMap(c => { var _a, _b; return (_b = (_a = c.positioning_points) === null || _a === void 0 ? void 0 : _a.map((p) => p)) !== null && _b !== void 0 ? _b : []; }),\n            ...(_a = this.targetProject.virtual_objects.flatMap(vo => { var _a, _b; return (_b = (_a = vo.positioning_points) === null || _a === void 0 ? void 0 : _a.map((p) => p)) !== null && _b !== void 0 ? _b : []; })) !== null && _a !== void 0 ? _a : []\n        ];\n        this.allComponentImplementations = this.targetProject.components.map(c => new project_component_implementation_1.ProjectComponentImplementation(this, c));\n        this.allVirtualObjectImplementations = this.targetProject.virtual_objects.map(vo => new connectable_project_item_implementation_1.ConnectableProjectItemImplementation(vo));\n        this.allPointsImplementation = [\n            ...this.allComponentImplementations.flatMap(c => c.data.positioning_points.map(p => new positioning_point_implementation_1.PositioningPointImplementation(c, p))),\n            ...this.allVirtualObjectImplementations.flatMap(vo => vo.data.positioning_points.map(p => new positioning_point_implementation_1.PositioningPointImplementation(vo, p)))\n        ];\n    }\n    static AnchorToNumber(anchor) {\n        switch (anchor) {\n            case enums_1.Anchor.Min:\n                return -0.5;\n            case enums_1.Anchor.Center:\n                return 0.0;\n            case enums_1.Anchor.Max:\n                return 0.5;\n            default:\n                throw new Error(`Unknown anchor type: ${anchor}`);\n        }\n    }\n    static AnchorToVector3(anchorable) {\n        return new math_1.Vector3(this.AnchorToNumber(anchorable.anchor_x), this.AnchorToNumber(anchorable.anchor_y), this.AnchorToNumber(anchorable.anchor_z));\n    }\n    GetCachedPoint(path) {\n        var _a, _b;\n        if (!this.cachedPoints.has(path)) {\n            const targetPoint = this.allPointsImplementation.find(p => p.fullPath === path);\n            this.cachedPoints.set(path, (_a = targetPoint === null || targetPoint === void 0 ? void 0 : targetPoint.data) !== null && _a !== void 0 ? _a : undefined);\n            return (_b = targetPoint === null || targetPoint === void 0 ? void 0 : targetPoint.data) !== null && _b !== void 0 ? _b : undefined;\n        }\n        return this.cachedPoints.get(path);\n    }\n    FindPointByPath(path) {\n        const hash = Hashable.GetHashCode(path);\n        if (!this.pathHashCachedPoints.has(hash)) {\n            const targetPoint = this.allPointsImplementation.find(p => p.fullPathHash === hash);\n            if (targetPoint) {\n                this.pathHashCachedPoints.set(hash, targetPoint.data);\n            }\n            else {\n                this.pathHashCachedPoints.set(hash, undefined);\n            }\n        }\n        return this.pathHashCachedPoints.get(hash);\n    }\n    FindComponentByPath(path) {\n        const hash = Hashable.GetHashCode(path);\n        if (!this.pathCachedComponents.has(hash)) {\n            const targetComponent = this.allComponentImplementations.find(c => c.fullPathHash === hash);\n            if (targetComponent) {\n                this.pathCachedComponents.set(hash, targetComponent.data);\n            }\n            else {\n                this.pathCachedComponents.set(hash, undefined);\n            }\n            return this.pathCachedComponents.get(hash);\n        }\n        return this.pathCachedComponents.get(hash);\n    }\n    GetSessionConnectableImplementation(connectable) {\n        if (!this.sessionCache.has(connectable)) {\n            const sessionConnectable = new connectable_project_item_implementation_1.ConnectableProjectItemImplementation(connectable);\n            this.sessionCache.set(connectable, sessionConnectable);\n            return sessionConnectable;\n        }\n        return this.sessionCache.get(connectable);\n    }\n    GetCachedConnectable(point) {\n        if (!this.connectableCache.has(point)) {\n            const targetConnectable = this.targetProject.components.find(c => c.positioning_points.some(p => p.guid === point.guid)) ||\n                this.targetProject.virtual_objects.find(vo => vo.positioning_points.some(p => p.guid === point.guid));\n            this.connectableCache.set(point, targetConnectable);\n            return targetConnectable;\n        }\n        return this.connectableCache.get(point);\n    }\n    GetConnectableSize(connectable) {\n        if (connectable.size != undefined) //IsComponent\n         {\n            return connectable.size;\n        }\n        else //IsVirtualObject\n         {\n            const vo = connectable;\n            if (vo.modifier.type != enums_1.VirtualObjectModifierType.SHADOW_PLANE)\n                return new math_1.Vector3();\n            const r = vo.modifier.size;\n            return new math_1.Vector3(r.x, r.y, 0);\n        }\n    }\n    GetComponentBounds(component) {\n        let position = component.position.div(1000.0);\n        const rotation = component.rotation;\n        if (component.modifier.type === enums_1.ProjectComponentModifierType.MESH) {\n            const modifier = component.modifier;\n            if (modifier.apply_offset) {\n                const s = component.size.div(1000.0);\n                const n = modifier.mesh_size;\n                const scale = s.div(n);\n                const offset = math_1.Vector3.scale(modifier.mesh_offset, scale);\n                position = position.add(rotation.rotate(offset));\n            }\n        }\n        else if (component.modifier.type === enums_1.ProjectComponentModifierType.BUILTIN) {\n            if (!this.targetProject.components.includes(component)) {\n                throw new Error(\"Component is not part of the project\");\n            }\n            const relatedCore = this.core.related_calculations[component.guid];\n            //if( relatedCore )\n            //    position = position.add( relatedCore.projectAssembler.GetProjectOffset() );\n        }\n        const size = rotation.rotate(component.size).abs().div(1000.0);\n        if (!position.isFinite() || !size.isFinite())\n            return undefined;\n        return math_1.Bounds.fromCenterAndSize(position, size);\n    }\n    GetPointPosition(point) {\n        const connectable = this.GetCachedConnectable(point);\n        if (connectable == null)\n            return undefined;\n        const anchor = ProjectAssembler.AnchorToVector3(point);\n        const orths = [\n            new math_1.Vector3(anchor.x > 0 ? -1 : 1, 0, 0),\n            new math_1.Vector3(0, anchor.y > 0 ? -1 : 1, 0),\n            new math_1.Vector3(0, 0, anchor.z > 0 ? -1 : 1),\n        ];\n        let ox = connectable.rotation.rotate(orths[0]);\n        let oy = connectable.rotation.rotate(orths[1]);\n        let oz = connectable.rotation.rotate(orths[2]);\n        const size = this.GetConnectableSize(connectable);\n        let position;\n        const component = connectable;\n        if (component.modifier.cut_angle1 != null && component.modifier.cut_angle2 != null) //TODO  \n         {\n            position = new project_component_implementation_1.ProjectComponentImplementation(this, component).GetPointByAnchor(anchor);\n        }\n        else {\n            position = math_1.Vector3.scale(anchor, size);\n        }\n        let connectablePosition = connectable.position;\n        const anyConnectable = connectable; //TODO\n        if (anyConnectable.modifier.type === enums_1.ProjectComponentModifierType.MESH) {\n            const modifier = anyConnectable.modifier;\n            if (modifier.apply_offset) {\n                const s = anyConnectable.size.div(1000.0);\n                const n = modifier.mesh_size;\n                const scale = s.div(n);\n                const offset = math_1.Vector3.scale(modifier.mesh_offset, scale).mult(1000.0);\n                connectablePosition = connectablePosition.add(connectable.rotation.rotate(offset));\n            }\n        }\n        position = connectablePosition.add(connectable.rotation.rotate(position));\n        ox = ox.mult(point.offset.x);\n        oy = oy.mult(point.offset.y);\n        oz = oz.mult(point.offset.z);\n        return position.add(ox).add(oy).add(oz);\n    }\n    ConnectByConnectionPoint(cp) {\n        if (cp.point1 == null || cp.point2 == null)\n            return;\n        const point1 = this.GetCachedPoint(cp.point1);\n        const point2 = this.GetCachedPoint(cp.point2);\n        if (point1 == null || point2 == null)\n            return;\n        const connectable1 = this.GetCachedConnectable(point1);\n        const connectable2 = this.GetCachedConnectable(point2);\n        if (connectable1 == null || connectable2 == null)\n            return;\n        const position1 = this.GetPointPosition(point1);\n        const position2 = this.GetPointPosition(point2);\n        if (position1 == null || position2 == null)\n            return;\n        const dv = position1.sub(position2);\n        const connectableImplementation1 = this.GetSessionConnectableImplementation(connectable1);\n        const connectableImplementation2 = this.GetSessionConnectableImplementation(connectable2);\n        connectableImplementation2.TranslateWithChildren(dv, null);\n        connectableImplementation1.children.add(connectableImplementation2);\n        connectableImplementation1.TranslateWithChildren(dv.inversed(), null);\n        connectableImplementation2.children.add(connectableImplementation1);\n    }\n    GetProjectBounds() {\n        if (this.targetProject.components.length === 0)\n            return math_1.Bounds.default();\n        const startComponent = this.targetProject.components.find(c => {\n            return c.is_active && (c.ignore_bounds == null || !c.ignore_bounds) && this.GetComponentBounds(c) != null;\n        });\n        if (startComponent == null)\n            return math_1.Bounds.default();\n        let result = this.GetComponentBounds(startComponent);\n        for (const component of this.targetProject.components) {\n            if (!component.is_active || (component.ignore_bounds != null && component.ignore_bounds))\n                continue;\n            const b = this.GetComponentBounds(component);\n            if (b == null)\n                continue;\n            result.encapsulate(b);\n        }\n        return result;\n    }\n    GetProjectOffset() {\n        return math_1.Vector3.scale(this.GetProjectBounds().size, ProjectAssembler.AnchorToVector3(this.targetProject));\n    }\n    Assemble(mustBeCentered) {\n        this.sessionCache.clear();\n        for (const connectionPoint of this.targetProject.connection_points.reverse())\n            this.ConnectByConnectionPoint(connectionPoint);\n        if (mustBeCentered)\n            this.ToCenter();\n    }\n    Disassemble() {\n        for (const component of this.targetProject.components) {\n            let multiplier = 1.0;\n            if (component.disassemble_multiplier != null)\n                multiplier = component.disassemble_multiplier;\n            component.position = component.position.add(component.position.mult(multiplier));\n        }\n    }\n    ToCenter() {\n        const center = this.GetProjectBounds().center.mult(1000.0);\n        for (const component of this.targetProject.components)\n            component.position = component.position.sub(center);\n        for (const virtualObject of this.targetProject.virtual_objects)\n            virtualObject.position = virtualObject.position.sub(center);\n    }\n}\nexports.ProjectAssembler = ProjectAssembler;\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectComponentImplementation = void 0;\nconst filesystem_1 = require(\"../../filesystem\");\nconst logger_1 = require(\"../../logger\");\nconst shape_1 = require(\"../../Product/shape\");\nconst enums_1 = require(\"../enums\");\nconst generator_1 = require(\"../../MeshUtils/generator\");\nconst unwrapper_1 = require(\"../../MeshUtils/unwrapper\");\nconst material_1 = require(\"../../material\");\nconst connectable_project_item_implementation_1 = require(\"./connectable_project_item_implementation\");\nvar PrimitiveMesh = generator_1.Generator.PrimitiveMesh;\nvar CurvedMesh = generator_1.Generator.CurvedMesh;\nvar ShapedMesh = generator_1.Generator.ShapedMesh;\nvar TriplanarUnwrapper = unwrapper_1.Unwrapper.TriplanarUnwrapper;\nvar DebugLevel = logger_1.Logger.DebugLevel;\nvar Material = material_1.MaterialCore.Material;\nvar Texture = material_1.MaterialCore.Texture;\nconst math_1 = require(\"../../math\");\nclass ProjectComponentImplementation extends connectable_project_item_implementation_1.ConnectableProjectItemImplementation {\n    constructor(projectAssembler, data) {\n        super(data);\n        this.projectAssembler = projectAssembler;\n    }\n    static IsShapedType(type) {\n        return [\n            enums_1.ProjectComponentModifierType.SHAPE,\n            enums_1.ProjectComponentModifierType.MDF_WITH_PAINT,\n            enums_1.ProjectComponentModifierType.MDF_WITH_FITTING,\n            enums_1.ProjectComponentModifierType.SOLID_WOOD,\n        ].includes(type);\n    }\n    GetShapedMesh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (!ProjectComponentImplementation.IsShapedType(this.data.modifier.type))\n                return null;\n            let mesh = null;\n            let modifier = this.data.modifier;\n            const cutAngle1 = (_a = modifier.cut_angle1) !== null && _a !== void 0 ? _a : 0;\n            const cutAngle2 = (_b = modifier.cut_angle2) !== null && _b !== void 0 ? _b : 0;\n            const shape = yield this.GetShape();\n            if (shape == null) {\n                mesh = new PrimitiveMesh(this.data.size.div(1000.0), cutAngle1, cutAngle2);\n            }\n            else {\n                if (modifier.radius != null && modifier.radius != 0) {\n                    mesh = new CurvedMesh(shape, modifier.radius / 1000.0, modifier.start_angle, modifier.end_angle, modifier.cut_angle1, modifier.cut_angle2, modifier.precision, true);\n                }\n                else {\n                    mesh = new ShapedMesh(this.data.size.div(1000.0), shape, cutAngle1, cutAngle2);\n                }\n            }\n            return mesh;\n        });\n    }\n    GetDummyMesh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            let dummyModifier = this.data.modifier;\n            const cutAngle1 = (_a = dummyModifier.cut_angle1) !== null && _a !== void 0 ? _a : 0;\n            const cutAngle2 = (_b = dummyModifier.cut_angle2) !== null && _b !== void 0 ? _b : 0;\n            const target_faces = dummyModifier.target_faces == null ? [] : dummyModifier.target_faces;\n            return new PrimitiveMesh(this.data.size.div(1000.0), cutAngle1, cutAngle2, target_faces);\n        });\n    }\n    GetMesh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger_1.Logger.Log(\"Generating mesh for: \" + this.data.name, logger_1.Logger.DebugLevel.INFO);\n            const meshModifier = this.data.modifier;\n            let mesh = null;\n            if (ProjectComponentImplementation.IsShapedType(this.data.modifier.type)) {\n                let shapedModifier = this.data.modifier;\n                if (shapedModifier.shape == null || shapedModifier.shape == \"\")\n                    mesh = yield this.GetDummyMesh();\n                else\n                    mesh = yield this.GetShapedMesh();\n            }\n            else {\n                mesh = yield this.GetDummyMesh();\n            }\n            if (mesh == null)\n                return \"\";\n            if (this.data.bake != null && this.data.bake != \"\") {\n                let fName = \"model.s123mdata\";\n                if (this.projectAssembler.targetProject.guid)\n                    fName = `s123://calculationResults/${this.projectAssembler.targetProject.guid}/${fName}`;\n                logger_1.Logger.Log(\"Applying additional model data from file: \" + fName, logger_1.Logger.DebugLevel.INFO);\n                const data = yield filesystem_1.Filesystem.GetFile(fName);\n                if (data != null)\n                    mesh.ApplyAdditionalData(data.meshes[this.data.guid]);\n            }\n            if (this.data.processings != null && this.data.processings.length > 0) {\n                const proc = this.data.processings.find(function (p) {\n                    return p.type == 2;\n                });\n                const fitting = this.data.processings.find(function (p) {\n                    return p.type == 3;\n                });\n                const unwrapper = new TriplanarUnwrapper(mesh, fitting, proc, this);\n                mesh.triplanarUnwrapper = unwrapper;\n            }\n            return filesystem_1.Filesystem.Cache.GetCachedItem(mesh).id;\n        });\n    }\n    GetShape() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const modifier = this.data.modifier;\n            if (modifier.shape == undefined)\n                return null;\n            let fname = filesystem_1.Filesystem.GetRelativePath(modifier.shape);\n            fname = fname.split(\".\").slice(0, -1).join(\".\") + \".s123drawing\";\n            if (this.projectAssembler.targetProject.guid)\n                fname = `s123://calculationResults/${this.projectAssembler.targetProject.guid}/${fname}`;\n            logger_1.Logger.Log(\"Target shape file: \" + fname, logger_1.Logger.DebugLevel.INFO);\n            let shape = yield filesystem_1.Filesystem.GetFile(fname);\n            if (shape != null) {\n                if (modifier.radius != null && modifier.radius != 0)\n                    shape = shape_1.Shape.GetShapeFromData(shape, modifier.width / 1000.0, modifier.depth / 1000.0, modifier.is_mirrored);\n                else\n                    shape = shape_1.Shape.GetShapeFromData(shape, this.data.size.x / 1000.0, this.data.size.z / 1000.0, modifier.is_mirrored);\n            }\n            return shape;\n        });\n    }\n    static GetMaterialData(material, projectGuid, isWebPBRExtrasActive, isWebARActive) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let materialContent = Material.DefaultMaterial;\n            logger_1.Logger.Log(\"Generating content for material: \" + material, DebugLevel.VERBOSE);\n            if (material == null || material == \"\")\n                return materialContent;\n            if (!material.startsWith(\"s123mat://\") &&\n                !material.endsWith(\".s123mat\")) {\n                if (material == \"0\")\n                    return materialContent;\n                const diffuse = new Texture();\n                if (projectGuid != null)\n                    diffuse.fileName = `calculationResults/${projectGuid}/${filesystem_1.Filesystem.GetRelativePath(material)}`;\n                else\n                    diffuse.fileName = filesystem_1.Filesystem.GetRelativePath(material);\n                diffuse.realSize = new math_1.Vector2(1, 1);\n                diffuse.resolution = new math_1.Vector2(2048, 2048);\n                materialContent.diffuse = diffuse;\n                return materialContent;\n            }\n            if (material.startsWith(\"s123mat\")) {\n                logger_1.Logger.Log(\"as system material\", DebugLevel.VERBOSE);\n                materialContent = yield Material.GetByDirectLink(material);\n            }\n            else if (material.startsWith(\"local://\")) {\n                const material_data = yield filesystem_1.Filesystem.GetFile(material);\n                if (material_data != null) {\n                    materialContent = Material.GetByData(material_data, \"\");\n                }\n                else\n                    logger_1.Logger.Log(\"Material data is empty\", DebugLevel.VERBOSE);\n            }\n            else {\n                logger_1.Logger.Log(\"as internal material\", DebugLevel.VERBOSE);\n                let filename = filesystem_1.Filesystem.GetRelativePath(material);\n                if (projectGuid != null && projectGuid != \"\")\n                    filename = `s123://calculationResults/${projectGuid}/${filename}`;\n                let resultMaterial = yield Material.GetByDirectLink(filename, projectGuid);\n                if (resultMaterial != null) {\n                    materialContent = resultMaterial;\n                }\n                else {\n                    logger_1.Logger.Log(\"Material data is empty\", DebugLevel.VERBOSE);\n                }\n            }\n            if (isWebARActive &&\n                typeof materialContent.webAr === \"string\" &&\n                materialContent.webAr.startsWith(\"s123mat://\")) {\n                logger_1.Logger.Log(\"Using web ar version instead of original\", DebugLevel.VERBOSE);\n                materialContent = yield Material.GetByDirectLink(materialContent.webAr);\n            }\n            else if (isWebPBRExtrasActive &&\n                typeof materialContent.webPbr === \"string\" &&\n                materialContent.webPbr.startsWith(\"s123mat://\")) {\n                logger_1.Logger.Log(\"Using web pbr version instead of original\", DebugLevel.VERBOSE);\n                materialContent = yield Material.GetByDirectLink(materialContent.webPbr);\n            }\n            logger_1.Logger.Log(\"Done content generation\", DebugLevel.VERBOSE);\n            return materialContent;\n        });\n    }\n    GetMaterialData(isWebPBRExtrasActive, isWebARActive) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield ProjectComponentImplementation.GetMaterialData(this.data.material, this.projectAssembler.targetProject.guid, isWebPBRExtrasActive, isWebARActive);\n        });\n    }\n    GetPointByAnchor(anchor) {\n        var _a, _b;\n        const cuttableModifier = this.data.modifier;\n        const cutAngle1 = (_a = cuttableModifier.cut_angle1) !== null && _a !== void 0 ? _a : 0;\n        const cutAngle2 = (_b = cuttableModifier.cut_angle2) !== null && _b !== void 0 ? _b : 0;\n        if (anchor.x < 0 || (cutAngle1 == 0 && cutAngle2 == 0))\n            return math_1.Vector3.scale(this.data.size, anchor);\n        const angleOffset1 = this.data.size.x * Math.tan(Math.PI - (cutAngle1 / 180.0) * Math.PI);\n        const angleOffset2 = this.data.size.x * Math.tan((cutAngle2 / 180.0) * Math.PI);\n        const topLeft = this.data.size.y / 2.0 + angleOffset2;\n        const topRight = this.data.size.y / 2.0;\n        const bottomLeft = -this.data.size.y / 2.0 + angleOffset1;\n        const bottomRight = -this.data.size.y / 2.0;\n        if (anchor.x == 0) {\n            const result = math_1.Vector3.scale(this.data.size, anchor);\n            const topMid = (topLeft + topRight) / 2.0;\n            const bottomMid = (bottomLeft + bottomRight) / 2.0;\n            result.y = bottomMid + (topMid - bottomMid) * (anchor.y + 0.5);\n            return result;\n        }\n        const result = math_1.Vector3.scale(this.data.size, anchor);\n        result.y = bottomLeft + (topLeft - bottomLeft) * (anchor.y + 0.5);\n        return result;\n    }\n}\nexports.ProjectComponentImplementation = ProjectComponentImplementation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectItemImplementation = void 0;\nconst filesystem_1 = require(\"../../filesystem\");\nconst { Hashable } = filesystem_1.Filesystem;\nclass ProjectItemImplementation {\n    constructor(data) {\n        this.data = data;\n        this.fullPath = `${data.path}/${data.name}`;\n        this.fullPathHash = Hashable.GetHashCode(this.fullPath);\n    }\n}\nexports.ProjectItemImplementation = ProjectItemImplementation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GraphInputEnumSettingsDisplayType = exports.JSBlockArgumentType = exports.GraphOutputType = exports.GraphInputType = exports.PointsDistanceAxis = exports.ShadowPlaneType = exports.LightType = exports.CameraType = exports.VirtualObjectModifierType = exports.MarginSide = exports.ShapeModifierShapeType = exports.LDSPEdgeType = exports.ProjectComponentModifierType = exports.ProcessingType = exports.Space = exports.Face = exports.Anchor = exports.MeasurementUnit = void 0;\n//     S123\nvar MeasurementUnit;\n(function (MeasurementUnit) {\n    MeasurementUnit[MeasurementUnit[\"Millimeters\"] = 0] = \"Millimeters\";\n    MeasurementUnit[MeasurementUnit[\"Centimeters\"] = 1] = \"Centimeters\";\n    MeasurementUnit[MeasurementUnit[\"Meters\"] = 2] = \"Meters\";\n})(MeasurementUnit || (exports.MeasurementUnit = MeasurementUnit = {}));\nvar Anchor;\n(function (Anchor) {\n    Anchor[Anchor[\"Min\"] = 1] = \"Min\";\n    Anchor[Anchor[\"Center\"] = 2] = \"Center\";\n    Anchor[Anchor[\"Max\"] = 3] = \"Max\";\n})(Anchor || (exports.Anchor = Anchor = {}));\nvar Face;\n(function (Face) {\n    Face[Face[\"NONE\"] = -1] = \"NONE\";\n    Face[Face[\"FRONT\"] = 0] = \"FRONT\";\n    Face[Face[\"TOP\"] = 1] = \"TOP\";\n    Face[Face[\"BACK\"] = 2] = \"BACK\";\n    Face[Face[\"BOTTOM\"] = 3] = \"BOTTOM\";\n    Face[Face[\"LEFT\"] = 4] = \"LEFT\";\n    Face[Face[\"RIGHT\"] = 5] = \"RIGHT\";\n    Face[Face[\"ANY\"] = 6] = \"ANY\";\n})(Face || (exports.Face = Face = {}));\nvar Space;\n(function (Space) {\n    Space[Space[\"Self\"] = 0] = \"Self\";\n    Space[Space[\"World\"] = 1] = \"World\";\n})(Space || (exports.Space = Space = {}));\nvar ProcessingType;\n(function (ProcessingType) {\n    ProcessingType[ProcessingType[\"WALL_HOLE\"] = 1] = \"WALL_HOLE\";\n    ProcessingType[ProcessingType[\"BASE_TEXTURE_COORDINATE\"] = 2] = \"BASE_TEXTURE_COORDINATE\";\n    ProcessingType[ProcessingType[\"TEXTURE_FITTING\"] = 3] = \"TEXTURE_FITTING\";\n})(ProcessingType || (exports.ProcessingType = ProcessingType = {}));\nvar ProjectComponentModifierType;\n(function (ProjectComponentModifierType) {\n    ProjectComponentModifierType[ProjectComponentModifierType[\"DUMMY\"] = 0] = \"DUMMY\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"SHAPE\"] = 1] = \"SHAPE\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"PERFORATION\"] = 2] = \"PERFORATION\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"MESH\"] = 3] = \"MESH\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"LIGHT_SOURCE\"] = 4] = \"LIGHT_SOURCE\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"BUILTIN\"] = 5] = \"BUILTIN\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"WALL\"] = 6] = \"WALL\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"FLOOR\"] = 7] = \"FLOOR\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"CEILING\"] = 8] = \"CEILING\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"LDSP\"] = 9] = \"LDSP\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"MDF_WITH_PAINT\"] = 10] = \"MDF_WITH_PAINT\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"MDF_WITH_FITTING\"] = 11] = \"MDF_WITH_FITTING\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"SOLID_WOOD\"] = 12] = \"SOLID_WOOD\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"GLASS\"] = 13] = \"GLASS\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"ARRAY\"] = 14] = \"ARRAY\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"PANEL\"] = 15] = \"PANEL\";\n    ProjectComponentModifierType[ProjectComponentModifierType[\"MODEL_GROUP\"] = 16] = \"MODEL_GROUP\";\n})(ProjectComponentModifierType || (exports.ProjectComponentModifierType = ProjectComponentModifierType = {}));\nvar LDSPEdgeType;\n(function (LDSPEdgeType) {\n    LDSPEdgeType[LDSPEdgeType[\"NONE\"] = 0] = \"NONE\";\n    LDSPEdgeType[LDSPEdgeType[\"MM04\"] = 1] = \"MM04\";\n    LDSPEdgeType[LDSPEdgeType[\"MM2\"] = 2] = \"MM2\";\n})(LDSPEdgeType || (exports.LDSPEdgeType = LDSPEdgeType = {}));\nvar ShapeModifierShapeType;\n(function (ShapeModifierShapeType) {\n    ShapeModifierShapeType[ShapeModifierShapeType[\"NONE\"] = 0] = \"NONE\";\n    ShapeModifierShapeType[ShapeModifierShapeType[\"SHAPE\"] = 1] = \"SHAPE\";\n    ShapeModifierShapeType[ShapeModifierShapeType[\"DRAWING\"] = 2] = \"DRAWING\";\n})(ShapeModifierShapeType || (exports.ShapeModifierShapeType = ShapeModifierShapeType = {}));\nvar MarginSide;\n(function (MarginSide) {\n    MarginSide[MarginSide[\"LEFT\"] = 1] = \"LEFT\";\n    MarginSide[MarginSide[\"RIGHT\"] = 2] = \"RIGHT\";\n    MarginSide[MarginSide[\"UP\"] = 3] = \"UP\";\n    MarginSide[MarginSide[\"DOWN\"] = 4] = \"DOWN\";\n})(MarginSide || (exports.MarginSide = MarginSide = {}));\nvar VirtualObjectModifierType;\n(function (VirtualObjectModifierType) {\n    VirtualObjectModifierType[VirtualObjectModifierType[\"SHADOW_PLANE\"] = 1] = \"SHADOW_PLANE\";\n    VirtualObjectModifierType[VirtualObjectModifierType[\"LIGHT\"] = 2] = \"LIGHT\";\n    VirtualObjectModifierType[VirtualObjectModifierType[\"CAMERA\"] = 3] = \"CAMERA\";\n    VirtualObjectModifierType[VirtualObjectModifierType[\"MANIPULATOR\"] = 4] = \"MANIPULATOR\";\n    VirtualObjectModifierType[VirtualObjectModifierType[\"POINT_DISTANCE\"] = 5] = \"POINT_DISTANCE\";\n})(VirtualObjectModifierType || (exports.VirtualObjectModifierType = VirtualObjectModifierType = {}));\nvar CameraType;\n(function (CameraType) {\n    CameraType[CameraType[\"STATIC\"] = 0] = \"STATIC\";\n    CameraType[CameraType[\"SPHERE\"] = 1] = \"SPHERE\";\n    CameraType[CameraType[\"SEQUENCE\"] = 2] = \"SEQUENCE\";\n})(CameraType || (exports.CameraType = CameraType = {}));\nvar LightType;\n(function (LightType) {\n    LightType[LightType[\"DIRECTIONAL\"] = 0] = \"DIRECTIONAL\";\n    LightType[LightType[\"POINT\"] = 1] = \"POINT\";\n    LightType[LightType[\"SPOT\"] = 2] = \"SPOT\";\n    LightType[LightType[\"AREA\"] = 3] = \"AREA\";\n})(LightType || (exports.LightType = LightType = {}));\nvar ShadowPlaneType;\n(function (ShadowPlaneType) {\n    ShadowPlaneType[ShadowPlaneType[\"CUSTOM\"] = 0] = \"CUSTOM\";\n    ShadowPlaneType[ShadowPlaneType[\"SQUARE\"] = 1] = \"SQUARE\";\n    ShadowPlaneType[ShadowPlaneType[\"ROUND\"] = 2] = \"ROUND\";\n})(ShadowPlaneType || (exports.ShadowPlaneType = ShadowPlaneType = {}));\nvar PointsDistanceAxis;\n(function (PointsDistanceAxis) {\n    PointsDistanceAxis[PointsDistanceAxis[\"Top\"] = 0] = \"Top\";\n    PointsDistanceAxis[PointsDistanceAxis[\"Bottom\"] = 1] = \"Bottom\";\n    PointsDistanceAxis[PointsDistanceAxis[\"Left\"] = 2] = \"Left\";\n    PointsDistanceAxis[PointsDistanceAxis[\"Right\"] = 3] = \"Right\";\n    PointsDistanceAxis[PointsDistanceAxis[\"Forward\"] = 4] = \"Forward\";\n    PointsDistanceAxis[PointsDistanceAxis[\"Back\"] = 5] = \"Back\";\n})(PointsDistanceAxis || (exports.PointsDistanceAxis = PointsDistanceAxis = {}));\nvar GraphInputType;\n(function (GraphInputType) {\n    GraphInputType[GraphInputType[\"FLOAT\"] = 1] = \"FLOAT\";\n    GraphInputType[GraphInputType[\"STRING\"] = 2] = \"STRING\";\n    GraphInputType[GraphInputType[\"INT\"] = 3] = \"INT\";\n    GraphInputType[GraphInputType[\"FILES\"] = 4] = \"FILES\";\n    GraphInputType[GraphInputType[\"ENUM\"] = 5] = \"ENUM\";\n    GraphInputType[GraphInputType[\"FILES_TAG\"] = 6] = \"FILES_TAG\";\n    GraphInputType[GraphInputType[\"CATALOG\"] = 7] = \"CATALOG\";\n})(GraphInputType || (exports.GraphInputType = GraphInputType = {}));\nvar GraphOutputType;\n(function (GraphOutputType) {\n    GraphOutputType[GraphOutputType[\"NONE\"] = 0] = \"NONE\";\n    GraphOutputType[GraphOutputType[\"PRICE\"] = 1] = \"PRICE\";\n    GraphOutputType[GraphOutputType[\"SHORT_DESCRIPTION\"] = 2] = \"SHORT_DESCRIPTION\";\n    GraphOutputType[GraphOutputType[\"DESCRIPTION\"] = 3] = \"DESCRIPTION\";\n    GraphOutputType[GraphOutputType[\"DATE\"] = 4] = \"DATE\";\n    GraphOutputType[GraphOutputType[\"WEIGHT\"] = 5] = \"WEIGHT\";\n    GraphOutputType[GraphOutputType[\"ARTICLE\"] = 6] = \"ARTICLE\";\n})(GraphOutputType || (exports.GraphOutputType = GraphOutputType = {}));\nvar JSBlockArgumentType;\n(function (JSBlockArgumentType) {\n    JSBlockArgumentType[JSBlockArgumentType[\"NONE\"] = 0] = \"NONE\";\n    JSBlockArgumentType[JSBlockArgumentType[\"ANY\"] = 1] = \"ANY\";\n    JSBlockArgumentType[JSBlockArgumentType[\"NODE\"] = 2] = \"NODE\";\n    JSBlockArgumentType[JSBlockArgumentType[\"STRING\"] = 3] = \"STRING\";\n    JSBlockArgumentType[JSBlockArgumentType[\"INT\"] = 4] = \"INT\";\n    JSBlockArgumentType[JSBlockArgumentType[\"FLOAT\"] = 5] = \"FLOAT\";\n    JSBlockArgumentType[JSBlockArgumentType[\"COMPONENT\"] = 6] = \"COMPONENT\";\n    JSBlockArgumentType[JSBlockArgumentType[\"POSITIONING_POINT\"] = 7] = \"POSITIONING_POINT\";\n    JSBlockArgumentType[JSBlockArgumentType[\"CONNECTION_POINT\"] = 8] = \"CONNECTION_POINT\";\n    JSBlockArgumentType[JSBlockArgumentType[\"PROCESSING\"] = 10] = \"PROCESSING\";\n    JSBlockArgumentType[JSBlockArgumentType[\"TEXTURE_FITTING\"] = 11] = \"TEXTURE_FITTING\";\n    JSBlockArgumentType[JSBlockArgumentType[\"COMPONENT_FIELD\"] = 12] = \"COMPONENT_FIELD\";\n    JSBlockArgumentType[JSBlockArgumentType[\"POSITIONING_POINT_FIELD\"] = 13] = \"POSITIONING_POINT_FIELD\";\n    JSBlockArgumentType[JSBlockArgumentType[\"CONNECTION_POINT_FIELD\"] = 14] = \"CONNECTION_POINT_FIELD\";\n    JSBlockArgumentType[JSBlockArgumentType[\"PROCESSING_FIELD\"] = 16] = \"PROCESSING_FIELD\";\n    JSBlockArgumentType[JSBlockArgumentType[\"TEXTURE_FITTING_FIELD\"] = 17] = \"TEXTURE_FITTING_FIELD\";\n    JSBlockArgumentType[JSBlockArgumentType[\"DICTIONARY\"] = 18] = \"DICTIONARY\";\n    JSBlockArgumentType[JSBlockArgumentType[\"SCRIPT\"] = 19] = \"SCRIPT\";\n    JSBlockArgumentType[JSBlockArgumentType[\"INPUT\"] = 20] = \"INPUT\";\n    JSBlockArgumentType[JSBlockArgumentType[\"OUTPUT\"] = 21] = \"OUTPUT\";\n    JSBlockArgumentType[JSBlockArgumentType[\"FACE\"] = 22] = \"FACE\";\n    JSBlockArgumentType[JSBlockArgumentType[\"MARGIN_SIDE\"] = 23] = \"MARGIN_SIDE\";\n    JSBlockArgumentType[JSBlockArgumentType[\"LDSP_EDGE_TYPE\"] = 24] = \"LDSP_EDGE_TYPE\";\n})(JSBlockArgumentType || (exports.JSBlockArgumentType = JSBlockArgumentType = {}));\nvar GraphInputEnumSettingsDisplayType;\n(function (GraphInputEnumSettingsDisplayType) {\n    GraphInputEnumSettingsDisplayType[GraphInputEnumSettingsDisplayType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    GraphInputEnumSettingsDisplayType[GraphInputEnumSettingsDisplayType[\"SLIDER\"] = 1] = \"SLIDER\";\n})(GraphInputEnumSettingsDisplayType || (exports.GraphInputEnumSettingsDisplayType = GraphInputEnumSettingsDisplayType = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.nameof = nameof;\nfunction nameof(key) {\n    return key;\n}\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Filesystem = void 0;\nconst logger_1 = require(\"./logger\");\nconst changeable_1 = require(\"./Core/changeable\");\nconst utils_1 = require(\"./utils\");\nconst DebugLevel = logger_1.Logger.DebugLevel;\nvar Filesystem;\n(function (Filesystem) {\n    class Hashable extends changeable_1.Changeable {\n        constructor() {\n            super(...arguments);\n            this.hash = 0;\n            this.isDirty = true;\n        }\n        static GetHashCode(data) {\n            let result = 0;\n            for (let i = 0; i < data.length; i++) {\n                let chr = data.charCodeAt(i);\n                result = (result << 5) - result + chr;\n                result |= 0; // Convert to 32bit integer\n            }\n            return result;\n        }\n        GetHashCode() {\n            if (this.isDirty) {\n                let str = this.GetHashableData();\n                this.hash = Hashable.GetHashCode(str);\n                this.isDirty = false;\n            }\n            return this.hash;\n        }\n        MarkDirty() {\n            this.isDirty = true;\n        }\n    }\n    Filesystem.Hashable = Hashable;\n    class Cacheable extends Hashable {\n        constructor() {\n            super(...arguments);\n            this.isGenerated = false;\n        }\n        Generate() {\n            if (this.isGenerated)\n                return;\n            this.GenerateInternal();\n            this.isGenerated = true;\n        }\n    }\n    Filesystem.Cacheable = Cacheable;\n    class CacheItem {\n        constructor(id, data) {\n            this.id = id;\n            this.data = data;\n        }\n    }\n    Filesystem.CacheItem = CacheItem;\n    class Cache {\n        static AddRequestProcessing(request) {\n            return Cache.processing_request.push(request);\n        }\n        static HasRequestProcessing(request) {\n            return Cache.processing_request.includes(request);\n        }\n        static RemoveRequestProcessing(request) {\n            Cache.processing_request = Cache.processing_request.filter((r) => r != request);\n        }\n        static AddData(key, value) {\n            this.cachedData[key] = value;\n        }\n        static HasDataKey(key) {\n            return key in this.cachedData && this.cachedData[key] !== undefined;\n        }\n        static GetData(key) {\n            if (!this.HasDataKey(key))\n                return \"\";\n            return this.cachedData[key];\n        }\n        static GetItemById(id) {\n            let result = this.cachedItems.find((c) => c.id == id);\n            if (result == undefined)\n                return null;\n            if (!result.data.isGenerated)\n                result.data.Generate();\n            return result.data;\n        }\n        static GetCachedItem(item) {\n            let result = this.cachedItems.find((c) => c.data.GetHashCode() == item.GetHashCode());\n            if (result == undefined) {\n                item.Generate();\n                result = new CacheItem((0, utils_1.CreateUUID)(), item);\n                this.cachedItems.push(result);\n            }\n            return result;\n        }\n        static Clear() {\n            for (let k in this.cachedData)\n                delete this.cachedData[k];\n            this.cachedData = {};\n            for (let k in this.cachedItems)\n                delete this.cachedItems[k];\n            this.cachedItems = [];\n        }\n    }\n    Cache.cachedData = {};\n    Cache.processing_request = [];\n    Cache.cachedItems = [];\n    Filesystem.Cache = Cache;\n    Filesystem.GetRelativePath = function (p) {\n        if (p == null)\n            return \"\";\n        if (typeof p != \"string\")\n            return \"\";\n        return p.replace(\"file://\", \"\");\n    };\n    Filesystem.GetFileContentsAsync = null;\n    Filesystem.ApiGet = null;\n    Filesystem.ApiPost = null;\n    let requestPromises = {};\n    function Get(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestPromises[url] != null) {\n                return requestPromises[url];\n            }\n            if (Cache.HasDataKey(url)) {\n                return Cache.GetData(url);\n            }\n            requestPromises[url] = (() => __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling ApiGet with argument '\" + url + \"'\", logger_1.Logger.DebugLevel.VERBOSE);\n                if (Filesystem.ApiGet == null) {\n                    logger_1.Logger.Log(\"ApiGet not set\", DebugLevel.ERROR);\n                    delete requestPromises[url];\n                    return \"\";\n                }\n                let result = \"\";\n                if (Filesystem.ApiGet.ToPromise != undefined)\n                    result = yield Filesystem.ApiGet(url).ToPromise();\n                else\n                    result = yield Filesystem.ApiGet(url);\n                if (result == \"\") {\n                    logger_1.Logger.Log(\"No data received\", logger_1.Logger.DebugLevel.VERBOSE);\n                    result = null;\n                }\n                else {\n                    logger_1.Logger.Log(\"Received data length: \" + result.length, DebugLevel.VERBOSE);\n                    result = JSON.parse(result);\n                }\n                Cache.AddData(url, result);\n                delete requestPromises[url];\n                return result;\n            }))();\n            return requestPromises[url];\n        });\n    }\n    Filesystem.Get = Get;\n    function Post(url_1, data_1) {\n        return __awaiter(this, arguments, void 0, function* (url, data, headers = null) {\n            const key = url + \"?\" + data;\n            if (requestPromises[key] != null) {\n                return requestPromises[key];\n            }\n            if (Cache.HasDataKey(key)) {\n                return Cache.GetData(key);\n            }\n            requestPromises[key] = (() => __awaiter(this, void 0, void 0, function* () {\n                let result = \"\";\n                if (Filesystem.ApiPost == null) {\n                    logger_1.Logger.Log(\"ApiPost not set\", DebugLevel.ERROR);\n                    delete requestPromises[key];\n                    return \"\";\n                }\n                if (Filesystem.ApiPost.ToPromise != undefined)\n                    result = yield Filesystem.ApiPost(url, data, headers).ToPromise();\n                else\n                    result = yield Filesystem.ApiPost(url, data, headers);\n                Cache.AddData(key, result);\n                delete requestPromises[key];\n                return result;\n            }))();\n            return requestPromises[key];\n        });\n    }\n    Filesystem.Post = Post;\n    function GetFile(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestPromises[path] != null) {\n                return requestPromises[path];\n            }\n            if (Cache.HasDataKey(path)) {\n                return Cache.GetData(path);\n            }\n            requestPromises[path] = (() => __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log('Calling GetFileContents with argument \"' + path + '\"', logger_1.Logger.DebugLevel.VERBOSE);\n                if (Filesystem.GetFileContentsAsync == null) {\n                    logger_1.Logger.Log(\"GetFileContentsAsync not set\", DebugLevel.ERROR);\n                    delete requestPromises[path];\n                    return \"\";\n                }\n                let result = \"\";\n                if (Filesystem.GetFileContentsAsync.ToPromise != undefined)\n                    result = yield Filesystem.GetFileContentsAsync(path).ToPromise();\n                else {\n                    logger_1.Logger.Log(\"Just before get file contents call\", logger_1.Logger.DebugLevel.VERBOSE);\n                    result = yield Filesystem.GetFileContentsAsync(path);\n                    logger_1.Logger.Log(\"Just after get file contents call\", logger_1.Logger.DebugLevel.VERBOSE);\n                }\n                if (result == \"\") {\n                    logger_1.Logger.Log(\"No data received\", logger_1.Logger.DebugLevel.VERBOSE);\n                    result = null;\n                }\n                else {\n                    logger_1.Logger.Log(\"Received data length: \" + result.length, logger_1.Logger.DebugLevel.VERBOSE);\n                    result = JSON.parse(result);\n                }\n                Cache.AddData(path, result);\n                delete requestPromises[path];\n                return result;\n            }))();\n            return requestPromises[path];\n        });\n    }\n    Filesystem.GetFile = GetFile;\n})(Filesystem || (exports.Filesystem = Filesystem = {}));\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Graph = void 0;\nconst changeable_1 = require(\"./Core/changeable\");\nconst filesystem_1 = require(\"./filesystem\");\nconst logger_1 = require(\"./logger\");\nconst math_1 = require(\"./math\");\nconst utils_1 = require(\"./utils\");\nvar Graph;\n(function (Graph_1) {\n    let ArgumentType;\n    (function (ArgumentType) {\n        ArgumentType[ArgumentType[\"NONE\"] = 0] = \"NONE\";\n        ArgumentType[ArgumentType[\"ANY\"] = 1] = \"ANY\";\n        ArgumentType[ArgumentType[\"NODE\"] = 2] = \"NODE\";\n        ArgumentType[ArgumentType[\"STRING\"] = 3] = \"STRING\";\n        ArgumentType[ArgumentType[\"INT\"] = 4] = \"INT\";\n        ArgumentType[ArgumentType[\"FLOAT\"] = 5] = \"FLOAT\";\n        ArgumentType[ArgumentType[\"COMPONENT\"] = 6] = \"COMPONENT\";\n        ArgumentType[ArgumentType[\"POSITIONING_POINT\"] = 7] = \"POSITIONING_POINT\";\n        ArgumentType[ArgumentType[\"CONNECTION_POINT\"] = 8] = \"CONNECTION_POINT\";\n        ArgumentType[ArgumentType[\"PROCESSING\"] = 10] = \"PROCESSING\";\n        ArgumentType[ArgumentType[\"TEXTURE_FITTING\"] = 11] = \"TEXTURE_FITTING\";\n        ArgumentType[ArgumentType[\"COMPONENT_FIELD\"] = 12] = \"COMPONENT_FIELD\";\n        ArgumentType[ArgumentType[\"POSITIONING_POINT_FIELD\"] = 13] = \"POSITIONING_POINT_FIELD\";\n        ArgumentType[ArgumentType[\"CONNECTION_POINT_FIELD\"] = 14] = \"CONNECTION_POINT_FIELD\";\n        ArgumentType[ArgumentType[\"PROCESSING_FIELD\"] = 16] = \"PROCESSING_FIELD\";\n        ArgumentType[ArgumentType[\"TEXTURE_FITTING_FIELD\"] = 17] = \"TEXTURE_FITTING_FIELD\";\n        ArgumentType[ArgumentType[\"DICTIONARY\"] = 18] = \"DICTIONARY\";\n        ArgumentType[ArgumentType[\"SCRIPT\"] = 19] = \"SCRIPT\";\n        ArgumentType[ArgumentType[\"INPUT\"] = 20] = \"INPUT\";\n        ArgumentType[ArgumentType[\"OUTPUT\"] = 21] = \"OUTPUT\";\n        ArgumentType[ArgumentType[\"FACE\"] = 22] = \"FACE\";\n        ArgumentType[ArgumentType[\"MARGIN_SIDE\"] = 23] = \"MARGIN_SIDE\";\n        ArgumentType[ArgumentType[\"LDSP_EDGE_TYPE\"] = 24] = \"LDSP_EDGE_TYPE\";\n    })(ArgumentType = Graph_1.ArgumentType || (Graph_1.ArgumentType = {}));\n    class GraphNodeMethodArgumentNodeValue extends changeable_1.Changeable {\n        constructor(node_guid, pair_key) {\n            super();\n            this.node_guid = node_guid;\n            this.pair_key = pair_key;\n        }\n    }\n    class GraphNodeMethodArgumentKeyValuePair extends changeable_1.Changeable {\n        constructor(type, key, value) {\n            super();\n            this.type = type;\n            this.key = key;\n            this.value = value;\n        }\n    }\n    Graph_1.GraphNodeMethodArgumentKeyValuePair = GraphNodeMethodArgumentKeyValuePair;\n    class GraphNodeMethodArgument extends changeable_1.Changeable {\n        constructor(...args) {\n            super();\n            if (args.length == 1) {\n                this.name = args[0].name;\n                this.value = args[0].value;\n                this.type = args[0].type;\n                return;\n            }\n            this.name = args[0];\n            this.value = args[1];\n            this.type = args[2];\n        }\n        get IsLinked() {\n            return (this.type == ArgumentType.NODE ||\n                (this.type == ArgumentType.DICTIONARY &&\n                    this.value.some((pair) => pair.type == ArgumentType.NODE)));\n        }\n        GetLinks() {\n            if (!this.IsLinked)\n                return [];\n            if (this.type == ArgumentType.NODE)\n                return [this.value.node_guid];\n            return this.value\n                .filter((v) => v.type == ArgumentType.NODE)\n                .map((v) => v.value.node_guid);\n        }\n        HasValue(v) {\n            if (this.value == v)\n                return true;\n            if (this.type == ArgumentType.DICTIONARY)\n                return this.value.some((dict_val) => dict_val.value == v);\n            return false;\n        }\n    }\n    Graph_1.GraphNodeMethodArgument = GraphNodeMethodArgument;\n    class GraphNodeMethod extends changeable_1.Changeable {\n        constructor(...args) {\n            super();\n            if (args.length == 1) {\n                this.name = args[0].name;\n                this.arguments = args[0].arguments.map((a) => new GraphNodeMethodArgument(a));\n                this.result = new GraphNodeMethodArgument(args[0].result);\n                return;\n            }\n            this.name = args[0];\n            this.arguments = args[1];\n            this.result = args[2];\n        }\n        HasConnectionTo(node_guid) {\n            for (let a of this.arguments) {\n                if (a.type == ArgumentType.NODE && a.value.node_guid == node_guid)\n                    return true;\n                if (a.type == ArgumentType.DICTIONARY) {\n                    if (a.value == null)\n                        continue;\n                    if (a.value.find((v) => v.type == ArgumentType.NODE && v.value.node_guid == node_guid) != null)\n                        return true;\n                }\n            }\n            return false;\n        }\n    }\n    Graph_1.GraphNodeMethod = GraphNodeMethod;\n    class GraphNode extends changeable_1.Changeable {\n        constructor(...args) {\n            super();\n            if (args.length == 1) {\n                this.guid = args[0].guid;\n                this.name = args[0].name;\n                this.position = args[0].position;\n                this.method = new GraphNodeMethod(args[0].method);\n                this.order = args[0].order;\n                return;\n            }\n            this.guid = args[0];\n            this.name = args[1];\n            this.position = args[2];\n            this.order = 0;\n            this.method = new GraphNodeMethod(args[3]);\n        }\n    }\n    Graph_1.GraphNode = GraphNode;\n    let GraphInputType;\n    (function (GraphInputType) {\n        GraphInputType[GraphInputType[\"NONE\"] = 0] = \"NONE\";\n        GraphInputType[GraphInputType[\"FLOAT\"] = 1] = \"FLOAT\";\n        GraphInputType[GraphInputType[\"STRING\"] = 2] = \"STRING\";\n        GraphInputType[GraphInputType[\"INT\"] = 3] = \"INT\";\n        GraphInputType[GraphInputType[\"FILES\"] = 4] = \"FILES\";\n        GraphInputType[GraphInputType[\"ENUM\"] = 5] = \"ENUM\";\n        GraphInputType[GraphInputType[\"FILES_TAG\"] = 6] = \"FILES_TAG\";\n        GraphInputType[GraphInputType[\"CATALOG\"] = 7] = \"CATALOG\";\n    })(GraphInputType = Graph_1.GraphInputType || (Graph_1.GraphInputType = {}));\n    let GraphOutputType;\n    (function (GraphOutputType) {\n        GraphOutputType[GraphOutputType[\"NONE\"] = 0] = \"NONE\";\n        GraphOutputType[GraphOutputType[\"PRICE\"] = 1] = \"PRICE\";\n        GraphOutputType[GraphOutputType[\"SHORT_DESCRIPTION\"] = 2] = \"SHORT_DESCRIPTION\";\n        GraphOutputType[GraphOutputType[\"DESCRIPTION\"] = 3] = \"DESCRIPTION\";\n        GraphOutputType[GraphOutputType[\"DATE\"] = 4] = \"DATE\";\n        GraphOutputType[GraphOutputType[\"WEIGHT\"] = 5] = \"WEIGHT\";\n        GraphOutputType[GraphOutputType[\"ARTICLE\"] = 6] = \"ARTICLE\";\n    })(GraphOutputType = Graph_1.GraphOutputType || (Graph_1.GraphOutputType = {}));\n    class GraphInputSettings extends changeable_1.Changeable {\n        constructor(...args) {\n            super();\n            if (args.length == 1) {\n                this.tag = args[0].tag;\n                this.is_interactive = args[0].is_interactive;\n                this.event = args[0].event;\n                this.show_in_preview = args[0].show_in_preview;\n                this.show_in_consult = args[0].show_in_consult;\n                this.display_external = args[0].display_external;\n                return;\n            }\n            this.tag = args[0];\n            this.is_interactive = args[1];\n            this.event = args[2];\n            this.show_in_preview = false;\n            this.show_in_consult = true;\n            this.display_external = false;\n        }\n    }\n    class GraphInputStringSettings extends GraphInputSettings {\n    }\n    Graph_1.GraphInputStringSettings = GraphInputStringSettings;\n    class GraphInputFloatSettings extends GraphInputSettings {\n        constructor(...args) {\n            if (args.length == 1) {\n                super(args[0]);\n                this.min = args[0].min;\n                this.max = args[0].max;\n                this.minText = args[0].minText;\n                this.maxText = args[0].maxText;\n                this.manipulator_start = args[0].manipulator_start;\n                this.manipulator_end = args[0].manipulator_end;\n                this.manipulator_handle = args[0].manipulator_handle;\n                return;\n            }\n            super(args[0], args[1], args[2]);\n            this.min = args[3];\n            this.max = args[4];\n            this.minText = \"\";\n            this.maxText = \"\";\n            this.manipulator_start = \"\";\n            this.manipulator_end = \"\";\n            this.manipulator_handle = \"\";\n        }\n    }\n    Graph_1.GraphInputFloatSettings = GraphInputFloatSettings;\n    class GraphInputStringValue extends changeable_1.Changeable {\n        constructor(verbose, value) {\n            super();\n            this.verbose = verbose;\n            this.value = value;\n        }\n    }\n    Graph_1.GraphInputStringValue = GraphInputStringValue;\n    class GraphInputIntSettings extends GraphInputSettings {\n        constructor(...args) {\n            if (args.length == 1) {\n                super(args[0]);\n                this.min = args[0].min;\n                this.max = args[0].max;\n                return;\n            }\n            super(args[0], args[1], args[2]);\n            this.min = args[3];\n            this.max = args[4];\n        }\n    }\n    Graph_1.GraphInputIntSettings = GraphInputIntSettings;\n    class GraphInputFilesTagSettings extends GraphInputSettings {\n        constructor(...args) {\n            if (args.length == 1) {\n                super(args[0]);\n                this.search_tags = args[0].search_tags;\n                this.has_none = args[0].has_none;\n                this.manipulator_handle = args[0].manipulator_handle;\n                return;\n            }\n            super(args[0], args[1], args[2]);\n            this.search_tags = args[3];\n            this.has_none = true;\n            this.manipulator_handle = \"\";\n        }\n    }\n    Graph_1.GraphInputFilesTagSettings = GraphInputFilesTagSettings;\n    class GraphInputFileValue extends changeable_1.Changeable {\n        constructor(name, icon, value) {\n            super();\n            this.name = name;\n            this.icon = icon;\n            this.value = value;\n        }\n    }\n    Graph_1.GraphInputFileValue = GraphInputFileValue;\n    class GraphInputFilesSettings extends GraphInputSettings {\n        constructor(...args) {\n            if (args.length == 1) {\n                super(args[0]);\n                this.values = args[0].values;\n                this.has_none = args[0].has_none;\n                this.manipulator_handle = args[0].manipulator_handle;\n                return;\n            }\n            super(args[0], args[1], args[2]);\n            this.values = args[3];\n            this.has_none = true;\n            this.manipulator_handle = \"\";\n        }\n    }\n    Graph_1.GraphInputFilesSettings = GraphInputFilesSettings;\n    class GraphInputCatalogSettings extends GraphInputSettings {\n        constructor(...args) {\n            if (args.length == 1) {\n                super(args[0]);\n                this.values = args[0].values;\n                this.target = args[0].target;\n                this.has_none = args[0].has_none;\n                this.additional_values = [];\n                this.manipulator_handle = args[0].manipulator_handle;\n                return;\n            }\n            super(args[0], args[1], args[2]);\n            this.values = args[3];\n            this.target = args[4];\n            this.has_none = true;\n            this.additional_values = [];\n            this.manipulator_handle = \"\";\n        }\n    }\n    Graph_1.GraphInputCatalogSettings = GraphInputCatalogSettings;\n    let GraphInputEnumSettingsDisplayType;\n    (function (GraphInputEnumSettingsDisplayType) {\n        GraphInputEnumSettingsDisplayType[GraphInputEnumSettingsDisplayType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n        GraphInputEnumSettingsDisplayType[GraphInputEnumSettingsDisplayType[\"SLIDER\"] = 1] = \"SLIDER\";\n    })(GraphInputEnumSettingsDisplayType = Graph_1.GraphInputEnumSettingsDisplayType || (Graph_1.GraphInputEnumSettingsDisplayType = {}));\n    class GraphInputEnumSettings extends GraphInputSettings {\n        constructor(...args) {\n            if (args.length == 1) {\n                super(args[0]);\n                this.values = args[0].values;\n                this.display = args[0].display;\n                this.manipulator_handle_next = args[0].manipulator_handle_next;\n                this.manipulator_handle_previous = args[0].manipulator_handle_previous;\n                return;\n            }\n            super(args[0], args[1], args[2]);\n            this.values = args[3];\n            this.display = GraphInputEnumSettingsDisplayType.DEFAULT;\n            this.manipulator_handle_next = \"\";\n            this.manipulator_handle_previous = \"\";\n        }\n    }\n    Graph_1.GraphInputEnumSettings = GraphInputEnumSettings;\n    class GraphInput extends changeable_1.Changeable {\n        constructor(...args) {\n            super();\n            this.is_active = true;\n            this.is_hidden = false;\n            this.order = 0;\n            if (args.length == 1) {\n                const input_obj = args[0];\n                this.guid = input_obj.guid;\n                this.verbose_ru = input_obj.verbose_ru;\n                this.verbose_en = input_obj.verbose_en;\n                this.name = input_obj.name;\n                this.type = input_obj.type;\n                this.hint = input_obj.hint;\n                this.value = input_obj.value;\n                this.is_active = input_obj.is_active;\n                this.is_hidden = input_obj.is_hidden;\n                this.order = input_obj.order;\n                this.parent = input_obj.parent;\n                this.related_builtin_component = input_obj.related_builtin_component;\n                this.icon = input_obj.icon;\n                this.user_data = input_obj.user_data;\n                switch (this.type) {\n                    case GraphInputType.NONE:\n                        this.settings = new GraphInputSettings(input_obj.settings);\n                        break;\n                    case GraphInputType.FLOAT:\n                        this.settings = new GraphInputFloatSettings(input_obj.settings);\n                        break;\n                    case GraphInputType.INT:\n                        this.settings = new GraphInputIntSettings(input_obj.settings);\n                        break;\n                    case GraphInputType.STRING:\n                        this.settings = new GraphInputStringSettings(input_obj.settings);\n                        break;\n                    case GraphInputType.FILES_TAG:\n                        this.settings = new GraphInputFilesTagSettings(input_obj.settings);\n                        break;\n                    case GraphInputType.FILES:\n                        this.settings = new GraphInputFilesSettings(input_obj.settings);\n                        break;\n                    case GraphInputType.ENUM:\n                        this.settings = new GraphInputEnumSettings(input_obj.settings);\n                        break;\n                    case GraphInputType.CATALOG:\n                        this.settings = new GraphInputCatalogSettings(input_obj.settings);\n                        break;\n                }\n                return;\n            }\n            this.guid = args[0];\n            this.verbose_ru = args[1];\n            this.name = args[2];\n            this.type = args[3];\n            this.value = args[4];\n            this.settings = args[5];\n            this.is_active = args[6];\n            this.parent = args[7];\n            this.verbose_en = \"\";\n            this.hint = \"\";\n            this.related_builtin_component = \"\";\n            this.icon = \"\";\n            this.user_data = \"\";\n        }\n    }\n    Graph_1.GraphInput = GraphInput;\n    class GraphOutput extends changeable_1.Changeable {\n        constructor(output_obj) {\n            super();\n            this.guid = output_obj.guid;\n            this.name = output_obj.name;\n            this.hint = output_obj.hint;\n            this.value = output_obj.value;\n            this.show_in_preview = output_obj.show_in_preview;\n            this.show_in_consult = output_obj.show_in_consult;\n            this.is_hidden = output_obj.is_hidden;\n            this.order = output_obj.order;\n            this.tag = output_obj.tag;\n            this.type = output_obj.type;\n            this.verbose_ru = output_obj.verbose_ru;\n            this.verbose_en = output_obj.verbose_en;\n            this.min = 0;\n            this.max = 0;\n        }\n    }\n    Graph_1.GraphOutput = GraphOutput;\n    class Graph extends changeable_1.Changeable {\n        constructor(...args) {\n            super();\n            this.related_inputs = null;\n            this.is_active = true;\n            this.inputs = [];\n            this.outputs = [];\n            this.nodes = [];\n            this.comments = [];\n            this.position = new math_1.Vector2();\n            this.scale = 1;\n            if (args.length == 1) {\n                this.related_inputs = {};\n                const graph_obj = args[0];\n                this.is_active = graph_obj.is_active;\n                this.comments = graph_obj.comments;\n                if (graph_obj.position != null)\n                    this.position = new math_1.Vector2(graph_obj.position);\n                if (graph_obj.scale != null)\n                    this.scale = graph_obj.scale;\n                for (const i of graph_obj.inputs)\n                    this.inputs.push(new GraphInput(i));\n                for (const o of graph_obj.outputs)\n                    this.outputs.push(new GraphOutput(o));\n                for (const n of graph_obj.nodes)\n                    this.nodes.push(new GraphNode(n));\n                for (let i in graph_obj.related_inputs)\n                    this.related_inputs[i] = graph_obj.related_inputs[i];\n            }\n        }\n        FindNodeByGUID(guid) {\n            return this.nodes.find(function (n) {\n                return n.guid === guid;\n            });\n        }\n        GetNodeInputLinks(node) {\n            let result = [];\n            const args = node.method.arguments.filter((argument) => argument.IsLinked);\n            for (const arg of args)\n                result = result.concat(arg.GetLinks().map((link) => this.FindNodeByGUID(link)));\n            return result;\n        }\n        GetNodeOutputLinks(node) {\n            return this.nodes.filter((n) => n.method.arguments.some((argument) => argument.GetLinks().some((link) => link == node.guid)));\n        }\n        GetRootNodes(node) {\n            let result = [];\n            let parents = this.GetNodeInputLinks(node);\n            if (parents.length != 0) {\n                for (const parent of parents)\n                    result = result.concat(this.GetRootNodes(parent));\n            }\n            else {\n                result = parents;\n            }\n            return result;\n        }\n        GetFinalNodes(node) {\n            let result = [];\n            let children = this.GetNodeOutputLinks(node);\n            if (children.length != 0) {\n                for (const child of children)\n                    result = result.concat(this.GetFinalNodes(child));\n            }\n            else {\n                result = children;\n            }\n            return result;\n        }\n        AddAdditionalDataToInput(input_guid, name, value, icon = \"\", callback = null) {\n            const input = this.inputs.find((i) => i.guid == input_guid);\n            if (input == null) {\n                logger_1.Logger.Log(\"Cannot find input with guid = \" + input_guid, logger_1.Logger.DebugLevel.ERROR);\n                return;\n            }\n            if (input.type != GraphInputType.CATALOG) {\n                logger_1.Logger.Log(\"Unsupported input type for additional data\", logger_1.Logger.DebugLevel.ERROR);\n                return;\n            }\n            const settings = input.settings;\n            settings.additional_values.push(new GraphInputFileValue(name, icon, value));\n            input.value = value;\n            if (callback != null)\n                callback();\n        }\n        RemoveAdditionalDataFromInput(input_guid, value) {\n            const input = this.inputs.find((i) => i.guid == input_guid);\n            if (input == null) {\n                logger_1.Logger.Log(\"Cannot find input with guid = \" + input_guid, logger_1.Logger.DebugLevel.ERROR);\n                return;\n            }\n            if (input.type != GraphInputType.CATALOG) {\n                logger_1.Logger.Log(\"Unsupported input type for additional data\", logger_1.Logger.DebugLevel.ERROR);\n                return;\n            }\n            const settings = input.settings;\n            settings.additional_values = settings.additional_values.filter((v) => v.value == value);\n        }\n        AddMaterialInput(name, comp_full_names, materials) {\n            //INPUT\n            let input_settings = new GraphInputFilesSettings(\"\", true, \"\", materials);\n            let input = new GraphInput((0, utils_1.CreateUUID)(), name, name, GraphInputType.FILES, materials[0].value, input_settings, true, \"\");\n            //INPUT NODE\n            let input_node_argument = new GraphNodeMethodArgument(\"input\", name, ArgumentType.INPUT);\n            let input_node_result = new GraphNodeMethodArgument(\"\", \"\", ArgumentType.ANY);\n            let input_node_method = new GraphNodeMethod(\"GetInputValue\", [input_node_argument], input_node_result);\n            let input_node = new GraphNode((0, utils_1.CreateUUID)(), \" \", new math_1.Vector2(), input_node_method);\n            //SET MATERIAL NODE\n            let set_material_node_component_argument_values = [];\n            for (let i in comp_full_names) {\n                const pair = new GraphNodeMethodArgumentKeyValuePair(ArgumentType.COMPONENT, (i + 1).toString(), comp_full_names[i]);\n                set_material_node_component_argument_values.push(pair);\n            }\n            let set_material_node_component_argument = new GraphNodeMethodArgument(\"components\", set_material_node_component_argument_values, ArgumentType.DICTIONARY);\n            let set_field_node_component_argument_value = new GraphNodeMethodArgumentKeyValuePair(ArgumentType.NODE, \"material\", new GraphNodeMethodArgumentNodeValue(input_node.guid, null));\n            let set_field_node_component_argument = new GraphNodeMethodArgument(\"fields\", [set_field_node_component_argument_value], ArgumentType.DICTIONARY);\n            let set_material_node_result = new GraphNodeMethodArgument(\"\", \"\", ArgumentType.NONE);\n            let set_material_node_method = new GraphNodeMethod(\"SetComponentsFields\", [\n                set_material_node_component_argument,\n                set_field_node_component_argument,\n            ], set_material_node_result);\n            let set_material_node = new GraphNode((0, utils_1.CreateUUID)(), \"  \", new math_1.Vector2(), set_material_node_method);\n            this.inputs.push(input);\n            this.nodes.push(input_node);\n            this.nodes.push(set_material_node);\n        }\n        AddSlotInput(project, source, parent) {\n            return __awaiter(this, void 0, void 0, function* () {\n                //TODO      any\n                const vertical_offset = Math.min(...this.nodes.map((n) => n.position.y)) - 500;\n                let category = source.modifier.category;\n                if (category == null || category == 0) {\n                    const stat = yield filesystem_1.Filesystem.Get(\"api/Calculation/GetCalculationStat?guid=\" + project.guid);\n                    category = stat.category;\n                }\n                let target_slots = source.modifier.related_project_data.components.filter((c) => c.modifier.type == 5 &&\n                    (c.modifier.allow_iik_slotting == null ||\n                        c.modifier.allow_iik_slotting == true));\n                if (category != null && category != 0)\n                    target_slots = target_slots.filter((s) => s.modifier.category == category);\n                //INPUT\n                let input_settings_values = target_slots.map((s) => new GraphInputStringValue(s.name, s.fullPath));\n                let input_settings = new GraphInputEnumSettings(\"\", true, \"\", input_settings_values);\n                let input = new GraphInput((0, utils_1.CreateUUID)(), \"\", \"slot_\" + source.guid, GraphInputType.ENUM, input_settings_values[0].value, input_settings, true, parent ? parent.guid : \"\");\n                //INPUT_NODE\n                let input_node_argument = new GraphNodeMethodArgument(\"input\", \"slot_\" + source.guid, ArgumentType.INPUT);\n                let input_node_result = new GraphNodeMethodArgument(\"\", \"\", ArgumentType.ANY);\n                let input_node_method = new GraphNodeMethod(\"GetInputValue\", [input_node_argument], input_node_result);\n                let input_node = new GraphNode((0, utils_1.CreateUUID)(), \" \", new math_1.Vector2(-200, vertical_offset), input_node_method);\n                //SET_SLOT_NODE\n                let set_slot_node_component_argument_values = [\n                    new GraphNodeMethodArgumentKeyValuePair(ArgumentType.COMPONENT, \"1\", source.fullPath),\n                ];\n                let set_slot_node_component_argument = new GraphNodeMethodArgument(\"components\", set_slot_node_component_argument_values, ArgumentType.DICTIONARY);\n                let set_field_node_component_argument_value = new GraphNodeMethodArgumentKeyValuePair(ArgumentType.NODE, \"target_slot\", new GraphNodeMethodArgumentNodeValue(input_node.guid, null));\n                let set_field_node_component_argument = new GraphNodeMethodArgument(\"fields\", [set_field_node_component_argument_value], ArgumentType.DICTIONARY);\n                let set_slot_node_result = new GraphNodeMethodArgument(\"\", \"\", ArgumentType.NONE);\n                let set_slot_node_method = new GraphNodeMethod(\"SetComponentsFields\", [set_slot_node_component_argument, set_field_node_component_argument], set_slot_node_result);\n                let set_slot_node = new GraphNode((0, utils_1.CreateUUID)(), \"  \", new math_1.Vector2(200, vertical_offset), set_slot_node_method);\n                this.inputs.push(input);\n                this.nodes.push(input_node);\n                this.nodes.push(set_slot_node);\n            });\n        }\n    }\n    Graph_1.Graph = Graph;\n})(Graph || (exports.Graph = Graph = {}));\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IIK = void 0;\n//@ts-ignore\nconst lodash_get_js_1 = __importDefault(require(\"../plugins/lodash_get.js\"));\nconst project_1 = require(\"./Project/DTOs/project\");\nconst filesystem_1 = require(\"./filesystem\");\nconst graph_1 = require(\"./graph\");\nconst logger_1 = require(\"./logger\");\nconst builder_1 = require(\"./Product/builder\");\nconst shape_1 = require(\"./Product/shape\");\nconst enums_1 = require(\"./Project/enums\");\nconst project_assembler_1 = require(\"./Project/Implementations/project_assembler\");\nconst project_item_implementation_1 = require(\"./Project/Implementations/project_item_implementation\");\nconst project_component_implementation_1 = require(\"./Project/Implementations/project_component_implementation\");\nvar Log = logger_1.Logger.Log;\nvar DebugLevel = logger_1.Logger.DebugLevel;\nvar ArgumentType = graph_1.Graph.ArgumentType;\nvar GraphInputType = graph_1.Graph.GraphInputType;\nvar GraphOutputType = graph_1.Graph.GraphOutputType;\nconst math_1 = require(\"./math\");\nconst utils_1 = require(\"./utils\");\nconst material_1 = require(\"./material\");\nvar IIK;\n(function (IIK) {\n    var Material = material_1.MaterialCore.Material;\n    class IIKCore {\n        //TODO\n        //public async PrefetchResources(done?: () => void): Promise<void> {\n        //  if (!this.project.prefetch?.materials) return;\n        //  const materialGuids = this.project.prefetch.materials.map(\n        //    (materialUrl: string) => materialUrl.replace(\"s123mat://\", \"\"),\n        //  );\n        //  if (materialGuids !== null) {\n        //    await Utils.iterateAsync(\n        //      materialGuids,\n        //      async (guid: string) => {\n        //        const calc_stat = await Filesystem.Get(\n        //          \"api/Calculation/GetCalculationStat?guid=\" + guid,\n        //        );\n        //        if (calc_stat) {\n        //          await Filesystem.GetFile(\n        //            `s123://calculationResults/${guid}/${calc_stat.projectFileName}`,\n        //          );\n        //        }\n        //      },\n        //      this.platform,\n        //    );\n        //  }\n        //  if (typeof done == \"function\") {\n        //    done();\n        //  }\n        //}\n        static UpdateOldScript(script) {\n            return script.replace(/IIK\\.project/g, \"this.project\");\n        }\n        GetObjectFieldByString(target, path) {\n            if (path.includes(\".\")) {\n                const splitted = path.split(\".\");\n                if (target[splitted[0]] === undefined)\n                    return undefined;\n                return target[splitted[0]][splitted[1]];\n            }\n            return target[path];\n        }\n        InvokeMethod(method_info) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Invoking method: \" + method_info.name, logger_1.Logger.DebugLevel.VERBOSE);\n                const args = [];\n                for (let a of method_info.arguments)\n                    args.push(a);\n                if (method_info.result.type === ArgumentType.DICTIONARY)\n                    args.push(method_info.result);\n                const func = (0, lodash_get_js_1.default)(IIKCore.prototype, method_info.name);\n                return yield func.apply(this, args);\n            });\n        }\n        GetValue(attr) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (attr.type === ArgumentType.NODE) {\n                    const guid = attr.value.node_guid;\n                    let result = null;\n                    if (guid in this.method_cache)\n                        result = this.method_cache[guid];\n                    if (result == null) {\n                        const m = this.project.graph.FindNodeByGUID(guid);\n                        if (m == null)\n                            result = \"\";\n                        else\n                            result = yield this.InvokeMethod(m.method);\n                        this.method_cache[guid] = result;\n                    }\n                    if (attr.value.pair_key != null && attr.value.pair_key.length > 0) {\n                        for (const r of result)\n                            if (r.key === attr.value.pair_key)\n                                return r.value;\n                        return null;\n                    }\n                    return result;\n                }\n                return attr.value;\n            });\n        }\n        MakeConstant(v) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling MakeConstant node with value: \" + v, DebugLevel.VERBOSE);\n                let result = yield this.GetValue(v);\n                if (typeof result === \"string\" && !isNaN(Number(result))) {\n                    if (result.includes(\",\"))\n                        result = result.replace(\",\", \".\");\n                    if (result.includes(\".\"))\n                        result = parseFloat(result);\n                    else\n                        result = parseInt(result);\n                }\n                return result;\n            });\n        }\n        GetInputValue(name) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling GetInputValue node with value: \" + name, DebugLevel.VERBOSE);\n                name = yield this.GetValue(name);\n                const input = this.project.graph.inputs.find(function (i) {\n                    return i.name === name;\n                });\n                if (input != null) {\n                    let result = input.value;\n                    if ((input.type === 1 || input.type === 3) &&\n                        typeof result === \"string\") {\n                        if (result.includes(\",\"))\n                            result = result.replace(\",\", \".\");\n                        if (result.includes(\".\"))\n                            result = parseFloat(result);\n                        else\n                            result = parseInt(result);\n                    }\n                    return result;\n                }\n                return 0;\n            });\n        }\n        GetOutputValue(name) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling GetOutputValue node with value: \" + name, DebugLevel.VERBOSE);\n                name = yield this.GetValue(name);\n                let result = this.outputs[name];\n                if (result == undefined) {\n                    logger_1.Logger.Log(\"    \" + name, DebugLevel.ERROR);\n                    return 0;\n                }\n                return result;\n            });\n        }\n        GetComponentField(_comp, _field_name) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling GetComponentField node with values: \" +\n                    _comp +\n                    \"|\" +\n                    _field_name, DebugLevel.VERBOSE);\n                const comp_path = yield this.GetValue(_comp);\n                const comp = this.projectAssembler.FindComponentByPath(comp_path);\n                if (comp == null)\n                    return 0;\n                const field_name = yield this.GetValue(_field_name);\n                let result = this.GetObjectFieldByString(comp, field_name);\n                if (result === undefined)\n                    result = this.GetObjectFieldByString(comp.modifier, field_name);\n                if (result === undefined) {\n                    logger_1.Logger.Log(`    ${field_name}   ${comp_path}`, DebugLevel.ERROR);\n                    return 0;\n                }\n                return result;\n            });\n        }\n        SetComponentsFields(components, fields) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling SetComponentsFields node with values: \" +\n                    components +\n                    \"|\" +\n                    fields, DebugLevel.VERBOSE);\n                if (fields.value == null) {\n                    logger_1.Logger.Log(\"      \", DebugLevel.ERROR);\n                    return;\n                }\n                for (const c of components.value) {\n                    const comp_path = c.value;\n                    const comp = this.projectAssembler.FindComponentByPath(comp_path);\n                    if (comp == null) {\n                        logger_1.Logger.Log(`     : ${comp_path}`, DebugLevel.ERROR);\n                        continue;\n                    }\n                    for (const field of fields.value) {\n                        const v = yield this.GetValue(field);\n                        if (v == undefined)\n                            continue;\n                        if (field.key.includes(\".\")) {\n                            const splitted = field.key.split(\".\");\n                            try {\n                                comp[splitted[0]][splitted[1]] = v;\n                            }\n                            catch (_a) {\n                                comp.modifier[splitted[0]][splitted[1]] = v;\n                            }\n                        }\n                        else if (field.key in comp) {\n                            comp[field.key] = v;\n                        }\n                        else if (field.key in comp.modifier) {\n                            comp.modifier[field.key] = v;\n                        }\n                        else\n                            logger_1.Logger.Log(`    ${field.key}   ${comp_path}`, DebugLevel.ERROR);\n                    }\n                }\n            });\n        }\n        SetLDSPMaterial(components, material) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling SetLDSPMaterial node with values: \" +\n                    components +\n                    \"|\" +\n                    material, DebugLevel.VERBOSE);\n                for (const c of components.value) {\n                    const comp_path = c.value;\n                    const comp = this.projectAssembler.FindComponentByPath(comp_path);\n                    if (comp == null)\n                        continue;\n                    if (comp.modifier.type != enums_1.ProjectComponentModifierType.LDSP)\n                        continue;\n                    const modifier = comp.modifier;\n                    const front_material = yield this.GetValue(material);\n                    comp.material = front_material;\n                    modifier.back_material = front_material;\n                    const edges = modifier.edges;\n                    for (const edge of edges)\n                        edge.material = front_material;\n                }\n            });\n        }\n        SetLDSPElementMaterial(components, material, back_material, left_edge, top_edge, right_edge, bottom_edge) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling SetLDSPElementMaterial node with values: \" +\n                    components +\n                    \"|\" +\n                    material +\n                    \"|\" +\n                    back_material +\n                    \"|\" +\n                    left_edge +\n                    \"|\" +\n                    top_edge +\n                    \"|\" +\n                    right_edge +\n                    \"|\" +\n                    bottom_edge, DebugLevel.VERBOSE);\n                for (const c of components.value) {\n                    const comp_path = c.value;\n                    const comp = this.projectAssembler.FindComponentByPath(comp_path);\n                    if (comp == null)\n                        continue;\n                    if (comp.modifier.type != enums_1.ProjectComponentModifierType.LDSP)\n                        continue;\n                    const modifier = comp.modifier;\n                    const front_material = yield this.GetValue(material);\n                    const _back_material = yield this.GetValue(back_material);\n                    comp.material = front_material;\n                    modifier.back_material = _back_material;\n                    const edges = modifier.edges;\n                    edges[0].material = yield this.GetValue(left_edge);\n                    edges[1].material = yield this.GetValue(top_edge);\n                    edges[2].material = yield this.GetValue(right_edge);\n                    edges[3].material = yield this.GetValue(bottom_edge);\n                }\n            });\n        }\n        SetLDSPEdgesType(components, left, top, right, bottom) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling SetLDSPEdgesType node with values: \" +\n                    components +\n                    \"|\" +\n                    left +\n                    \"|\" +\n                    top +\n                    \"|\" +\n                    right +\n                    \"|\" +\n                    bottom, DebugLevel.VERBOSE);\n                for (const c of components.value) {\n                    const comp_path = c.value;\n                    const comp = this.projectAssembler.FindComponentByPath(comp_path);\n                    if (comp == null)\n                        continue;\n                    if (comp.modifier.type != enums_1.ProjectComponentModifierType.LDSP)\n                        continue;\n                    const modifier = comp.modifier;\n                    modifier.edges[0].type = yield this.GetValue(left);\n                    modifier.edges[1].type = yield this.GetValue(top);\n                    modifier.edges[2].type = yield this.GetValue(right);\n                    modifier.edges[3].type = yield this.GetValue(bottom);\n                }\n            });\n        }\n        SetComponentRotation(_comp, ax, ay, az) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling SetComponentRotation node with values: \" +\n                    _comp +\n                    \"|\" +\n                    ax +\n                    \",\" +\n                    ay +\n                    \",\" +\n                    az, DebugLevel.VERBOSE);\n                const comp_path = yield this.GetValue(_comp);\n                const comp = this.projectAssembler.FindComponentByPath(comp_path);\n                if (comp == null)\n                    return;\n                const rx = yield this.GetValue(ax);\n                const ry = yield this.GetValue(ay);\n                const rz = yield this.GetValue(az);\n                comp.rotation = math_1.Quaternion.euler(rx, ry, rz);\n            });\n        }\n        SetPositioningPointsFields(points, fields) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling SetPositioningPointsFields node with values: \" +\n                    points +\n                    \"|\" +\n                    fields, DebugLevel.VERBOSE);\n                for (const v of points.value) {\n                    const pp_path = v.value;\n                    const pp = this.projectAssembler.FindPointByPath(pp_path);\n                    if (pp == null) {\n                        logger_1.Logger.Log(`      : ${pp_path}`, DebugLevel.ERROR);\n                        continue;\n                    }\n                    for (const field of fields.value) {\n                        const v = yield this.GetValue(field);\n                        if (v == undefined)\n                            continue;\n                        if (field.key.includes(\".\")) {\n                            const splitted = field.key.split(\".\");\n                            pp[splitted[0]][splitted[1]] = v;\n                        }\n                        else if (field.key in pp) {\n                            pp[field.key] = v;\n                        }\n                        else\n                            logger_1.Logger.Log(`    ${field.key}    ${pp_path}`, DebugLevel.ERROR);\n                    }\n                }\n            });\n        }\n        GetMargin(_comp, _face, _side) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling GetMargin node with values: \" +\n                    _comp +\n                    \"|\" +\n                    _face +\n                    \"|\" +\n                    _side, DebugLevel.VERBOSE);\n                const comp_path = yield this.GetValue(_comp);\n                const comp = this.projectAssembler.FindComponentByPath(comp_path);\n                if (comp == null)\n                    return 0;\n                let face = yield this.GetValue(_face);\n                if (face == null)\n                    face = enums_1.Face.FRONT;\n                let side = yield this.GetValue(_side);\n                if (side == null)\n                    side = enums_1.MarginSide.LEFT;\n                const modifier = comp.modifier;\n                const margin = modifier.margins.find((m) => m.face == face);\n                if (margin == null)\n                    return 0;\n                return margin.values[side];\n            });\n        }\n        SetMargin(_comp, _face, _side, _value) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling SetMargin node with values: \" +\n                    _comp +\n                    \"|\" +\n                    _face +\n                    \"|\" +\n                    _side +\n                    \"|\" +\n                    _value, DebugLevel.VERBOSE);\n                const comp_path = yield this.GetValue(_comp);\n                const comp = this.projectAssembler.FindComponentByPath(comp_path);\n                if (comp == null)\n                    return;\n                if (comp.modifier.type != enums_1.ProjectComponentModifierType.BUILTIN)\n                    return;\n                const modifier = comp.modifier;\n                let face = yield this.GetValue(_face);\n                if (face == null)\n                    face = enums_1.Face.FRONT;\n                let side = yield this.GetValue(_side);\n                if (side == null)\n                    side = enums_1.MarginSide.LEFT;\n                const value = yield this.GetValue(_value);\n                const margin = modifier.margins.find((m) => m.face == face);\n                if (margin == null)\n                    return;\n                margin.values[side] = value;\n            });\n        }\n        SumRun(positive_variables, negative_variables, script, result) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling SumRun node with values: \" +\n                    positive_variables +\n                    \"|\" +\n                    negative_variables +\n                    \"|\" +\n                    script +\n                    \"|\" +\n                    result, DebugLevel.VERBOSE);\n                let var_string = \"\";\n                let buffer_string = \"\";\n                let sum = 0;\n                let buffer = {};\n                if (positive_variables.value != null) {\n                    for (let pval of positive_variables.value) {\n                        const key = pval.key;\n                        let value = yield this.GetValue(pval);\n                        if (value == null)\n                            value = \"\";\n                        if (typeof value === \"string\") {\n                            if (value == \"\" || isNaN(Number(value)))\n                                value = '\"' + value + '\"';\n                        }\n                        var_string += \"const \" + key + \" = \" + value + \";\\n\";\n                        sum += value;\n                    }\n                }\n                if (negative_variables.value != null) {\n                    for (let nval of negative_variables.value) {\n                        const key = nval.key;\n                        let value = yield this.GetValue(nval);\n                        if (value == null)\n                            value = \"\";\n                        if (typeof value === \"string\") {\n                            if (value == \"\" || isNaN(Number(value)))\n                                value = '\"' + value + '\"';\n                        }\n                        var_string += \"const \" + key + \" = \" + value + \";\\n\";\n                        sum -= value;\n                    }\n                }\n                for (let val of result.value) {\n                    if (val.key === \"\")\n                        continue;\n                    var_string += \"let \" + val.key + \";\\n\";\n                    buffer_string += \"buffer.\" + val.key + \" = \" + val.key + \";\\n\";\n                }\n                let target_string = var_string;\n                if (script.value != null)\n                    target_string += IIKCore.UpdateOldScript(script.value) + \"\\n\";\n                target_string += buffer_string;\n                const exposedKeys = [\n                    \"self\",\n                    \"buffer\",\n                    \"sum\",\n                    \"var_string\",\n                    \"buffer_string\",\n                    \"target_string\",\n                    \"S123Core\"\n                ];\n                const exposedValues = [\n                    this,\n                    buffer,\n                    sum,\n                    var_string,\n                    buffer_string,\n                    target_string,\n                    yield Promise.resolve().then(() => __importStar(require(\"./index\")))\n                ];\n                if (target_string.includes(\"await\")) {\n                    yield new Function(...exposedKeys, `return (async function() {${target_string}})();`).apply(this, exposedValues);\n                }\n                else {\n                    new Function(...exposedKeys, target_string).apply(this, exposedValues);\n                }\n                for (let val of result.value) {\n                    if (val.key === \"\")\n                        continue;\n                    val.value = buffer[val.key];\n                }\n                for (let val of result.value) {\n                    if (val.key === \"\")\n                        val.value = sum;\n                }\n                return result.value;\n            });\n        }\n        SetOutput(name, value) {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Calling SetOutput node with values: \" + name + \"|\" + value, DebugLevel.VERBOSE);\n                if (name.value == \"\" || name.value == null)\n                    return;\n                const real_value = yield this.GetValue(value);\n                this.outputs[name.value] = real_value;\n                const output = this.project.graph.outputs.find((o) => o != null && o.name == name.value);\n                if (output == null)\n                    return;\n                output.value = real_value;\n            });\n        }\n        SetUVTransform(components, offset_x, offset_y, scale_x, scale_y, rotation) {\n            return __awaiter(this, void 0, void 0, function* () {\n                for (const c of components.value) {\n                    const comp_path = c.value;\n                    const comp = this.projectAssembler.FindComponentByPath(comp_path);\n                    if (comp == null || comp.processings == null || comp.processings.length == 0)\n                        continue;\n                    const foundProcessing = comp.processings.find(function (p) {\n                        return p.type == 2;\n                    });\n                    if (foundProcessing == null)\n                        continue;\n                    const targetProcessing = foundProcessing;\n                    let offset_x_value = yield this.GetValue(offset_x);\n                    let offset_y_value = yield this.GetValue(offset_y);\n                    let scale_x_value = yield this.GetValue(scale_x);\n                    let scale_y_value = yield this.GetValue(scale_y);\n                    let rotation_value = yield this.GetValue(rotation);\n                    if (offset_x_value == null ||\n                        offset_y_value == null ||\n                        scale_x_value == null ||\n                        scale_y_value == null ||\n                        rotation_value == null)\n                        continue;\n                    targetProcessing.offset = new math_1.Vector2(offset_x_value, offset_y_value);\n                    targetProcessing.scale = new math_1.Vector2(scale_x_value, scale_y_value);\n                    targetProcessing.rotation = rotation_value;\n                }\n            });\n        }\n        GetSerializedBlocks() {\n            return JSON.stringify(this.Blocks);\n        }\n        PrepareInputs() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (this.inputs != null) {\n                    for (let input of this.inputs) {\n                        const pr_input = this.project.graph.inputs.find(function (i) {\n                            return i.guid == input.guid;\n                        });\n                        if (pr_input === undefined)\n                            continue;\n                        pr_input.value = input.value;\n                        if (input.settings != null)\n                            pr_input.settings = input.settings;\n                        if (input.is_active != null)\n                            pr_input.is_active = input.is_active;\n                    }\n                }\n                if (this.parent_project != null &&\n                    this.parent_project.graph.outputs != null) {\n                    for (let input of this.project.graph.inputs) {\n                        if (input.settings.tag != null && input.settings.tag != \"\") {\n                            const tagged_output = this.parent_project.graph.outputs.find(function (o) {\n                                return o.tag == input.settings.tag;\n                            });\n                            if (tagged_output != null) {\n                                input.value = tagged_output.value;\n                            }\n                        }\n                    }\n                }\n                this.inputs = this.project.graph.inputs;\n                for (let i of this.inputs) {\n                    if (i.settings != null &&\n                        i.type == GraphInputType.ENUM &&\n                        i.settings.values.length > 0 &&\n                        (i.value == \"\" || i.value == null))\n                        i.value = i.settings.values[0].value;\n                    //if( i.type == GraphInputType.FILES_TAG && ( i.value == null || i.value == \"\" ) )\n                    //{\n                    //    let request_string = \"api/Calculation/GetAllPaginationCalculations?offset=0&limit=64&tags=\";\n                    //    for( let t of i.settings.search_tags )\n                    //        request_string += \"%23\" + t.value;\n                    //    request_string = encodeURI(request_string);\n                    //    const response = await Filesystem.Get( request_string );\n                    //    const calculations = response.calculations;\n                    //    if( calculations.length == 0 )\n                    //        continue;\n                    //    const first_calc = calculations[0];\n                    //    if( first_calc.idCalculationType == 3 )\n                    //        i.value = \"s123mat://\" + first_calc.guid;\n                    //    else\n                    //        i.value = \"s123calc://\" + first_calc.guid;\n                    //}\n                }\n            });\n        }\n        constructor(project) {\n            this.is_active = true;\n            this.related_calculations = {};\n            this.related_names = {};\n            this.has_frontend = true;\n            this.generate_inactive = false;\n            this.has_related = true;\n            this.is_detailed_materials = false;\n            this.max_texture_size = 512;\n            this.platform = undefined;\n            this.is_web_pbr_extras_active = false;\n            this.is_web_ar_active = false;\n            this.is_scene = false;\n            this.method_cache = {};\n            this.Blocks = [\n                {\n                    verbose_name: \"\",\n                    name: \"MakeConstant\",\n                    color: \"#ffffff\",\n                    arguments: [\n                        {\n                            verbose_name: \"\",\n                            name: \"v\",\n                            type: ArgumentType.FLOAT,\n                            value_only: true,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.FLOAT,\n                    },\n                },\n                {\n                    verbose_name: \"  \",\n                    name: \"GetComponentField\",\n                    color: \"#ffad6a\",\n                    arguments: [\n                        {\n                            name: \"component\",\n                            type: ArgumentType.COMPONENT,\n                            value_only: true,\n                        },\n                        {\n                            name: \"field_name\",\n                            type: ArgumentType.COMPONENT_FIELD,\n                            value_only: true,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.ANY,\n                    },\n                },\n                {\n                    is_final: true,\n                    verbose_name: \"  \",\n                    color: \"#788cff\",\n                    name: \"SetComponentsFields\",\n                    arguments: [\n                        {\n                            name: \"components\",\n                            type: ArgumentType.DICTIONARY,\n                            settings: {\n                                key: ArgumentType.STRING,\n                                value: ArgumentType.COMPONENT,\n                                value_only: true,\n                            },\n                            is_array: true,\n                            value_only: true,\n                        },\n                        {\n                            name: \"fields\",\n                            type: ArgumentType.DICTIONARY,\n                            settings: {\n                                key: ArgumentType.COMPONENT_FIELD,\n                                value: ArgumentType.ANY,\n                            },\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.NONE,\n                    },\n                },\n                {\n                    is_final: true,\n                    verbose_name: \" \",\n                    name: \"SetComponentRotation\",\n                    color: \"#df6aff\",\n                    arguments: [\n                        {\n                            name: \"comp\",\n                            type: ArgumentType.COMPONENT,\n                            value_only: true,\n                        },\n                        {\n                            name: \"ax\",\n                            type: ArgumentType.FLOAT,\n                        },\n                        {\n                            name: \"ay\",\n                            type: ArgumentType.FLOAT,\n                        },\n                        {\n                            name: \"az\",\n                            type: ArgumentType.FLOAT,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.NONE,\n                    },\n                },\n                {\n                    verbose_name: \" \",\n                    name: \"GetMargin\",\n                    color: \"#b192ff\",\n                    arguments: [\n                        {\n                            name: \"comp\",\n                            verbose_name: \"\",\n                            type: ArgumentType.COMPONENT,\n                            value_only: true,\n                        },\n                        {\n                            name: \"face\",\n                            verbose_name: \"\",\n                            type: ArgumentType.FACE,\n                            value_only: true,\n                        },\n                        {\n                            name: \"side\",\n                            verbose_name: \"\",\n                            type: ArgumentType.MARGIN_SIDE,\n                            value_only: true,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.FLOAT,\n                    },\n                },\n                {\n                    is_final: true,\n                    verbose_name: \" \",\n                    name: \"SetMargin\",\n                    color: \"#8efffa\",\n                    arguments: [\n                        {\n                            name: \"comp\",\n                            verbose_name: \"\",\n                            type: ArgumentType.COMPONENT,\n                            value_only: true,\n                        },\n                        {\n                            name: \"face\",\n                            verbose_name: \"\",\n                            type: ArgumentType.FACE,\n                            value_only: true,\n                        },\n                        {\n                            name: \"side\",\n                            verbose_name: \"\",\n                            type: ArgumentType.MARGIN_SIDE,\n                            value_only: true,\n                        },\n                        {\n                            name: \"value\",\n                            verbose_name: \"\",\n                            type: ArgumentType.FLOAT,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.NONE,\n                    },\n                },\n                {\n                    is_final: true,\n                    verbose_name: \"  \",\n                    color: \"#6affe9\",\n                    name: \"SetPositioningPointsFields\",\n                    arguments: [\n                        {\n                            name: \"points\",\n                            type: ArgumentType.DICTIONARY,\n                            settings: {\n                                key: ArgumentType.STRING,\n                                value: ArgumentType.POSITIONING_POINT,\n                                value_only: true,\n                            },\n                            value_only: true,\n                            is_array: true,\n                        },\n                        {\n                            name: \"fields\",\n                            type: ArgumentType.DICTIONARY,\n                            settings: {\n                                key: ArgumentType.POSITIONING_POINT_FIELD,\n                                value: ArgumentType.ANY,\n                            },\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.NONE,\n                    },\n                },\n                {\n                    is_final: true,\n                    verbose_name: \"\",\n                    color: \"#ff5e5e\",\n                    name: \"SumRun\",\n                    arguments: [\n                        {\n                            name: \"positive_variables\",\n                            verbose_name: \"\",\n                            type: ArgumentType.DICTIONARY,\n                            settings: {\n                                key: ArgumentType.STRING,\n                                value: ArgumentType.ANY,\n                            },\n                        },\n                        {\n                            name: \"negative_variables\",\n                            verbose_name: \"\",\n                            type: ArgumentType.DICTIONARY,\n                            settings: {\n                                key: ArgumentType.STRING,\n                                value: ArgumentType.ANY,\n                            },\n                        },\n                        {\n                            name: \"script\",\n                            type: ArgumentType.SCRIPT,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.DICTIONARY,\n                        settings: {\n                            key: ArgumentType.STRING,\n                            value: ArgumentType.ANY,\n                            fixed_keys: [\"\"],\n                        },\n                    },\n                },\n                {\n                    verbose_name: \" \",\n                    color: \"#7dff63\",\n                    name: \"GetInputValue\",\n                    arguments: [\n                        {\n                            name: \"input\",\n                            type: ArgumentType.INPUT,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.ANY,\n                    },\n                },\n                {\n                    verbose_name: \" \",\n                    color: \"#abffc6\",\n                    name: \"GetOutputValue\",\n                    arguments: [\n                        {\n                            name: \"input\",\n                            type: ArgumentType.OUTPUT,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.ANY,\n                    },\n                },\n                {\n                    is_final: true,\n                    verbose_name: \" \",\n                    color: \"#fff86a\",\n                    name: \"SetOutput\",\n                    arguments: [\n                        {\n                            name: \"name\",\n                            type: ArgumentType.STRING,\n                        },\n                        {\n                            name: \"value\",\n                            type: ArgumentType.ANY,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.NONE,\n                    },\n                },\n                {\n                    is_final: true,\n                    verbose_name: \"  \",\n                    name: \"SetProjectBounds\",\n                    arguments: [\n                        {\n                            name: \"width\",\n                            verbose_name: \"\",\n                            type: ArgumentType.FLOAT,\n                        },\n                        {\n                            name: \"height\",\n                            verbose_name: \"\",\n                            type: ArgumentType.FLOAT,\n                        },\n                        {\n                            name: \"depth\",\n                            verbose_name: \"\",\n                            type: ArgumentType.FLOAT,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.NONE,\n                    },\n                },\n                {\n                    is_final: true,\n                    verbose_name: \"  \",\n                    name: \"SetLDSPEdgesType\",\n                    arguments: [\n                        {\n                            name: \"components\",\n                            type: ArgumentType.DICTIONARY,\n                            settings: {\n                                key: ArgumentType.STRING,\n                                value: ArgumentType.COMPONENT,\n                                value_only: true,\n                            },\n                            is_array: true,\n                            value_only: true,\n                        },\n                        {\n                            name: \"left_edge\",\n                            verbose_name: \"\",\n                            type: ArgumentType.LDSP_EDGE_TYPE,\n                        },\n                        {\n                            name: \"top_edge\",\n                            verbose_name: \"\",\n                            type: ArgumentType.LDSP_EDGE_TYPE,\n                        },\n                        {\n                            name: \"right_edge\",\n                            verbose_name: \"\",\n                            type: ArgumentType.LDSP_EDGE_TYPE,\n                        },\n                        {\n                            name: \"bottom_edge\",\n                            verbose_name: \"\",\n                            type: ArgumentType.LDSP_EDGE_TYPE,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.NONE,\n                    },\n                },\n                {\n                    is_final: true,\n                    verbose_name: \"  \",\n                    name: \"SetLDSPMaterial\",\n                    arguments: [\n                        {\n                            name: \"components\",\n                            type: ArgumentType.DICTIONARY,\n                            settings: {\n                                key: ArgumentType.STRING,\n                                value: ArgumentType.COMPONENT,\n                                value_only: true,\n                            },\n                            is_array: true,\n                            value_only: true,\n                        },\n                        {\n                            name: \"material\",\n                            verbose_name: \"\",\n                            type: ArgumentType.STRING,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.NONE,\n                    },\n                },\n                {\n                    is_final: true,\n                    verbose_name: \"   \",\n                    name: \"SetLDSPElementMaterial\",\n                    arguments: [\n                        {\n                            name: \"components\",\n                            type: ArgumentType.DICTIONARY,\n                            settings: {\n                                key: ArgumentType.STRING,\n                                value: ArgumentType.COMPONENT,\n                                value_only: true,\n                            },\n                            is_array: true,\n                            value_only: true,\n                        },\n                        {\n                            name: \"material\",\n                            verbose_name: \"\",\n                            type: ArgumentType.STRING,\n                        },\n                        {\n                            name: \"back_material\",\n                            verbose_name: \"\",\n                            type: ArgumentType.STRING,\n                        },\n                        {\n                            name: \"left_edge\",\n                            verbose_name: \" \",\n                            type: ArgumentType.STRING,\n                        },\n                        {\n                            name: \"top_edge\",\n                            verbose_name: \" \",\n                            type: ArgumentType.STRING,\n                        },\n                        {\n                            name: \"right_edge\",\n                            verbose_name: \" \",\n                            type: ArgumentType.STRING,\n                        },\n                        {\n                            name: \"bottom_edge\",\n                            verbose_name: \" \",\n                            type: ArgumentType.STRING,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.NONE,\n                    },\n                },\n                {\n                    verbose_name: \"\",\n                    name: \"InvokeEvent\",\n                    color: \"#b26aff\",\n                    arguments: [\n                        {\n                            name: \"name\",\n                            verbose_name: \" \",\n                            type: ArgumentType.STRING,\n                        },\n                        {\n                            name: \"script\",\n                            type: ArgumentType.SCRIPT,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.NONE,\n                    },\n                },\n                {\n                    is_final: true,\n                    verbose_name: \"UV \",\n                    name: \"SetUVTransform\",\n                    arguments: [\n                        {\n                            name: \"components\",\n                            type: ArgumentType.DICTIONARY,\n                            settings: {\n                                key: ArgumentType.STRING,\n                                value: ArgumentType.COMPONENT,\n                                value_only: true,\n                            },\n                            is_array: true,\n                            value_only: true,\n                        },\n                        {\n                            name: \"offset_x\",\n                            verbose_name: \"  X\",\n                            type: ArgumentType.FLOAT,\n                        },\n                        {\n                            name: \"offset_y\",\n                            verbose_name: \"  Y\",\n                            type: ArgumentType.FLOAT,\n                        },\n                        {\n                            name: \"scale_x\",\n                            verbose_name: \"  X\",\n                            type: ArgumentType.FLOAT,\n                        },\n                        {\n                            name: \"scale_y\",\n                            verbose_name: \"  Y\",\n                            type: ArgumentType.FLOAT,\n                        },\n                        {\n                            name: \"rotation\",\n                            verbose_name: \"\",\n                            type: ArgumentType.FLOAT,\n                        },\n                    ],\n                    result: {\n                        type: ArgumentType.NONE,\n                    },\n                },\n            ];\n            this.project = project_1.ProjectFactory.Create(project);\n            this.projectAssembler = new project_assembler_1.ProjectAssembler(this);\n            if (this.related_inputs == null ||\n                Object.keys(this.related_inputs).length == 0) {\n                this.related_inputs = this.project.graph.related_inputs;\n            }\n            this.outputs = {};\n        }\n        PrepareFrontend() {\n            return __awaiter(this, void 0, void 0, function* () {\n                logger_1.Logger.Log(\"Start preparing content\", logger_1.Logger.DebugLevel.INFO);\n                logger_1.Logger.Log(\"MaxTextureSize: \" + this.max_texture_size, logger_1.Logger.DebugLevel.INFO);\n                const builder = new builder_1.ProductBuilder(this);\n                builder.generateRelated = this.has_related;\n                builder.generateInactive = this.generate_inactive;\n                builder.isScene = this.is_scene;\n                logger_1.Logger.Log(\"Starting product build\", logger_1.Logger.DebugLevel.INFO);\n                this.frontend = yield builder.Build();\n                logger_1.Logger.Log(\"Done preparing content\", logger_1.Logger.DebugLevel.INFO);\n            });\n        }\n        GetComponentScale(comp) {\n            const implementation = new project_item_implementation_1.ProjectItemImplementation(comp);\n            const initialComponent = this.projectAssembler.FindComponentByPath(implementation.fullPath);\n            if (initialComponent == null)\n                return math_1.Vector3.one;\n            const scale = comp.size.div(initialComponent.size);\n            if (scale.isZero() || !scale.isFinite())\n                return math_1.Vector3.one;\n            return scale;\n        }\n        PrepareOutputNodes(nodes) {\n            const final_nodes = [];\n            let zero_ordered_nodes = nodes.filter((n) => n.order == 0);\n            for (let i in zero_ordered_nodes) {\n                if (zero_ordered_nodes[i].order == 0)\n                    zero_ordered_nodes[i].order = Number(i);\n            }\n            for (let node of nodes) {\n                const func = this.Blocks.find((b) => b.name === node.method.name);\n                if (func.is_final !== true)\n                    continue;\n                if (node.method.result.type != ArgumentType.NONE) {\n                    if (nodes.find((n) => n.method.HasConnectionTo(node.guid)) != null)\n                        continue;\n                }\n                final_nodes.push(node);\n            }\n            final_nodes.sort((n1, n2) => {\n                if (n1.order <= n2.order)\n                    return -1;\n                return 1;\n            });\n            return final_nodes;\n        }\n        UpdateInputs() {\n            for (const input of this.inputs) {\n                if (\"min\" in input.settings) {\n                    if (input.value < input.settings.min)\n                        input.value = input.settings.min;\n                }\n                if (\"max\" in input.settings) {\n                    if (input.value > input.settings.max)\n                        input.value = input.settings.max;\n                }\n            }\n        }\n        UpdateOutputs() {\n            if (this.project.graph.outputs == null) {\n                this.project.graph.outputs = [];\n                this.outputs = [];\n                return;\n            }\n            for (let output of this.project.graph.outputs) {\n                if (output == null)\n                    continue;\n                if (output.tag != null && output.tag != \"\") {\n                    const tagged_input = this.project.graph.inputs.find(function (i) {\n                        return i.settings.tag == output.tag;\n                    });\n                    if (tagged_input != null) {\n                        output.value = tagged_input.value;\n                        continue;\n                    }\n                }\n                if (this.outputs[output.name] != undefined)\n                    output.value = this.outputs[output.name];\n            }\n            this.outputs = this.project.graph.outputs;\n        }\n        static GetSlotComponent(parentAssembler, childAssembler, sourceComponent) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (sourceComponent.modifier.type != enums_1.ProjectComponentModifierType.BUILTIN)\n                    return null;\n                const modifier = sourceComponent.modifier;\n                const targetSlot = modifier.target_slot;\n                if (targetSlot != null && targetSlot != \"\") {\n                    const foundComponent = childAssembler.FindComponentByPath(targetSlot);\n                    if (foundComponent == null)\n                        return null;\n                    if (foundComponent.modifier.type != enums_1.ProjectComponentModifierType.BUILTIN)\n                        return null;\n                    return foundComponent;\n                }\n                let category = modifier.category;\n                if (category == null || category == 0) {\n                    if (parentAssembler.targetProject.guid != null) {\n                        const stat = yield filesystem_1.Filesystem.Get(\"api/Calculation/GetCalculationStat?guid=\" + parentAssembler.targetProject.guid);\n                        category = stat.category;\n                    }\n                }\n                return childAssembler.targetProject.components.find((c) => {\n                    if (c.modifier.type != enums_1.ProjectComponentModifierType.BUILTIN)\n                        return false;\n                    const modifier = c.modifier;\n                    if (modifier.category == null)\n                        modifier.category = 0;\n                    if ((category == null || category == 0) && modifier.category != 0)\n                        return false;\n                    return modifier.category == category;\n                });\n            });\n        }\n        CalculateRelated(comp) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (comp.modifier.type != enums_1.ProjectComponentModifierType.BUILTIN)\n                    return null;\n                const modifier = comp.modifier;\n                if (modifier.related_project == null || modifier.related_project == \"\")\n                    return null;\n                const projectGuid = modifier.related_project.replace(\"s123calc://\", \"\");\n                const calcStat = yield filesystem_1.Filesystem.Get(\"api/Calculation/GetCalculationStat?guid=\" + projectGuid);\n                if (calcStat == null) {\n                    logger_1.Logger.Log(\"   \" + projectGuid, DebugLevel.ERROR);\n                    return null;\n                }\n                const projectData = yield filesystem_1.Filesystem.GetFile(`s123://calculationResults/${projectGuid}/${calcStat.projectFileName}`);\n                const childIIK = new IIKCore(projectData);\n                childIIK.inputs = null;\n                childIIK.related_inputs = null;\n                childIIK.project.guid = projectGuid;\n                childIIK.has_frontend = this.has_frontend;\n                childIIK.max_texture_size = this.max_texture_size;\n                childIIK.is_detailed_materials = this.is_detailed_materials;\n                childIIK.parent_project = this.project;\n                childIIK.platform = this.platform;\n                childIIK.is_web_ar_active = this.is_web_ar_active;\n                childIIK.is_web_pbr_extras_active = this.is_web_pbr_extras_active;\n                if (this.related_inputs != null && comp.guid in this.related_inputs) {\n                    childIIK.project.graph.inputs = this.related_inputs[comp.guid];\n                    //const childInputs: GraphInput[] = childIIK.project.graph.inputs;\n                    //let notFound = arraysMatchUnorderedBy( this.related_inputs[comp.guid], childInputs, (a : GraphInput,b : GraphInput) => a.guid == b.guid );\n                    //if (notFound)\n                    //  this.related_inputs[comp.guid] = childIIK.project.graph.inputs;\n                    //else {\n                    //  for (let i = 0; i < childInputs.length; i++) {\n                    //    const relatedInput = this.related_inputs[comp.guid].find(\n                    //      (input: GraphInput) => input.guid == childInputs[i].guid,\n                    //    );\n                    //    if( relatedInput == null ) continue;\n                    //    const oldInput = childInputs[i];\n                    //    childInputs[i] = relatedInput;\n                    //    childInputs[i].settings.tag = oldInput.settings.tag;\n                    //  }\n                    //}\n                }\n                const slotComponent = yield IIKCore.GetSlotComponent(this.projectAssembler, childIIK.projectAssembler, comp);\n                if (slotComponent != null) {\n                    const slotComponentFullPath = new project_component_implementation_1.ProjectComponentImplementation(childIIK.projectAssembler, slotComponent).fullPath;\n                    for (const childNode of childIIK.project.graph.nodes) {\n                        if (childNode.method.name != \"SetComponentsFields\")\n                            continue;\n                        const componentsArgument = childNode.method.arguments.find(arg => arg.name == \"components\");\n                        const fieldsArgument = childNode.method.arguments.find(arg => arg.name == \"fields\");\n                        if (componentsArgument != null && fieldsArgument != null &&\n                            fieldsArgument.value.some((pair) => pair.value == \"size.x\" ||\n                                pair.value == \"size.y\" ||\n                                pair.value == \"size.z\" ||\n                                pair.value == \"material\")) {\n                            componentsArgument.value = componentsArgument.value.filter((pair) => {\n                                return pair.value != slotComponentFullPath;\n                            });\n                        }\n                    }\n                    slotComponent.size = comp.size;\n                    slotComponent.material = comp.material;\n                    const slotModifier = slotComponent.modifier;\n                    slotModifier.related_project = \"\";\n                }\n                if (this.related_event != null && this.related_event.guid == comp.guid) {\n                    yield childIIK.Invoke(this.related_event.name, this.related_event.value);\n                    this.related_event = null;\n                }\n                yield childIIK.Calculate();\n                if (this.related_inputs == null)\n                    this.related_inputs = {};\n                this.related_inputs[comp.guid] = childIIK.inputs;\n                comp.size = childIIK.projectAssembler.GetProjectBounds().size.mult(1000.0);\n                return childIIK;\n            });\n        }\n        UpdateComponentsSize() {\n            return __awaiter(this, void 0, void 0, function* () {\n                var _a;\n                for (let comp of this.project.components) {\n                    if (comp.modifier.type == enums_1.ProjectComponentModifierType.ARRAY) {\n                        const modifier = comp.modifier;\n                        if (modifier.child == null)\n                            continue;\n                        const bounds = new math_1.Bounds();\n                        const child_size = ((_a = this.projectAssembler.GetComponentBounds(modifier.child)) !== null && _a !== void 0 ? _a : new math_1.Bounds()).size;\n                        const offset = new math_1.Vector3(modifier.offset).div(1000.0);\n                        for (let i = 0; i < modifier.count; i++) {\n                            let pos = offset\n                                .mult(i)\n                                .sub(offset.mult(modifier.count - 1).div(2.0));\n                            bounds.encapsulate(math_1.Bounds.fromCenterAndSize(pos, child_size));\n                        }\n                        comp.size = bounds.size.mult(1000.0);\n                    }\n                    else if (comp.modifier.type == enums_1.ProjectComponentModifierType.SHAPE) {\n                        const modifier = comp.modifier;\n                        if (modifier.shape == null || modifier.shape == \"\")\n                            continue;\n                        const implementation = new project_component_implementation_1.ProjectComponentImplementation(this.projectAssembler, comp);\n                        const shape = yield implementation.GetShape();\n                        if (shape == null)\n                            continue;\n                        const shape_size = shape_1.Shape.GetShapeSize(shape);\n                        if (modifier.radius == undefined || modifier.radius == 0) {\n                            if (shape_size.x != null && shape_size.y != null) {\n                                comp.size = new math_1.Vector3(shape_size.x * 1000.0, comp.size.y, shape_size.y * 1000.0);\n                            }\n                        }\n                        else {\n                            const angle1 = (modifier.start_angle / 180.0) * Math.PI;\n                            const angle2 = (modifier.end_angle / 180.0) * Math.PI;\n                            const dangle = ((modifier.start_angle +\n                                (modifier.end_angle - modifier.start_angle) / 2.0) /\n                                180.0) *\n                                Math.PI;\n                            const v1 = new math_1.Vector2(Math.cos(angle1), Math.sin(angle1)).mult(modifier.radius);\n                            const v2 = new math_1.Vector2(Math.cos(angle2), Math.sin(angle2)).mult(modifier.radius);\n                            const v3 = new math_1.Vector2(Math.cos(dangle), Math.sin(dangle)).mult(modifier.radius);\n                            const min = new math_1.Vector2(Math.min(v1.x, v2.x, v3.x), Math.min(v1.y, v2.y, v3.y));\n                            const max = new math_1.Vector2(Math.max(v1.x, v2.x, v3.x), Math.max(v1.y, v2.y, v3.y));\n                            comp.size.x = max.x - min.x;\n                            comp.size.y = max.y - min.y;\n                            if (modifier.depth != null && modifier.depth != 0)\n                                comp.size.z = modifier.depth;\n                        }\n                    }\n                    else if (comp.modifier.type == enums_1.ProjectComponentModifierType.LDSP) {\n                        const modifier = comp.modifier;\n                        modifier.real_size = new math_1.Vector3(comp.size);\n                        if (modifier.edges[0].type == enums_1.LDSPEdgeType.MM2)\n                            modifier.real_size.x -= 2;\n                        if (modifier.edges[2].type == enums_1.LDSPEdgeType.MM2)\n                            modifier.real_size.x -= 2;\n                        if (modifier.edges[1].type == enums_1.LDSPEdgeType.MM2)\n                            modifier.real_size.y -= 2;\n                        if (modifier.edges[3].type == enums_1.LDSPEdgeType.MM2)\n                            modifier.real_size.y -= 2;\n                        {\n                            modifier.edges[0].size = new math_1.Vector3();\n                            modifier.edges[0].size.x = comp.size.z;\n                            modifier.edges[0].size.y = comp.size.y;\n                            modifier.edges[0].size.z = 0;\n                            if (modifier.edges[0].type == enums_1.LDSPEdgeType.MM04)\n                                modifier.edges[0].size.z = 0.4;\n                            else if (modifier.edges[0].type == enums_1.LDSPEdgeType.MM2)\n                                modifier.edges[0].size.z = 2;\n                        }\n                        {\n                            modifier.edges[2].size = new math_1.Vector3();\n                            modifier.edges[2].size.x = comp.size.z;\n                            modifier.edges[2].size.y = comp.size.y;\n                            modifier.edges[2].size.z = 0;\n                            if (modifier.edges[2].type == enums_1.LDSPEdgeType.MM04)\n                                modifier.edges[2].size.z = 0.4;\n                            else if (modifier.edges[2].type == enums_1.LDSPEdgeType.MM2)\n                                modifier.edges[2].size.z = 2;\n                        }\n                        {\n                            modifier.edges[1].size = new math_1.Vector3();\n                            modifier.edges[1].size.x = comp.size.z;\n                            // noinspection JSSuspiciousNameCombination\n                            modifier.edges[1].size.y = comp.size.x;\n                            modifier.edges[1].size.z = 0;\n                            if (modifier.edges[1].type == enums_1.LDSPEdgeType.MM04)\n                                modifier.edges[1].size.z = 0.4;\n                            else if (modifier.edges[1].type == enums_1.LDSPEdgeType.MM2)\n                                modifier.edges[1].size.z = 2;\n                        }\n                        {\n                            modifier.edges[3].size = new math_1.Vector3();\n                            modifier.edges[3].size.x = comp.size.z;\n                            // noinspection JSSuspiciousNameCombination\n                            modifier.edges[3].size.y = comp.size.x;\n                            modifier.edges[3].size.z = 0;\n                            if (modifier.edges[3].type == enums_1.LDSPEdgeType.MM04)\n                                modifier.edges[3].size.z = 0.4;\n                            else if (modifier.edges[3].type == enums_1.LDSPEdgeType.MM2)\n                                modifier.edges[3].size.z = 2;\n                        }\n                    }\n                    else if (comp.modifier.type == enums_1.ProjectComponentModifierType.BUILTIN) {\n                        const relatedCalculation = this.related_calculations[comp.guid];\n                        if (relatedCalculation != null) {\n                            comp.size = relatedCalculation.projectAssembler.GetProjectBounds().size.mult(1000.0);\n                        }\n                    }\n                }\n            });\n        }\n        PrepareRelatedInputs() {\n            //if( this.related_inputs == null )\n            //    this.related_inputs = this.project.graph.related_inputs;\n            //else\n            //    this.project.graph.related_inputs = this.related_inputs;\n            //\n            //for( let key in this.related_inputs )\n            //{\n            //    const comp = this.project.components.find( ( c : ProjectComponent ) => c.guid == key );\n            //    if( comp == null )\n            //    {\n            //        delete this.related_inputs[key];\n            //        continue;\n            //    }\n            //    if( comp.modifier.show_inputs == false )\n            //        delete this.related_inputs[key];\n            //}\n            this.related_inputs = {};\n            for (let comp of this.project.components) {\n                if (comp.modifier.type != enums_1.ProjectComponentModifierType.BUILTIN)\n                    continue;\n                const modifier = comp.modifier;\n                if (modifier.related_project == null ||\n                    modifier.related_project == \"\")\n                    continue;\n                if (!modifier.show_inputs)\n                    continue;\n                if (comp.guid in this.related_calculations) {\n                    this.related_inputs[comp.guid] =\n                        this.related_calculations[comp.guid].project.graph.inputs;\n                }\n            }\n            this.project.graph.related_inputs = this.related_inputs;\n        }\n        CalculateNodes() {\n            return __awaiter(this, void 0, void 0, function* () {\n                this.out_nodes = this.PrepareOutputNodes(this.project.graph.nodes);\n                if (this.project.graph.is_active == undefined || this.project.graph.is_active) {\n                    for (const n of this.out_nodes)\n                        yield this.InvokeMethod(n.method);\n                }\n            });\n        }\n        Calculate() {\n            return __awaiter(this, arguments, void 0, function* (callback = null) {\n                if (this.project.guid != null) {\n                    const stat = yield filesystem_1.Filesystem.Get(\"api/Calculation/GetCalculationStat?guid=\" + this.project.guid);\n                    if (stat != null && stat.idCalculationType != null) {\n                        this.is_scene = stat.idCalculationType == 1;\n                    }\n                }\n                this.method_cache = {};\n                logger_1.Logger.Log(\"Calculation started\", logger_1.Logger.DebugLevel.INFO);\n                Log(\"Preparing inputs\", DebugLevel.INFO);\n                yield this.PrepareInputs();\n                Log(\"Done preparing inputs\", DebugLevel.INFO);\n                logger_1.Logger.Log(\"Preparing materials\", logger_1.Logger.DebugLevel.INFO);\n                //await this.PrepareMaterials();\n                logger_1.Logger.Log(\"Processing nodes\", logger_1.Logger.DebugLevel.INFO);\n                yield this.CalculateNodes();\n                logger_1.Logger.Log(\"Updating inputs\", logger_1.Logger.DebugLevel.INFO);\n                this.UpdateInputs();\n                logger_1.Logger.Log(\"Updating outputs\", logger_1.Logger.DebugLevel.INFO);\n                this.UpdateOutputs();\n                if (!this.is_scene)\n                    this.related_calculations = {};\n                this.related_names = {};\n                logger_1.Logger.Log(\"Calculating related projects\", logger_1.Logger.DebugLevel.INFO);\n                yield (0, utils_1.iterateAsync)(this.project.components, (comp) => __awaiter(this, void 0, void 0, function* () {\n                    if (comp.modifier.type != enums_1.ProjectComponentModifierType.BUILTIN)\n                        return;\n                    if (comp.modifier.related_project == null ||\n                        comp.modifier.related_project == \"\")\n                        return;\n                    if (!this.is_scene) {\n                        this.related_calculations[comp.guid] = yield this.CalculateRelated(comp);\n                        if (this.related_calculations[comp.guid] != null)\n                            this.related_names[comp.guid] = comp.name;\n                    }\n                    else {\n                        if (!(comp.guid in this.related_calculations)) {\n                            this.related_calculations[comp.guid] = yield this.CalculateRelated(comp);\n                        }\n                        else {\n                            let child_iik = this.related_calculations[comp.guid];\n                            if (child_iik != null) {\n                                if (this.related_inputs != null && comp.guid in this.related_inputs) {\n                                    let not_found = false;\n                                    for (let ri of this.related_inputs[comp.guid]) {\n                                        if (child_iik.project.graph.inputs.find(function (i) {\n                                            return i.guid == ri.guid;\n                                        }) == null) {\n                                            not_found = true;\n                                            break;\n                                        }\n                                    }\n                                    if (not_found)\n                                        this.related_inputs[comp.guid] = child_iik.project.graph.inputs;\n                                    else {\n                                        const child_inputs = child_iik.project.graph.inputs;\n                                        for (let i = 0; i < child_inputs.length; i++) {\n                                            const related_input = this.related_inputs[comp.guid].find((inp) => inp.guid == child_inputs[i].guid);\n                                            if (related_input != null) {\n                                                const old_input = child_inputs[i];\n                                                child_inputs[i] = related_input;\n                                                child_inputs[i].settings.tag = old_input.settings.tag;\n                                            }\n                                        }\n                                    }\n                                }\n                                yield child_iik.Calculate();\n                            }\n                        }\n                    }\n                }), this.platform);\n                if (Object.values(this.related_calculations).some((c) => c.need_parent_recalculate))\n                    yield this.CalculateNodes();\n                logger_1.Logger.Log(\"Updating components size\", logger_1.Logger.DebugLevel.INFO);\n                yield this.UpdateComponentsSize();\n                logger_1.Logger.Log(\"Assembling project\", logger_1.Logger.DebugLevel.INFO);\n                this.projectAssembler.Assemble(!this.is_scene);\n                if (this.has_frontend)\n                    yield this.PrepareFrontend();\n                logger_1.Logger.Log(\"Updating inputs and outputs\", logger_1.Logger.DebugLevel.INFO);\n                this.inputs = this.project.graph.inputs;\n                this.PrepareRelatedInputs();\n                this.is_active = this.project.graph.is_active;\n                let articleOutput = this.project.graph.outputs.find((o) => o.type == GraphOutputType.ARTICLE);\n                if (articleOutput != null) {\n                    const calculationStat = yield filesystem_1.Filesystem.Get(\"api/Calculation/GetCalculationStat?guid=\" + this.project.guid);\n                    articleOutput.value = calculationStat.article;\n                }\n                logger_1.Logger.Log(\"Calculation done\", logger_1.Logger.DebugLevel.INFO);\n                if (callback != null) {\n                    callback();\n                    logger_1.Logger.Log(\"Callback is done processing\", logger_1.Logger.DebugLevel.INFO);\n                }\n            });\n        }\n        SetInputValue(input_name, value) {\n            if (this.inputs != null) {\n                for (const i of this.inputs) {\n                    if (i.name === input_name)\n                        i.value = value;\n                }\n            }\n            for (const i of this.project.graph.inputs) {\n                if (i.name === input_name)\n                    i.value = value;\n            }\n        }\n        Detail(detail_name) {\n            const result = this.project.components.find((c) => c.name == detail_name);\n            if (result == undefined)\n                logger_1.Logger.Log(\"   \", DebugLevel.ERROR);\n            return result;\n        }\n        DetailFace(componentName, targetFaces) {\n            const component = this.Detail(componentName);\n            if (component == null)\n                return;\n            const modifier = component.modifier;\n            modifier.target_faces = targetFaces;\n        }\n        Input(input_name) {\n            const result = this.project.graph.inputs.find((i) => i.name == input_name);\n            if (result == undefined)\n                logger_1.Logger.Log(\"   \", DebugLevel.ERROR);\n            return result;\n        }\n        PPoint(point_name) {\n            const components = this.project.components;\n            if (components == undefined) {\n                logger_1.Logger.Log(\"      \", DebugLevel.ERROR);\n                return components;\n            }\n            let result = undefined;\n            for (let component of this.project.components) {\n                result = component.positioning_points.find((pp) => pp.name == point_name);\n                if (result != undefined)\n                    return result;\n            }\n            logger_1.Logger.Log(\"   \", DebugLevel.ERROR);\n            return result;\n        }\n        GetMaterialData(guidOrUrl) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let targetUrl = guidOrUrl;\n                if (!targetUrl.startsWith(\"s123://\") && !targetUrl.startsWith(\"s123mat://\"))\n                    targetUrl = \"s123mat://\" + targetUrl;\n                return Material.GetByDirectLink(targetUrl, this.project.guid);\n            });\n        }\n        Invoke(event_name, value) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const event = this.project.graph.nodes.find(function (node) {\n                    if (node.method.name !== \"InvokeEvent\")\n                        return false;\n                    const name_arg = node.method.arguments.find(function (a) {\n                        return a.name === \"name\";\n                    });\n                    return name_arg.value == event_name;\n                });\n                if (event == null)\n                    return;\n                let script = yield this.GetValue(event.method.arguments.find(function (a) {\n                    return a.name === \"script\";\n                }));\n                if (isNaN(Number(value)))\n                    value = '\"' + value + '\"';\n                script = \"var value=\" + value + \";\\n\" + IIKCore.UpdateOldScript(script);\n                new Function(script).call(this);\n            });\n        }\n        InvokeScript(script) {\n            new Function(script).call(this);\n        }\n    }\n    IIKCore.DefaultLDSPMaterial = \"s123mat://b1e0b85e-c613-452f-8b49-0b0dc89d3543\";\n    IIKCore.DefaultLDSPCutMaterial = \"s123mat://93d343ca-ce11-4614-a0bb-50f5ff65fe96\";\n    IIK.IIKCore = IIKCore;\n})(IIK || (exports.IIK = IIK = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProductFactory = exports.ProjectFactory = exports.Graph = exports.MaterialCore = exports.Filesystem = exports.Logger = exports.Generator = exports.IIK = void 0;\nconst iik_1 = require(\"./iik\");\nObject.defineProperty(exports, \"IIK\", { enumerable: true, get: function () { return iik_1.IIK; } });\nconst generator_1 = require(\"./MeshUtils/generator\");\nObject.defineProperty(exports, \"Generator\", { enumerable: true, get: function () { return generator_1.Generator; } });\nconst logger_1 = require(\"./logger\");\nObject.defineProperty(exports, \"Logger\", { enumerable: true, get: function () { return logger_1.Logger; } });\nconst filesystem_1 = require(\"./filesystem\");\nObject.defineProperty(exports, \"Filesystem\", { enumerable: true, get: function () { return filesystem_1.Filesystem; } });\nconst material_1 = require(\"./material\");\nObject.defineProperty(exports, \"MaterialCore\", { enumerable: true, get: function () { return material_1.MaterialCore; } });\nconst graph_1 = require(\"./graph\");\nObject.defineProperty(exports, \"Graph\", { enumerable: true, get: function () { return graph_1.Graph; } });\nconst project_1 = require(\"./Project/DTOs/project\");\nObject.defineProperty(exports, \"ProjectFactory\", { enumerable: true, get: function () { return project_1.ProjectFactory; } });\nconst product_1 = require(\"./Product/product\");\nObject.defineProperty(exports, \"ProductFactory\", { enumerable: true, get: function () { return product_1.ProductFactory; } });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Logger = void 0;\nvar Logger;\n(function (Logger) {\n    let DebugLevel;\n    (function (DebugLevel) {\n        DebugLevel[DebugLevel[\"NONE\"] = -1] = \"NONE\";\n        DebugLevel[DebugLevel[\"ERROR\"] = 0] = \"ERROR\";\n        DebugLevel[DebugLevel[\"WARNING\"] = 1] = \"WARNING\";\n        DebugLevel[DebugLevel[\"INFO\"] = 2] = \"INFO\";\n        DebugLevel[DebugLevel[\"VERBOSE\"] = 3] = \"VERBOSE\";\n    })(DebugLevel = Logger.DebugLevel || (Logger.DebugLevel = {}));\n    Logger.debug = DebugLevel.NONE;\n    //export let debug = DebugLevel.VERBOSE;\n    //export let debug = DebugLevel.INFO;\n    Logger.externalLog = console.log;\n    Logger.Log = function (data, level) {\n        if (level > Logger.debug)\n            return;\n        if (data instanceof Error) {\n            Logger.externalLog(data.stack);\n        }\n        else if (typeof data === \"string\") {\n            Logger.externalLog(data);\n        }\n        else {\n            Logger.externalLog(JSON.stringify(data));\n        }\n    };\n})(Logger || (exports.Logger = Logger = {}));\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MaterialCore = void 0;\nconst changeable_1 = require(\"./Core/changeable\");\nconst filesystem_1 = require(\"./filesystem\");\nconst logger_1 = require(\"./logger\");\nconst math_1 = require(\"./math\");\nconst DebugLevel = logger_1.Logger.DebugLevel;\nvar MaterialCore;\n(function (MaterialCore) {\n    var Cacheable = filesystem_1.Filesystem.Cacheable;\n    let MaterialTemplate;\n    (function (MaterialTemplate) {\n        MaterialTemplate[MaterialTemplate[\"NONE\"] = 0] = \"NONE\";\n        MaterialTemplate[MaterialTemplate[\"TILE\"] = 1] = \"TILE\";\n        MaterialTemplate[MaterialTemplate[\"WALLPAPER\"] = 2] = \"WALLPAPER\";\n        MaterialTemplate[MaterialTemplate[\"PLASTER\"] = 3] = \"PLASTER\";\n        MaterialTemplate[MaterialTemplate[\"WOOD\"] = 4] = \"WOOD\";\n        MaterialTemplate[MaterialTemplate[\"CLOTH\"] = 5] = \"CLOTH\";\n    })(MaterialTemplate = MaterialCore.MaterialTemplate || (MaterialCore.MaterialTemplate = {}));\n    class Texture extends changeable_1.Changeable {\n        constructor() {\n            super(...arguments);\n            this.fileName = \"\";\n            this.resolution = new math_1.Vector2(2048, 2048);\n            this.realSize = undefined;\n        }\n    }\n    MaterialCore.Texture = Texture;\n    class WebMaterialParams extends changeable_1.Changeable {\n        constructor() {\n            super(...arguments);\n            this.lightMapIntensity = 1;\n            this.envMapIntensity = 1;\n            this.aoMapIntensity = 1;\n            this.transparent = false;\n            this.alphaTest = 0;\n            this.depthTest = true;\n            this.depthWrite = true;\n            this.side = \"FrontSide\";\n        }\n    }\n    MaterialCore.WebMaterialParams = WebMaterialParams;\n    let UEMaterialType;\n    (function (UEMaterialType) {\n        UEMaterialType[UEMaterialType[\"OPAQUE\"] = 1] = \"OPAQUE\";\n        UEMaterialType[UEMaterialType[\"TRANSPARENT\"] = 2] = \"TRANSPARENT\";\n        UEMaterialType[UEMaterialType[\"MASK\"] = 3] = \"MASK\";\n        UEMaterialType[UEMaterialType[\"MASK_DOUBLESIDED\"] = 4] = \"MASK_DOUBLESIDED\";\n        UEMaterialType[UEMaterialType[\"CLOTH_DOUBLESIDED\"] = 5] = \"CLOTH_DOUBLESIDED\";\n        UEMaterialType[UEMaterialType[\"GLASS_NOREFRACTION\"] = 6] = \"GLASS_NOREFRACTION\";\n        UEMaterialType[UEMaterialType[\"GLASS_REFRACTION\"] = 7] = \"GLASS_REFRACTION\";\n    })(UEMaterialType || (UEMaterialType = {}));\n    class Color extends changeable_1.Changeable {\n        constructor() {\n            super(...arguments);\n            this.r = 1;\n            this.g = 1;\n            this.b = 1;\n            this.a = 1;\n        }\n    }\n    MaterialCore.Color = Color;\n    class UEMaterialParams extends changeable_1.Changeable {\n        constructor() {\n            super(...arguments);\n            this.metallicIntensity = 1;\n            this.roughnessIntensity = 1;\n            this.emissiveIntensity = 1;\n            this.normalIntensity = 1;\n            this.displacement = new Texture();\n            this.displacementIntensity = 1;\n            this.hue = new Color();\n            this.type = UEMaterialType.OPAQUE;\n        }\n    }\n    MaterialCore.UEMaterialParams = UEMaterialParams;\n    class Material extends Cacheable {\n        constructor() {\n            super();\n            this.guid = \"\";\n            this.name = \"\";\n            this.ao = new Texture();\n            this.aoValue = 1;\n            this.diffuse = new Texture();\n            this.color = \"#ffffff\";\n            this.metallic = new Texture();\n            this.metallicValue = 1;\n            this.normal = new Texture();\n            this.normalValue = 1;\n            this.roughness = new Texture();\n            this.roughnessValue = 1;\n            this.emissive = new Texture();\n            this.emissiveColor = \"#000000\";\n            this.sheenValue = 0;\n            this.sheenRoughness = new Texture();\n            this.sheenRoughnessValue = 1;\n            this.sheenColor = new Texture();\n            this.sheenColorValue = \"#ffffff\";\n            this.alpha = new Texture();\n            this.opacity = 1;\n            this.transmission = new Texture();\n            this.transmissionValue = 0;\n            this.dispersion = 0;\n            this.ior = 1.5;\n            this.attenuationDistance = Infinity;\n            this.attenuationColor = \"#ffffff\";\n            this.realSize = new math_1.Vector2(1, 1);\n            this.isMask = false;\n            this.renderFace = \"front\";\n            this.previewColor = \"\";\n            this.category = \"\";\n            this.bake = \"\";\n            this.isDetailed = false;\n            this.maxResolution = 512;\n            this.web = new WebMaterialParams();\n            this.ue = new UEMaterialParams();\n            this.compressedTextures = undefined;\n            this.webAr = \"\";\n            this.webPbr = \"\";\n            this.preset = \"\";\n        }\n        GetHashableData() {\n            let newMaterial = new Material();\n            newMaterial.UpdateFrom(this);\n            delete newMaterial.hash;\n            delete newMaterial.isDirty;\n            return JSON.stringify(newMaterial);\n        }\n        GetAllTextures() {\n            const result = [];\n            const keys = Object.keys(this);\n            for (const key of keys) {\n                if (typeof this[key] == \"object\" &&\n                    this[key] instanceof Texture)\n                    result.push(this[key]);\n            }\n            return result;\n        }\n        ConvertToNew(data) {\n            const keys = Object.keys(this);\n            for (const key of keys) {\n                if (data.hasOwnProperty(key)) {\n                    if (typeof this[key] == \"object\" &&\n                        this[key] instanceof Texture) {\n                        if (typeof data[key] == \"string\") {\n                            const url = data[key];\n                            data[key] = new Texture();\n                            data[key].fileName = url;\n                            if (data.real_size != null && data.real_size[key] != null)\n                                data[key].realSize = data.real_size[key];\n                        }\n                    }\n                }\n            }\n            if (data.real_size != null && data.real_size.default != null)\n                data.realSize = data.real_size.default;\n            return data;\n        }\n        static GetByDirectLink(url_1) {\n            return __awaiter(this, arguments, void 0, function* (url, guid = \"\") {\n                var _a;\n                if (url + guid in Material.cachedMaterials) {\n                    return Material.cachedMaterials[url + guid];\n                }\n                let materialName = \"\";\n                let materialFilePath = \"\";\n                let targetGuid = guid;\n                if (url.startsWith(\"s123://\")) {\n                    materialFilePath = url;\n                    materialName = (_a = materialFilePath.split(\"/\").pop()) !== null && _a !== void 0 ? _a : \"\";\n                }\n                else {\n                    const guid = url.replace(\"s123mat://\", \"\");\n                    targetGuid = guid;\n                    const calc_stat = yield filesystem_1.Filesystem.Get(\"api/Calculation/GetCalculationStat?guid=\" + guid);\n                    if (calc_stat == null) {\n                        logger_1.Logger.Log(\"   \" + guid, DebugLevel.ERROR);\n                        Material.cachedMaterials[url + guid] = Material.DefaultMaterial;\n                        return Material.DefaultMaterial;\n                    }\n                    materialName = calc_stat.name;\n                    materialFilePath = `s123://calculationResults/${guid}/${calc_stat.projectFileName}`;\n                }\n                const material = yield filesystem_1.Filesystem.GetFile(materialFilePath);\n                if (material == null) {\n                    logger_1.Logger.Log(\"   \" + materialFilePath, DebugLevel.ERROR);\n                    Material.cachedMaterials[url + guid] = Material.DefaultMaterial;\n                    return Material.DefaultMaterial;\n                }\n                const result = Material.GetByData(material, targetGuid);\n                result.name = materialName;\n                Material.cachedMaterials[url + guid] = result;\n                return result;\n            });\n        }\n        static GetByData(data, guid) {\n            const result = new Material();\n            result.guid = guid;\n            const updated_data = result.ConvertToNew(data);\n            result.UpdateFrom(updated_data);\n            for (let t of result.GetAllTextures()) {\n                if (t.realSize == null)\n                    t.realSize = result.realSize;\n            }\n            return result;\n        }\n        GetDirectTextureLink(filename, maxSize, crop) {\n            logger_1.Logger.Log(\"Preparing direct texture link\", DebugLevel.VERBOSE);\n            logger_1.Logger.Log(\"GUID: \" + this.guid, DebugLevel.VERBOSE);\n            logger_1.Logger.Log(\"filename: \" + filename, DebugLevel.VERBOSE);\n            if (this.guid == null || this.guid == \"\")\n                return filename;\n            let result = `calculationResults/${this.guid}/${filename}`;\n            if (maxSize != 0) {\n                if (!crop)\n                    result += `&maxSize=${maxSize}`;\n                else\n                    result += `&cropSize=${maxSize}`;\n            }\n            return result;\n        }\n        PrepareForContent() {\n            const keys = Object.keys(this);\n            for (const key of keys) {\n                if (typeof this[key] == \"object\" &&\n                    this[key] instanceof Texture) {\n                    if (this[key].fileName == \"\" ||\n                        this[key].fileName == null) {\n                        delete this[key];\n                        continue;\n                    }\n                    delete this[key].resolution;\n                }\n                if (this[key] == null)\n                    delete this[key];\n            }\n        }\n        GenerateInternal() {\n            let maxMaterialResolution = 0;\n            for (let t of this.GetAllTextures()) {\n                if (t.resolution == null)\n                    t.resolution = new math_1.Vector2(this.maxResolution, this.maxResolution);\n                if (t.resolution.x > maxMaterialResolution)\n                    maxMaterialResolution = t.resolution.x;\n            }\n            let aspect = 1;\n            if (maxMaterialResolution > this.maxResolution)\n                aspect = this.maxResolution / maxMaterialResolution;\n            for (let t of this.GetAllTextures()) {\n                t.resolution = t.resolution.mult(aspect);\n                if (t.fileName != null && t.fileName != \"\")\n                    t.fileName = this.GetDirectTextureLink(t.fileName, t.resolution.x, this.isDetailed);\n                if (this.isDetailed)\n                    t.realSize = new math_1.Vector2(t.realSize).mult(aspect);\n            }\n            if (this.isDetailed)\n                this.realSize = this.realSize.mult(aspect);\n            this.PrepareForContent();\n        }\n        static GetFromTemplate(template) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let guid = \"\";\n                switch (template) {\n                    case MaterialTemplate.NONE:\n                        return new Material();\n                    case MaterialTemplate.TILE:\n                        guid = \"ca413a2e-a948-430b-a6e6-54f489595128\";\n                        break;\n                    case MaterialTemplate.WALLPAPER:\n                        guid = \"712da9b3-6414-4a08-9293-a2d568f7a43c\";\n                        break;\n                    case MaterialTemplate.PLASTER:\n                        guid = \"c4b323d0-ca53-42d1-a8ec-b34d274b47fb\";\n                        break;\n                    case MaterialTemplate.WOOD:\n                        guid = \"f449c695-5d32-430e-8819-0f8cb08da0c7\";\n                        break;\n                    case MaterialTemplate.CLOTH:\n                        guid = \"2999715f-dabc-4021-ba83-f7d307769c67\";\n                        break;\n                    default:\n                        logger_1.Logger.Log(\"Unknown material template\", DebugLevel.ERROR);\n                        return new Material();\n                }\n                return yield Material.GetByDirectLink(\"s123mat://\" + guid);\n            });\n        }\n        static CreateMaterial(name_1, template_1, diffuse_file_1, resolution_1) {\n            return __awaiter(this, arguments, void 0, function* (name, template, diffuse_file, resolution, real_size = new math_1.Vector2(1, 1), callback) {\n                const result = yield Material.GetFromTemplate(template);\n                result.diffuse.fileName = diffuse_file;\n                result.diffuse.realSize = real_size;\n                result.diffuse.resolution = new math_1.Vector2(resolution);\n                result.guid = \"\";\n                result.name = name;\n                if (callback != null)\n                    callback(result);\n                return result;\n            });\n        }\n    }\n    Material.DefaultMaterial = new Material();\n    Material.cachedMaterials = {};\n    MaterialCore.Material = Material;\n})(MaterialCore || (exports.MaterialCore = MaterialCore = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Random = exports.Plane = exports.Ray = exports.Bounds = exports.TransformFactory = exports.Quaternion = exports.Matrix4x4 = exports.Vector3 = exports.Vector2 = void 0;\nconst changeable_1 = require(\"./Core/changeable\");\nconst utils_1 = require(\"./Project/utils\");\nclass Vector2 extends changeable_1.Changeable {\n    get length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    constructor(...args) {\n        super();\n        this.x = 0;\n        this.y = 0;\n        if (args.length == 1) {\n            const vector_obj = args[0];\n            if (!(\"x\" in vector_obj) || !(\"y\" in vector_obj))\n                throw new TypeError(\"Trying to create Vector3 from unsupported object\");\n            this.UpdateFrom(vector_obj);\n            return;\n        }\n        else if (args.length == 2) {\n            if (args[0] == null || args[1] == null)\n                throw new TypeError(\"Trying to set null value for Vector2 property\");\n            this.x = args[0];\n            this.y = args[1];\n            return;\n        }\n    }\n    add(v) {\n        return new Vector2(this.x + v.x, this.y + v.y);\n    }\n    sub(v) {\n        return new Vector2(this.x - v.x, this.y - v.y);\n    }\n    mult(n) {\n        if (n instanceof Vector2)\n            return new Vector2(this.x * n.x, this.y * n.y);\n        return new Vector2(this.x * n, this.y * n);\n    }\n    div(n) {\n        if (n instanceof Vector2)\n            return new Vector2(this.x / n.x, this.y / n.y);\n        return new Vector2(this.x / n, this.y / n);\n    }\n    rotate(angle) {\n        const sin = Math.sin((angle / 180) * Math.PI);\n        const cos = Math.cos((angle / 180) * Math.PI);\n        return new Vector2(cos * this.x - sin * this.y, sin * this.x + cos * this.y);\n    }\n    setX(x) {\n        return new Vector2(x, this.y);\n    }\n    setY(y) {\n        return new Vector2(this.x, y);\n    }\n    static scale(v1, v2) {\n        return new Vector2(v1.x * v2.x, v1.y * v2.y);\n    }\n    static distance(v1, v2) {\n        const dv = v2.sub(v1);\n        return dv.length;\n    }\n    static lerp(from, to, t) {\n        if (t < 0)\n            t = 0;\n        if (t > 1)\n            t = 1;\n        return new Vector2(from.x + (to.x - from.x) * t, from.y + (to.y - from.y) * t);\n    }\n    isFinite() {\n        return Number.isFinite(this.x) && Number.isFinite(this.y);\n    }\n    isNaN() {\n        return isNaN(this.x) || isNaN(this.y);\n    }\n}\nexports.Vector2 = Vector2;\nclass Vector3 extends changeable_1.Changeable {\n    get length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    get normalized() {\n        return this.div(this.length);\n    }\n    constructor(...args) {\n        super();\n        if (args.length == 1) {\n            const vector_obj = args[0];\n            if (vector_obj instanceof Vector2) {\n                this.x = vector_obj.x;\n                this.y = vector_obj.y;\n                this.z = 0;\n                return;\n            }\n            else {\n                if (!(\"x\" in vector_obj) ||\n                    !(\"y\" in vector_obj) ||\n                    !(\"z\" in vector_obj))\n                    throw new TypeError(\"Trying to create Vector3 from unsupported object\");\n                this.x = vector_obj.x;\n                this.y = vector_obj.y;\n                this.z = vector_obj.z;\n                return;\n            }\n        }\n        else if (args.length == 3) {\n            if (args[0] == null || args[1] == null || args[2] == null)\n                throw new TypeError(\"Trying to set null value for Vector3 property\");\n            this.x = args[0];\n            this.y = args[1];\n            this.z = args[2];\n            return;\n        }\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n    }\n    normalizeAngles() {\n        const result = new Vector3();\n        result.x = Vector3.normalizeAngle(this.x);\n        result.y = Vector3.normalizeAngle(this.y);\n        result.z = Vector3.normalizeAngle(this.z);\n        return result;\n    }\n    static normalizeAngle(angle) {\n        while (angle > 360)\n            angle -= 360;\n        while (angle < 0)\n            angle += 360;\n        return angle;\n    }\n    add(v) {\n        return new Vector3(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    sub(v) {\n        return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n    div(n) {\n        if (n instanceof Vector3)\n            return new Vector3(this.x / n.x, this.y / n.y, this.z / n.z);\n        return new Vector3(this.x / n, this.y / n, this.z / n);\n    }\n    mult(n) {\n        return new Vector3(this.x * n, this.y * n, this.z * n);\n    }\n    inversed() {\n        return new Vector3(-this.x, -this.y, -this.z);\n    }\n    equals(v) {\n        return this.x === v.x && this.y === v.y && this.z === v.z;\n    }\n    abs() {\n        return new Vector3(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z));\n    }\n    isZero() {\n        return this.x === 0 && this.y === 0 && this.z === 0;\n    }\n    isFinite() {\n        return (Number.isFinite(this.x) &&\n            Number.isFinite(this.y) &&\n            Number.isFinite(this.z));\n    }\n    isNaN() {\n        return isNaN(this.x) || isNaN(this.y) || isNaN(this.z);\n    }\n    invertX() {\n        return new Vector3(-this.x, this.y, this.z);\n    }\n    invertY() {\n        return new Vector3(this.x, -this.y, this.z);\n    }\n    invertZ() {\n        return new Vector3(this.x, this.y, -this.z);\n    }\n    toRH() {\n        return this.invertX();\n    }\n    setX(x) {\n        return new Vector3(x, this.y, this.z);\n    }\n    setY(y) {\n        return new Vector3(this.x, y, this.z);\n    }\n    setZ(z) {\n        return new Vector3(this.x, this.y, z);\n    }\n    addX(x) {\n        return new Vector3(this.x + x, this.y, this.z);\n    }\n    addY(y) {\n        return new Vector3(this.x, this.y + y, this.z);\n    }\n    addZ(z) {\n        return new Vector3(this.x, this.y, this.z + z);\n    }\n    static get one() {\n        return new Vector3(1, 1, 1);\n    }\n    static cross(lhs, rhs) {\n        return new Vector3(lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x);\n    }\n    static dot(lhs, rhs) {\n        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\n    }\n    static scale(v1, v2) {\n        return new Vector3(v1.x * v2.x, v1.y * v2.y, v1.z * v2.z);\n    }\n    static clamp(value, min, max) {\n        if (value < min)\n            value = min;\n        else if (value > max)\n            value = max;\n        return value;\n    }\n    static angle(from, to) {\n        const num = Math.sqrt(from.length * from.length * to.length * to.length);\n        return num < 1.0000000036274937e-15\n            ? 0.0\n            : Math.acos(Vector3.clamp(Vector3.dot(from, to) / num, -1, 1)) *\n                57.29578;\n    }\n    static distance(from, to) {\n        const num1 = from.x - to.x;\n        const num2 = from.y - to.y;\n        const num3 = from.z - to.z;\n        return Math.sqrt(num1 * num1 + num2 * num2 + num3 * num3);\n    }\n    static lerp(from, to, t) {\n        if (t < 0)\n            t = 0;\n        if (t > 1)\n            t = 1;\n        return new Vector3(from.x + (to.x - from.x) * t, from.y + (to.y - from.y) * t, from.z + (to.z - from.z) * t);\n    }\n    xy() {\n        return new Vector2(this.x, this.y);\n    }\n    xz() {\n        return new Vector2(this.x, this.z);\n    }\n    zy() {\n        return new Vector2(this.z, this.y);\n    }\n}\nexports.Vector3 = Vector3;\nclass Matrix4x4 extends changeable_1.Changeable {\n    constructor() {\n        super();\n        this[0] = [1, 0, 0, 0];\n        this[1] = [0, 1, 0, 0];\n        this[2] = [0, 0, 1, 0];\n        this[3] = [0, 0, 0, 1];\n    }\n    mult(v) {\n        const res = new Vector3();\n        res.x = this[0][0] * v.x + this[0][1] * v.y + this[0][2] * v.z;\n        res.y = this[1][0] * v.x + this[1][1] * v.y + this[1][2] * v.z;\n        res.z = this[2][0] * v.x + this[2][1] * v.y + this[2][2] * v.z;\n        return res;\n    }\n}\nexports.Matrix4x4 = Matrix4x4;\nclass Quaternion extends changeable_1.Changeable {\n    constructor(...args) {\n        super();\n        if (args.length == 1) {\n            const quat_obj = args[0];\n            if (!(\"x\" in quat_obj) ||\n                !(\"y\" in quat_obj) ||\n                !(\"z\" in quat_obj) ||\n                !(\"w\" in quat_obj))\n                throw new TypeError(\"Trying to create Quaternion from unsupported object\");\n            this.x = quat_obj.x;\n            this.y = quat_obj.y;\n            this.z = quat_obj.z;\n            this.w = quat_obj.w;\n            return;\n        }\n        else if (args.length == 4) {\n            this.x = args[0];\n            this.y = args[1];\n            this.z = args[2];\n            this.w = args[3];\n            return;\n        }\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 1;\n    }\n    mult(q) {\n        const x = this.w * q.x + this.x * q.w + this.y * q.z - this.z * q.y;\n        const y = this.w * q.y + this.y * q.w + this.z * q.x - this.x * q.z;\n        const z = this.w * q.z + this.z * q.w + this.x * q.y - this.y * q.x;\n        const w = this.w * q.w - this.x * q.x - this.y * q.y - this.z * q.z;\n        return new Quaternion(x, y, z, w);\n    }\n    equals(v) {\n        return (this.x === v.x && this.y === v.y && this.z === v.z && this.w == v.w);\n    }\n    inversed() {\n        const ls = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n        const invNorm = 1.0 / ls;\n        const x = -this.x * invNorm;\n        const y = -this.y * invNorm;\n        const z = -this.z * invNorm;\n        const w = this.w * invNorm;\n        return new Quaternion(x, y, z, w);\n    }\n    get eulerAngles() {\n        const rad2deg = 180.0 / Math.PI;\n        const sqw = this.w * this.w;\n        const sqx = this.x * this.x;\n        const sqy = this.y * this.y;\n        const sqz = this.z * this.z;\n        const unit = sqx + sqy + sqz + sqw; // if normalised is one, otherwise is correction factor\n        const test = this.x * this.w - this.y * this.z;\n        let v = new Vector3();\n        if (test > 0.4995 * unit) {\n            // singularity at north pole\n            v.y = 2 * Math.atan2(this.y, this.x);\n            v.x = Math.PI / 2;\n            v.z = 0;\n            return v.mult(rad2deg).normalizeAngles();\n        }\n        if (test < -0.4995 * unit) {\n            // singularity at south pole\n            v.y = -2 * Math.atan2(this.y, this.x);\n            v.x = -Math.PI / 2;\n            v.z = 0;\n            return v.mult(rad2deg).normalizeAngles();\n        }\n        v.y = Math.atan2(2 * this.x * this.w + 2 * this.y * this.z, 1 - 2 * (this.z * this.z + this.w * this.w)); // Yaw\n        v.x = Math.asin(2 * (this.x * this.z - this.w * this.y)); // Pitch\n        v.z = Math.atan2(2 * this.x * this.y + 2 * this.z * this.w, 1 - 2 * (this.y * this.y + this.z * this.z)); // Roll\n        return v.mult(rad2deg).normalizeAngles();\n    }\n    toRH() {\n        return new Quaternion(this.x, -this.y, -this.z, this.w);\n    }\n    static euler(_x, _y, _z) {\n        const yaw = (_y / 180) * Math.PI;\n        const pitch = (_x / 180) * Math.PI;\n        const roll = (_z / 180) * Math.PI;\n        const rollOver2 = roll * 0.5;\n        const sinRollOver2 = Math.sin(rollOver2);\n        const cosRollOver2 = Math.cos(rollOver2);\n        const pitchOver2 = pitch * 0.5;\n        const sinPitchOver2 = Math.sin(pitchOver2);\n        const cosPitchOver2 = Math.cos(pitchOver2);\n        const yawOver2 = yaw * 0.5;\n        const sinYawOver2 = Math.sin(yawOver2);\n        const cosYawOver2 = Math.cos(yawOver2);\n        const w = cosYawOver2 * cosPitchOver2 * cosRollOver2 +\n            sinYawOver2 * sinPitchOver2 * sinRollOver2;\n        const x = cosYawOver2 * sinPitchOver2 * cosRollOver2 +\n            sinYawOver2 * cosPitchOver2 * sinRollOver2;\n        const y = sinYawOver2 * cosPitchOver2 * cosRollOver2 -\n            cosYawOver2 * sinPitchOver2 * sinRollOver2;\n        const z = cosYawOver2 * cosPitchOver2 * sinRollOver2 -\n            sinYawOver2 * sinPitchOver2 * cosRollOver2;\n        return new Quaternion(x, y, z, w);\n    }\n    static lookRotation(_forward, up) {\n        const vector = _forward.normalized;\n        const vector2 = Vector3.cross(up, vector).normalized;\n        const vector3 = Vector3.cross(vector, vector2);\n        const m00 = vector2.x;\n        const m01 = vector2.y;\n        const m02 = vector2.z;\n        const m10 = vector3.x;\n        const m11 = vector3.y;\n        const m12 = vector3.z;\n        const m20 = vector.x;\n        const m21 = vector.y;\n        const m22 = vector.z;\n        const num8 = m00 + m11 + m22;\n        const quaternion = new Quaternion(0, 0, 0, 1);\n        if (num8 > 0) {\n            let num = Math.sqrt(num8 + 1);\n            quaternion.w = num * 0.5;\n            num = 0.5 / num;\n            quaternion.x = (m12 - m21) * num;\n            quaternion.y = (m20 - m02) * num;\n            quaternion.z = (m01 - m10) * num;\n            return quaternion;\n        }\n        if (m00 >= m11 && m00 >= m22) {\n            const num7 = Math.sqrt(1 + m00 - m11 - m22);\n            const num4 = 0.5 / num7;\n            quaternion.x = 0.5 * num7;\n            quaternion.y = (m01 + m10) * num4;\n            quaternion.z = (m02 + m20) * num4;\n            quaternion.w = (m12 - m21) * num4;\n            return quaternion;\n        }\n        if (m11 > m22) {\n            const num6 = Math.sqrt(1 + m11 - m00 - m22);\n            const num3 = 0.5 / num6;\n            quaternion.x = (m10 + m01) * num3;\n            quaternion.y = 0.5 * num6;\n            quaternion.z = (m21 + m12) * num3;\n            quaternion.w = (m20 - m02) * num3;\n            return quaternion;\n        }\n        const num5 = Math.sqrt(1 + m22 - m00 - m11);\n        const num2 = 0.5 / num5;\n        quaternion.x = (m20 + m02) * num2;\n        quaternion.y = (m21 + m12) * num2;\n        quaternion.z = 0.5 * num5;\n        quaternion.w = (m01 - m10) * num2;\n        return quaternion;\n    }\n    rotate(vec) {\n        const num = this.x * 2;\n        const num2 = this.y * 2;\n        const num3 = this.z * 2;\n        const num4 = this.x * num;\n        const num5 = this.y * num2;\n        const num6 = this.z * num3;\n        const num7 = this.x * num2;\n        const num8 = this.x * num3;\n        const num9 = this.y * num3;\n        const num10 = this.w * num;\n        const num11 = this.w * num2;\n        const num12 = this.w * num3;\n        const result = {\n            x: (1 - (num5 + num6)) * vec.x +\n                (num7 - num12) * vec.y +\n                (num8 + num11) * vec.z,\n            y: (num7 + num12) * vec.x +\n                (1 - (num4 + num6)) * vec.y +\n                (num9 - num10) * vec.z,\n            z: (num8 - num11) * vec.x +\n                (num9 + num10) * vec.y +\n                (1 - (num4 + num5)) * vec.z,\n        };\n        return new Vector3(result);\n    }\n}\nexports.Quaternion = Quaternion;\nclass TransformFactory {\n    static CreateNew() {\n        return {\n            position: new Vector3(),\n            rotation: new Quaternion(),\n            scale: new Vector3(1, 1, 1),\n        };\n    }\n    static Create(raw) {\n        return {\n            position: raw[(0, utils_1.nameof)(\"position\")]\n                ? new Vector3(raw[(0, utils_1.nameof)(\"position\")])\n                : new Vector3(),\n            rotation: raw[(0, utils_1.nameof)(\"rotation\")]\n                ? new Quaternion(raw[(0, utils_1.nameof)(\"rotation\")])\n                : new Quaternion(),\n            scale: raw[(0, utils_1.nameof)(\"scale\")]\n                ? new Vector3(raw[(0, utils_1.nameof)(\"scale\")])\n                : new Vector3(1, 1, 1),\n        };\n    }\n}\nexports.TransformFactory = TransformFactory;\nclass Bounds extends changeable_1.Changeable {\n    get center() {\n        return this.min.add(this.size.div(2.0));\n    }\n    get size() {\n        return this.max.sub(this.min);\n    }\n    constructor(...args) {\n        super();\n        if (args.length == 0) {\n            this.min = new Vector3();\n            this.max = new Vector3();\n            return;\n        }\n        this.min = args[0];\n        this.max = args[1];\n    }\n    static default() {\n        return new Bounds(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n    }\n    static fromCenterAndSize(center, size) {\n        return new Bounds(center.sub(size.div(2.0)), center.add(size.div(2.0)));\n    }\n    encapsulate(b) {\n        this.min.x = Math.min(this.min.x, b.min.x);\n        this.min.y = Math.min(this.min.y, b.min.y);\n        this.min.z = Math.min(this.min.z, b.min.z);\n        this.max.x = Math.max(this.max.x, b.max.x);\n        this.max.y = Math.max(this.max.y, b.max.y);\n        this.max.z = Math.max(this.max.z, b.max.z);\n    }\n}\nexports.Bounds = Bounds;\nclass Ray {\n    constructor(...args) {\n        if (args.length == 0) {\n            this.origin = new Vector3();\n            this.direction = new Vector3();\n            return;\n        }\n        this.origin = args[0];\n        this.direction = args[1].normalized;\n    }\n    GetPoint(h) {\n        return this.origin.add(this.direction.mult(h));\n    }\n}\nexports.Ray = Ray;\nclass Plane {\n    constructor(...args) {\n        if (args.length == 0) {\n            this.normal = new Vector3();\n            this.distance = 0;\n            return;\n        }\n        this.normal = args[0];\n        this.distance = args[1];\n    }\n    raycast(ray) {\n        let result = {};\n        const a = Vector3.dot(ray.direction, this.normal);\n        const num = -Vector3.dot(ray.origin, this.normal) - this.distance;\n        if (Math.abs(a) < 0.0001) {\n            result.enter = 0;\n            result.result = false;\n            return result;\n        }\n        result.enter = num / a;\n        result.result = result.enter > 0;\n        return result;\n    }\n    getSide(point) {\n        return Vector3.dot(this.normal, point) + this.distance > 0;\n    }\n    static fromPoint(normal, point) {\n        const p = new Plane();\n        p.normal = normal.normalized;\n        p.distance = -Vector3.dot(p.normal, point);\n        return p;\n    }\n}\nexports.Plane = Plane;\nclass Random {\n    constructor(seed) {\n        this.seed = seed;\n    }\n    next() {\n        const x = Math.sin(this.seed++) * 10000;\n        return x - Math.floor(x);\n    }\n}\nexports.Random = Random;\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.iterateAsync = exports.safeStringify = exports.GetHash = exports.CreateUUID = void 0;\nexports.arraysMatchUnorderedBy = arraysMatchUnorderedBy;\nconst CreateUUID = function () {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n        const r = (Math.random() * 16) | 0, v = c === \"x\" ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n};\nexports.CreateUUID = CreateUUID;\nconst GetHash = function (s) {\n    let hash = 0, i, chr;\n    if (s.length === 0)\n        return hash;\n    for (i = 0; i < s.length; i++) {\n        chr = s.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0;\n    }\n    return hash;\n};\nexports.GetHash = GetHash;\nlet safeStringify = function (obj, indent = 0) {\n    let cache = [];\n    const retVal = JSON.stringify(obj, function (key, value) {\n        if (typeof value === \"object\" && value != null && cache.includes(value))\n            return undefined;\n        cache.push(value);\n        return value;\n    }, indent);\n    cache = [];\n    return retVal;\n};\nexports.safeStringify = safeStringify;\nlet iterateAsync = function (array, cb, platform) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (platform == \"web\") {\n            yield Promise.all(array.map(cb));\n        }\n        else {\n            for (const element of array) {\n                yield cb(element);\n            }\n        }\n    });\n};\nexports.iterateAsync = iterateAsync;\nfunction arraysMatchUnorderedBy(arr1, arr2, predicate) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    const used = new Set();\n    for (const a of arr1) {\n        let found = false;\n        for (let i = 0; i < arr2.length; i++) {\n            if (used.has(i))\n                continue;\n            if (predicate(a, arr2[i])) {\n                used.add(i);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return false;\n        }\n    }\n    return true;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":[],"sourceRoot":""}